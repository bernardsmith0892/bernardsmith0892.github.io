<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-US"><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="https://bernardsmith0892.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://bernardsmith0892.github.io/" rel="alternate" type="text/html" hreflang="en-US" /><updated>2021-09-18T19:45:38-10:00</updated><id>https://bernardsmith0892.github.io/feed.xml</id><title type="html">Bernard Smith</title><subtitle>Mostly technology-related</subtitle><entry><title type="html">Hack-A-Sat 2: tree in the forest</title><link href="https://bernardsmith0892.github.io/posts/hackasat2-forest/" rel="alternate" type="text/html" title="Hack-A-Sat 2: tree in the forest" /><published>2021-06-29T22:00:00-10:00</published><updated>2021-06-29T22:00:00-10:00</updated><id>https://bernardsmith0892.github.io/posts/hackasat2-forest</id><content type="html" xml:base="https://bernardsmith0892.github.io/posts/hackasat2-forest/">&lt;h1 id=&quot;tree-in-the-forest-rapid-unplanned-disassembly&quot;&gt;tree in the forest (Rapid Unplanned Disassembly)&lt;/h1&gt;

&lt;p&gt;Upon connecting to the challenge and providing our ticket, we’re presented with a simple message.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;Starting up Service on udp:18.222.149.188:12752
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We can connect to this server using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nc -u 18.222.149.188 12752&lt;/code&gt; and see what the challenge looks like. After experimenting with a bit of random input, we can quickly see that the server is expecting &lt;em&gt;8 bytes&lt;/em&gt; of input.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;$ nc -u 18.222.149.188 12752
555555
Invalid length of command header, expected 8 but got 7
5555555
Command header acknowledge: version:13621 type:13621 id:171259189
Invalid id:171259189
55555555
Command header acknowledge: version:13621 type:13621 id:892679477
Invalid id:892679477
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The challenge page provides us with the source code (&lt;a href=&quot;https://bernardsmith0892.github.io/assets/files/parser.c&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;parser.c&lt;/code&gt;&lt;/a&gt;) for this server, which easily illuminates what’s going on. The server is expecting us to provide a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;command_header&lt;/code&gt; struct composed of three values:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A 16-bit integer for the version of the command. Not used within the program.&lt;/li&gt;
  &lt;li&gt;A 16-bit integer for the type of the command.  Not used within the program.&lt;/li&gt;
  &lt;li&gt;A 32-bit integer for the ID of the command. This is the only value used by the program. Valid IDs are defined within the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;command_id_type&lt;/code&gt; enum.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Looking through the possible IDs, the most interesting one is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;COMMAND_GETKEYS&lt;/code&gt; with an ID of 9. This command is what will order the server to print out the flag. However, the server has locked down this functionality on startup using a variable &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lock_state&lt;/code&gt; initialized to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LOCKED&lt;/code&gt; - a value of 1. Until we can set this variable to 0, the server will refuse to print out the flag.&lt;/p&gt;

&lt;p&gt;After analyzing the source code for this server, we discover the vulnerable portion of this code on line 134, which is:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c1&quot;&gt;// Log the message in the command log&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;command_log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;header&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Under normal operations, this array is simply used to track how many times a certain command ID has been received. For instance, to see how many times &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;COMMAND_GETKEYS&lt;/code&gt; has been issued, we would access &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;command_log[9]&lt;/code&gt;. What makes this exploitable is that &lt;strong&gt;C&lt;/strong&gt; and &lt;strong&gt;C++&lt;/strong&gt; do not perform bounds-checking by default when accessing an array. In addition, we have full control over what ID is sent to this line of code. So by providing a value outside the bounds of this array, such as negative values, we can modify any memory throughout the program.&lt;/p&gt;

&lt;p&gt;Our goal is to determine how many bytes before or after &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;command_log&lt;/code&gt; is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lock_state&lt;/code&gt; located. By knowing this, we will be able to determine the correct ID to use in order to modify the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lock_state&lt;/code&gt; value. To assist in our analysis, we can compile the provided source code using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;g++&lt;/code&gt; and debug it using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gdb&lt;/code&gt;. But before doing this, we uncomment lines 157 and 158 to display the memory addresses for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lock_state&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;command_log&lt;/code&gt; when we run the program.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;$ g++ parser.c

$ ./a.out
Address of lock_state:       0x56070625c130
Address of command_log: 0x56070625c138
Trying to bind to socket.
Bound to socket.
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Looking at this, we can see that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lock_state&lt;/code&gt; is only 8 bytes behind &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;command_log&lt;/code&gt;. So by sending an ID value of -8, we will be able to increment the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lock_state&lt;/code&gt; variable by 1 on every command. The issue right now is that we can only &lt;em&gt;increase&lt;/em&gt; the value of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lock_state&lt;/code&gt;. Since &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lock_state&lt;/code&gt; starts at 1, we will need to &lt;em&gt;overflow&lt;/em&gt; this byte in order to reach our desired value of 0. Thankfully, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;command_log&lt;/code&gt; is defined as an array of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;char&lt;/code&gt; values, so its max value is only 255.&lt;/p&gt;

&lt;p&gt;One thing to note is that until now, we’ve only been directly typing input for the server into a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nc&lt;/code&gt; session. However, since the server only looks at the underlying bytes it receives, it’ll interpret our “-8” as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x382d0000&lt;/code&gt;. So to send a properly formatted payload, we will need to create a simple Python script to construct our message at the byte-level and send it to the server. This is a very simple task using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pwntools&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;pwn&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;io&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;remote&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'0.0.0.0'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;54321&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;typ&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'udp'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;io&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sign&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'signed'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;io&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;recvline&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;io&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;recvline&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Using this script, we can validate the exploitation method by examining the server’s memory with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gdb&lt;/code&gt;. In the following demo, we send the malicious &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;command_header&lt;/code&gt; a few times to demonstrate how we’re able to increment the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lock_state&lt;/code&gt; variable.&lt;/p&gt;

&lt;script id=&quot;asciicast-cnSjOv7IP0MIXkBp7hoyh11VU&quot; src=&quot;https://asciinema.org/a/cnSjOv7IP0MIXkBp7hoyh11VU.js&quot; async=&quot;&quot;&gt;&lt;/script&gt;

&lt;p&gt;The next demo shows how the value overflows after 255 commands.&lt;/p&gt;

&lt;script id=&quot;asciicast-2AfnwYOQjo8awlTQpwTXMaTRn&quot; src=&quot;https://asciinema.org/a/2AfnwYOQjo8awlTQpwTXMaTRn.js&quot; async=&quot;&quot;&gt;&lt;/script&gt;

&lt;p&gt;Finally, we can send our &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GETKEYS&lt;/code&gt; command and retrieve the flag from the server. The following demo shows us running the final exploit script (&lt;a href=&quot;https://bernardsmith0892.github.io/assets/files/forest.py&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;forest.py&lt;/code&gt;&lt;/a&gt;):&lt;/p&gt;

&lt;script id=&quot;asciicast-3NviNO3HUdzmcZoNWw4MhhO8w&quot; src=&quot;https://asciinema.org/a/3NviNO3HUdzmcZoNWw4MhhO8w.js&quot; async=&quot;&quot;&gt;&lt;/script&gt;</content><author><name></name></author><category term="CTF" /><category term="HackASat2" /><category term="reverse_engineering" /><summary type="html">tree in the forest (Rapid Unplanned Disassembly) Upon connecting to the challenge and providing our ticket, we’re presented with a simple message. 1 Starting up Service on udp:18.222.149.188:12752 We can connect to this server using nc -u 18.222.149.188 12752 and see what the challenge looks like. After experimenting with a bit of random input, we can quickly see that the server is expecting 8 bytes of input. 1 2 3 4 5 6 7 8 9 $ nc -u 18.222.149.188 12752 555555 Invalid length of command header, expected 8 but got 7 5555555 Command header acknowledge: version:13621 type:13621 id:171259189 Invalid id:171259189 55555555 Command header acknowledge: version:13621 type:13621 id:892679477 Invalid id:892679477 The challenge page provides us with the source code (parser.c) for this server, which easily illuminates what’s going on. The server is expecting us to provide a command_header struct composed of three values: A 16-bit integer for the version of the command. Not used within the program. A 16-bit integer for the type of the command. Not used within the program. A 32-bit integer for the ID of the command. This is the only value used by the program. Valid IDs are defined within the command_id_type enum. Looking through the possible IDs, the most interesting one is COMMAND_GETKEYS with an ID of 9. This command is what will order the server to print out the flag. However, the server has locked down this functionality on startup using a variable lock_state initialized to LOCKED - a value of 1. Until we can set this variable to 0, the server will refuse to print out the flag. After analyzing the source code for this server, we discover the vulnerable portion of this code on line 134, which is: 1 2 // Log the message in the command log command_log[header-&amp;gt;id]++; Under normal operations, this array is simply used to track how many times a certain command ID has been received. For instance, to see how many times COMMAND_GETKEYS has been issued, we would access command_log[9]. What makes this exploitable is that C and C++ do not perform bounds-checking by default when accessing an array. In addition, we have full control over what ID is sent to this line of code. So by providing a value outside the bounds of this array, such as negative values, we can modify any memory throughout the program. Our goal is to determine how many bytes before or after command_log is lock_state located. By knowing this, we will be able to determine the correct ID to use in order to modify the lock_state value. To assist in our analysis, we can compile the provided source code using g++ and debug it using gdb. But before doing this, we uncomment lines 157 and 158 to display the memory addresses for lock_state and command_log when we run the program. 1 2 3 4 5 6 7 $ g++ parser.c $ ./a.out Address of lock_state: 0x56070625c130 Address of command_log: 0x56070625c138 Trying to bind to socket. Bound to socket. Looking at this, we can see that lock_state is only 8 bytes behind command_log. So by sending an ID value of -8, we will be able to increment the lock_state variable by 1 on every command. The issue right now is that we can only increase the value of lock_state. Since lock_state starts at 1, we will need to overflow this byte in order to reach our desired value of 0. Thankfully, command_log is defined as an array of char values, so its max value is only 255. One thing to note is that until now, we’ve only been directly typing input for the server into a nc session. However, since the server only looks at the underlying bytes it receives, it’ll interpret our “-8” as 0x382d0000. So to send a properly formatted payload, we will need to create a simple Python script to construct our message at the byte-level and send it to the server. This is a very simple task using pwntools. 1 2 3 4 5 6 from pwn import * io = remote('0.0.0.0', 54321, typ='udp') io.send( p16(1) + p16(1) + p32(-8, sign='signed') ) print(io.recvline()) print(io.recvline()) Using this script, we can validate the exploitation method by examining the server’s memory with gdb. In the following demo, we send the malicious command_header a few times to demonstrate how we’re able to increment the lock_state variable. The next demo shows how the value overflows after 255 commands. Finally, we can send our GETKEYS command and retrieve the flag from the server. The following demo shows us running the final exploit script (forest.py):</summary></entry><entry><title type="html">All-Army CyberStakes 4 - Cryptography (Headpiece Silver)</title><link href="https://bernardsmith0892.github.io/posts/acictf4-headpiece-silver/" rel="alternate" type="text/html" title="All-Army CyberStakes 4 - Cryptography (Headpiece Silver)" /><published>2020-05-16T04:00:00-10:00</published><updated>2020-05-16T04:00:00-10:00</updated><id>https://bernardsmith0892.github.io/posts/acictf4-headpiece-silver</id><content type="html" xml:base="https://bernardsmith0892.github.io/posts/acictf4-headpiece-silver/">&lt;h1 id=&quot;headpiece-silver-250-points&quot;&gt;Headpiece Silver (250 Points)&lt;/h1&gt;

&lt;p&gt;This challenge provides us with a server to interact with at challenge.acictf.com:30151. (&lt;em&gt;Your port number may differ&lt;/em&gt;) To get started, lets see what this server is about by connecting to it using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ncat&lt;/code&gt;.&lt;/p&gt;

&lt;script id=&quot;asciicast-sNd3fjZW4f9c69nYw88Ieu4G8&quot; src=&quot;https://asciinema.org/a/sNd3fjZW4f9c69nYw88Ieu4G8.js&quot; async=&quot;&quot; data-rows=&quot;20&quot;&gt;&lt;/script&gt;

&lt;p&gt;Based on this information given to us, this is clearly another &lt;em&gt;RSA&lt;/em&gt; related challenge. The server provides us with the components for a &lt;em&gt;public key&lt;/em&gt;, the public modulus &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;N&lt;/code&gt;, and the public exponent &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;e&lt;/code&gt;, which are:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;N: 122298190177919866881639090045815514691491489519639425496178483984084352945237
e: 65537
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If we can derive the &lt;em&gt;private key&lt;/em&gt; from this &lt;em&gt;public key&lt;/em&gt;, we will be able to decrypt the encrypted password they provided to us, which is: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;985be9b7b845a1a09a916437d767c30ae8d7ad4987cb77b0602b04889f7c2301&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Normally, computing the &lt;em&gt;private key&lt;/em&gt; from just the &lt;em&gt;public key&lt;/em&gt; is nearly impossible. However, what makes the key provided here different is in the &lt;em&gt;key length&lt;/em&gt;. Most RSA keys are used today are &lt;strong&gt;2048-bit&lt;/strong&gt; keys, which are practically impossible for current computers to decrypt. But the key provided by the server is only around a &lt;strong&gt;256-bit&lt;/strong&gt; key, which is vastly weaker than what is needed for proper security. To fully compare the strengths of these two key lengths, we need to determine how many &lt;em&gt;bits of security&lt;/em&gt; these keys would have. Since RSA is based on the &lt;em&gt;factoring problem&lt;/em&gt;, brute-forcing an RSA key doesn’t require you to test &lt;strong&gt;all&lt;/strong&gt; possible numbers, unlike &lt;a href=&quot;https://en.wikipedia.org/wiki/Advanced_Encryption_Standard&quot;&gt;AES&lt;/a&gt; where you’d need to check every possible key. So while &lt;em&gt;AES-256&lt;/em&gt; has &lt;em&gt;256-bit security&lt;/em&gt;, 2048-bit RSA key doesn’t have 2048-bit security.&lt;/p&gt;

&lt;p&gt;According to &lt;a href=&quot;https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-57pt1r5.pdf&quot;&gt;NIST (p. 54)&lt;/a&gt;, a 2048-bit RSA key only offers about &lt;strong&gt;112-bit security&lt;/strong&gt;. And while 256-bit RSA is so weak that it isn’t even considered in the NIST publication, &lt;a href=&quot;https://crypto.stackexchange.com/questions/8687/security-strength-of-rsa-in-relation-with-the-modulus-size&quot;&gt;this StackExchange&lt;/a&gt; question tells us that &lt;a href=&quot;https://www.wolframalpha.com/input/?i=N%5BLog2%5BExp%5B%2864%2F9*Log%5B2%5E256%5D%29%5E%281%2F3%29*%28Log%5BLog%5B2%5E256%5D%5D%29%5E%282%2F3%29%5D%5D%5D&quot;&gt;256-bit RSA&lt;/a&gt; only offers around &lt;strong&gt;46-bit security&lt;/strong&gt;. Each extra bit of security makes a key twice as secure, so 256-bit RSA is &lt;em&gt;twice&lt;/em&gt; as easy to break than a key with &lt;em&gt;47-bit security&lt;/em&gt;. Now compared to 2048-bit RSA, 256-bit RSA is about &lt;em&gt;73 quintillion&lt;/em&gt; times easier to break, or &lt;em&gt;73786976294838206464&lt;/em&gt; times easier.&lt;/p&gt;

&lt;p&gt;Now to how we can actually break the key. &lt;a href=&quot;https://github.com/Ganapati/RsaCtfTool&quot;&gt;RsaCtfTool&lt;/a&gt; makes this task very easy. We can provide the &lt;em&gt;public key&lt;/em&gt; components, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;N&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;e&lt;/code&gt;, and the &lt;em&gt;ciphertext&lt;/em&gt; in decimal to this tool in order to quickly derive the &lt;em&gt;private key&lt;/em&gt; and &lt;em&gt;plaintext&lt;/em&gt;. (&lt;em&gt;Note: It appears the challenge’s modulus is now in &lt;a href=&quot;http://factordb.com/index.php?query=122298190177919866881639090045815514691491489519639425496178483984084352945237&quot;&gt;FactorDB&lt;/a&gt;, so RsaCtfTool isn’t conducting the full attack)&lt;/em&gt;.&lt;/p&gt;

&lt;script id=&quot;asciicast-rfequzN91lhn6WrsCDyYnTD34&quot; src=&quot;https://asciinema.org/a/rfequzN91lhn6WrsCDyYnTD34.js&quot; async=&quot;&quot; data-rows=&quot;20&quot;&gt;&lt;/script&gt;

&lt;p&gt;We can see the plaintext password at the end of the unciphered data: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;4n1a5ebRFmtyysAe&lt;/code&gt;. By providing this password to the server, we can retrieve the flag: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ACI{ad94502b4d2437193e9c3fed364}&lt;/code&gt;&lt;/p&gt;

&lt;script id=&quot;asciicast-jeYy2ox48alc3qVHwKL5BTufE&quot; src=&quot;https://asciinema.org/a/jeYy2ox48alc3qVHwKL5BTufE.js&quot; async=&quot;&quot; data-rows=&quot;20&quot;&gt;&lt;/script&gt;

&lt;h2 id=&quot;bonus-solution&quot;&gt;Bonus Solution&lt;/h2&gt;

&lt;p&gt;As it turns out, like many real-world systems, the challenge’s server has a &lt;em&gt;misconfiguration&lt;/em&gt; vulnerability that allows you to skip all of this. What we didn’t check in the previous steps was the fourth option to &lt;em&gt;test ciphertext&lt;/em&gt;. It appears that this was supposed to serve as a &lt;em&gt;decryption oracle&lt;/em&gt; that decrypts whatever you provide it using the server’s private key. However, since the &lt;em&gt;password ciphertext&lt;/em&gt; is encrypted with the public key, we are able to use this test function to simply have the server decrypt the password ciphertext itself.&lt;/p&gt;

&lt;script id=&quot;asciicast-2h6fYvAV9BvBDJYhw3PqUrtN2&quot; src=&quot;https://asciinema.org/a/2h6fYvAV9BvBDJYhw3PqUrtN2.js&quot; async=&quot;&quot; data-rows=&quot;20&quot;&gt;&lt;/script&gt;</content><author><name></name></author><category term="CTF" /><category term="AllArmyCyberStakes4" /><category term="cryptography" /><summary type="html">Headpiece Silver (250 Points) This challenge provides us with a server to interact with at challenge.acictf.com:30151. (Your port number may differ) To get started, lets see what this server is about by connecting to it using ncat. Based on this information given to us, this is clearly another RSA related challenge. The server provides us with the components for a public key, the public modulus N, and the public exponent e, which are: 1 2 N: 122298190177919866881639090045815514691491489519639425496178483984084352945237 e: 65537 If we can derive the private key from this public key, we will be able to decrypt the encrypted password they provided to us, which is: 985be9b7b845a1a09a916437d767c30ae8d7ad4987cb77b0602b04889f7c2301 Normally, computing the private key from just the public key is nearly impossible. However, what makes the key provided here different is in the key length. Most RSA keys are used today are 2048-bit keys, which are practically impossible for current computers to decrypt. But the key provided by the server is only around a 256-bit key, which is vastly weaker than what is needed for proper security. To fully compare the strengths of these two key lengths, we need to determine how many bits of security these keys would have. Since RSA is based on the factoring problem, brute-forcing an RSA key doesn’t require you to test all possible numbers, unlike AES where you’d need to check every possible key. So while AES-256 has 256-bit security, 2048-bit RSA key doesn’t have 2048-bit security. According to NIST (p. 54), a 2048-bit RSA key only offers about 112-bit security. And while 256-bit RSA is so weak that it isn’t even considered in the NIST publication, this StackExchange question tells us that 256-bit RSA only offers around 46-bit security. Each extra bit of security makes a key twice as secure, so 256-bit RSA is twice as easy to break than a key with 47-bit security. Now compared to 2048-bit RSA, 256-bit RSA is about 73 quintillion times easier to break, or 73786976294838206464 times easier. Now to how we can actually break the key. RsaCtfTool makes this task very easy. We can provide the public key components, N and e, and the ciphertext in decimal to this tool in order to quickly derive the private key and plaintext. (Note: It appears the challenge’s modulus is now in FactorDB, so RsaCtfTool isn’t conducting the full attack). We can see the plaintext password at the end of the unciphered data: 4n1a5ebRFmtyysAe. By providing this password to the server, we can retrieve the flag: ACI{ad94502b4d2437193e9c3fed364} Bonus Solution As it turns out, like many real-world systems, the challenge’s server has a misconfiguration vulnerability that allows you to skip all of this. What we didn’t check in the previous steps was the fourth option to test ciphertext. It appears that this was supposed to serve as a decryption oracle that decrypts whatever you provide it using the server’s private key. However, since the password ciphertext is encrypted with the public key, we are able to use this test function to simply have the server decrypt the password ciphertext itself.</summary></entry><entry><title type="html">All-Army CyberStakes 4 - Cryptography (Speak Plainly)</title><link href="https://bernardsmith0892.github.io/posts/acictf4-speakplainly/" rel="alternate" type="text/html" title="All-Army CyberStakes 4 - Cryptography (Speak Plainly)" /><published>2020-05-16T03:00:00-10:00</published><updated>2020-05-16T03:00:00-10:00</updated><id>https://bernardsmith0892.github.io/posts/acictf4-speakplainly</id><content type="html" xml:base="https://bernardsmith0892.github.io/posts/acictf4-speakplainly/">&lt;h1 id=&quot;speak-plainly-150-points&quot;&gt;Speak Plainly (150 Points)&lt;/h1&gt;

&lt;p&gt;This problem diverts from the previous ones by providing us with a website instead. The hints bring a lot of attention to the website’s login cookies, so we try creating an account and examining the created cookies. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;auth_token&lt;/code&gt; in particular stands out since it’s not a standard cookie that’s seen on other sites.&lt;/p&gt;

&lt;figure&gt;
  &lt;img src=&quot;https://bernardsmith0892.github.io/assets/imgs/speakplainly/login.png&quot; alt=&quot;Logging In&quot; /&gt;
  &lt;figcaption&gt;Creating an account.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;figure&gt;
  &lt;img src=&quot;https://bernardsmith0892.github.io/assets/imgs/speakplainly/cookies.png&quot; alt=&quot;Cookies&quot; /&gt;
  &lt;figcaption&gt;The list of site cookies from the Chrome DevTools menu.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;After creating an account, the website tells us it’ll give us the flag after we provide it with the &lt;em&gt;StrongToken&lt;/em&gt;. The home page has several information blocks that give us a few hints about what this could mean:&lt;/p&gt;

&lt;figure&gt;
  &lt;img src=&quot;https://bernardsmith0892.github.io/assets/imgs/speakplainly/encryption-info.png&quot; alt=&quot;Speak Plainly Hints&quot; /&gt;
  &lt;figcaption&gt;Information blocks from the website's main menu.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;auth_token&lt;/code&gt; is encrypted with a 128-bit key in &lt;a href=&quot;https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Electronic_codebook_(ECB)&quot;&gt;AES-ECB&lt;/a&gt; mode.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Prior to encryption, the site appends a &lt;em&gt;StrongToken&lt;/em&gt; to the data and then encrypts it.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Since the site is using &lt;em&gt;Electronic Code Book (ECB) mode&lt;/em&gt;, we can perform a &lt;em&gt;chosen-plaintext attack&lt;/em&gt; by using the account creation process as an &lt;em&gt;encryption oracle&lt;/em&gt;. This will allows us to extract the &lt;em&gt;StrongToken&lt;/em&gt;, byte-by-byte. The entire attack process is well-explained in a blog post by &lt;a href=&quot;https://zachgrace.com/posts/attacking-ecb/&quot;&gt;Zach Grace&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Since we’re going to be using the account creation feature quite a bit, we should figure out a way to make the process easier for us. &lt;em&gt;Burp Suite&lt;/em&gt; has a feature called &lt;em&gt;Repeater&lt;/em&gt; that allows us to save a web request and repeatedly modify and resend it, rather than repeating the process in the web browser.&lt;/p&gt;

&lt;figure&gt;
  &lt;img src=&quot;https://bernardsmith0892.github.io/assets/imgs/speakplainly/burp-history.png&quot; alt=&quot;Burp Suite History&quot; /&gt;
  &lt;figcaption&gt;Finding the web request to repeat in the history menu.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;figure&gt;
  &lt;img src=&quot;https://bernardsmith0892.github.io/assets/imgs/speakplainly/burp-choose-repeater.png&quot; alt=&quot;Burp Suite Repeater Option&quot; /&gt;
  &lt;figcaption&gt;Selecting the &lt;i&gt;Send to Repeater&lt;/i&gt; option.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;figure&gt;
  &lt;img src=&quot;https://bernardsmith0892.github.io/assets/imgs/speakplainly/burp-repeater.png&quot; alt=&quot;Burp Suite Repeater&quot; /&gt;
  &lt;figcaption&gt;Modifying the request and seeing the &lt;code&gt;auth_token&lt;/code&gt; change in the response.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Our first step is to figure out exactly what’s being encrypted. We know it comes from the account information, so there’s only two real options: the username and password. By testing out two accounts with the same username but different passwords, we can see that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;auth_token&lt;/code&gt; doesn’t change as long as the username stays the same. With this, we can determine that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;auth_token&lt;/code&gt; only uses the username in its encryption.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;testusername:password = 958af5df8adcc6bb0abf0473f6be9bb7684387617f292c4d7e1f689f7f5bf19d
testusername:newpass  = 958af5df8adcc6bb0abf0473f6be9bb7684387617f292c4d7e1f689f7f5bf19d
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The next step is to determine the encryption &lt;em&gt;block size&lt;/em&gt;. By testing out a few different inputs, we can quickly see that ciphertext is added in &lt;strong&gt;16 byte&lt;/strong&gt; blocks.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;AAAAAAAAAAAAAAA  (15 As) = a764ad6331f1ed698044b8f4bf208dd7 73ad7e84d6e3bb6e8c85112732e0160a
AAAAAAAAAAAAAAAA (16 As) = e5a8d39cc17dd336ac0c0fd443ca5089 23101bd6e92b9703b48b69d5a1d01460 68a9e1b3e5368dc2725eb057cc397065
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Our next step is to figure out the offset between the start of the encrypted data, and where our input begins. We start by sending 2 blocks (32 bytes) of the same information, and then prepending that input with padding characters until we can see two blocks in a row of the same encrypted data. It will also let us estimate the size of the &lt;em&gt;StrongToken&lt;/em&gt; by seeing how much many more blocks appear after the matching blocks.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;AAAAAAAAAAAAAAAA AAAAAAAAAAAAAAAA = e5a8d39cc17dd336ac0c0fd443ca5089 e5a8d39cc17dd336ac0c0fd443ca5089 23101bd6e92b9703b48b69d5a1d01460 68a9e1b3e5368dc2725eb057cc397065
[None]                   = 23101bd6e92b9703b48b69d5a1d01460 68a9e1b3e5368dc2725eb057cc397065
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;These results immediately show that there is no offset between the start of the plaintext and the username, since the first two blocks are already the same without any padding needed. Now that we know the block size and offset, we can begin brute-forcing the &lt;em&gt;StrongToken&lt;/em&gt;. We first provide an input one byte smaller than the block size, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AAAAAAAAAAAAAAA&lt;/code&gt;. This creates a ciphertext block using the plaintext &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AAAAAAAAAAAAAAA?&lt;/code&gt;, where &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;?&lt;/code&gt; is the first byte of the &lt;em&gt;StrongToken&lt;/em&gt;. Using the ciphertext block provided by the website as a &lt;em&gt;reference output&lt;/em&gt;, we can brute-force the first byte of the &lt;em&gt;StrongToken&lt;/em&gt;. By using the &lt;em&gt;reference input&lt;/em&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AAAAAAAAAAAAAAA&lt;/code&gt;, and iterating through all possible characters for the last byte, we can determine what the &lt;em&gt;StrongToken’s&lt;/em&gt; first byte when our output matches the &lt;em&gt;reference output&lt;/em&gt;.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;Reference Value:
AAAAAAAAAAAAAAA  = a764ad6331f1ed698044b8f4bf208dd7

Brute-Forcing:
AAAAAAAAAAAAAAA! = d4e420b6abd4e19033ed1fdea60dabdb
AAAAAAAAAAAAAAA&quot; = caee4360f81620169c15d01da4064629
[...snip...]
AAAAAAAAAAAAAAA: = 0c775d6e025a1ad985ac8c339e261a47
AAAAAAAAAAAAAAA; = a764ad6331f1ed698044b8f4bf208dd7
** MATCH **
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;By repeating this process and replacing more of the reference input with discovered &lt;em&gt;StrongToken&lt;/em&gt; characters, we can slowly determine the &lt;em&gt;StrongToken&lt;/em&gt; byte-by-byte. Using a Python script also makes this process less arduous. With this process, we are able to determine that the full &lt;em&gt;StrongToken&lt;/em&gt; is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fY5V/=B80?e4.CA8&lt;/code&gt;. (&lt;em&gt;The initial character &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;;&lt;/code&gt; is only used as a divider between the plaintext and the StrongToken&lt;/em&gt;) By submitting the token to the website, we are able to receive the flag.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;Correct! The Flag is: ACI{c0db96acd85091480db76ed49ca}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><category term="CTF" /><category term="AllArmyCyberStakes4" /><category term="cryptography" /><summary type="html">Speak Plainly (150 Points) This problem diverts from the previous ones by providing us with a website instead. The hints bring a lot of attention to the website’s login cookies, so we try creating an account and examining the created cookies. auth_token in particular stands out since it’s not a standard cookie that’s seen on other sites. Creating an account. The list of site cookies from the Chrome DevTools menu. After creating an account, the website tells us it’ll give us the flag after we provide it with the StrongToken. The home page has several information blocks that give us a few hints about what this could mean: Information blocks from the website's main menu. auth_token is encrypted with a 128-bit key in AES-ECB mode. Prior to encryption, the site appends a StrongToken to the data and then encrypts it. Since the site is using Electronic Code Book (ECB) mode, we can perform a chosen-plaintext attack by using the account creation process as an encryption oracle. This will allows us to extract the StrongToken, byte-by-byte. The entire attack process is well-explained in a blog post by Zach Grace. Since we’re going to be using the account creation feature quite a bit, we should figure out a way to make the process easier for us. Burp Suite has a feature called Repeater that allows us to save a web request and repeatedly modify and resend it, rather than repeating the process in the web browser. Finding the web request to repeat in the history menu. Selecting the Send to Repeater option. Modifying the request and seeing the auth_token change in the response. Our first step is to figure out exactly what’s being encrypted. We know it comes from the account information, so there’s only two real options: the username and password. By testing out two accounts with the same username but different passwords, we can see that auth_token doesn’t change as long as the username stays the same. With this, we can determine that auth_token only uses the username in its encryption. 1 2 testusername:password = 958af5df8adcc6bb0abf0473f6be9bb7684387617f292c4d7e1f689f7f5bf19d testusername:newpass = 958af5df8adcc6bb0abf0473f6be9bb7684387617f292c4d7e1f689f7f5bf19d The next step is to determine the encryption block size. By testing out a few different inputs, we can quickly see that ciphertext is added in 16 byte blocks. 1 2 AAAAAAAAAAAAAAA (15 As) = a764ad6331f1ed698044b8f4bf208dd7 73ad7e84d6e3bb6e8c85112732e0160a AAAAAAAAAAAAAAAA (16 As) = e5a8d39cc17dd336ac0c0fd443ca5089 23101bd6e92b9703b48b69d5a1d01460 68a9e1b3e5368dc2725eb057cc397065 Our next step is to figure out the offset between the start of the encrypted data, and where our input begins. We start by sending 2 blocks (32 bytes) of the same information, and then prepending that input with padding characters until we can see two blocks in a row of the same encrypted data. It will also let us estimate the size of the StrongToken by seeing how much many more blocks appear after the matching blocks. 1 2 AAAAAAAAAAAAAAAA AAAAAAAAAAAAAAAA = e5a8d39cc17dd336ac0c0fd443ca5089 e5a8d39cc17dd336ac0c0fd443ca5089 23101bd6e92b9703b48b69d5a1d01460 68a9e1b3e5368dc2725eb057cc397065 [None] = 23101bd6e92b9703b48b69d5a1d01460 68a9e1b3e5368dc2725eb057cc397065 These results immediately show that there is no offset between the start of the plaintext and the username, since the first two blocks are already the same without any padding needed. Now that we know the block size and offset, we can begin brute-forcing the StrongToken. We first provide an input one byte smaller than the block size, AAAAAAAAAAAAAAA. This creates a ciphertext block using the plaintext AAAAAAAAAAAAAAA?, where ? is the first byte of the StrongToken. Using the ciphertext block provided by the website as a reference output, we can brute-force the first byte of the StrongToken. By using the reference input, AAAAAAAAAAAAAAA, and iterating through all possible characters for the last byte, we can determine what the StrongToken’s first byte when our output matches the reference output. 1 2 3 4 5 6 7 8 9 10 Reference Value: AAAAAAAAAAAAAAA = a764ad6331f1ed698044b8f4bf208dd7 Brute-Forcing: AAAAAAAAAAAAAAA! = d4e420b6abd4e19033ed1fdea60dabdb AAAAAAAAAAAAAAA&quot; = caee4360f81620169c15d01da4064629 [...snip...] AAAAAAAAAAAAAAA: = 0c775d6e025a1ad985ac8c339e261a47 AAAAAAAAAAAAAAA; = a764ad6331f1ed698044b8f4bf208dd7 ** MATCH ** By repeating this process and replacing more of the reference input with discovered StrongToken characters, we can slowly determine the StrongToken byte-by-byte. Using a Python script also makes this process less arduous. With this process, we are able to determine that the full StrongToken is fY5V/=B80?e4.CA8. (The initial character ; is only used as a divider between the plaintext and the StrongToken) By submitting the token to the website, we are able to receive the flag. 1 Correct! The Flag is: ACI{c0db96acd85091480db76ed49ca}</summary></entry><entry><title type="html">All-Army CyberStakes 4 - Cryptography (Over Time: Paid)</title><link href="https://bernardsmith0892.github.io/posts/acictf4-otp/" rel="alternate" type="text/html" title="All-Army CyberStakes 4 - Cryptography (Over Time: Paid)" /><published>2020-05-15T02:00:00-10:00</published><updated>2020-05-15T02:00:00-10:00</updated><id>https://bernardsmith0892.github.io/posts/acictf4-otp</id><content type="html" xml:base="https://bernardsmith0892.github.io/posts/acictf4-otp/">&lt;h1 id=&quot;over-time-paid-50-points&quot;&gt;Over Time: Paid (50 Points)&lt;/h1&gt;

&lt;p&gt;This is where the challenges start getting more difficult. This problem starts with two files again: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;document.encrypted&lt;/code&gt;, which contains 15 lines of hex, and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;source.py&lt;/code&gt;, which contains what appears to be the script that generated the document. The script performs two key steps to create the document:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Generates the plaintext of the document with a static intro line, 10 random lines, a static outro line, and finally the flag.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Generates a random, 64-byte long key and XORs each line with it.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Based on the name of the challenge (&lt;strong&gt;O&lt;/strong&gt;ver &lt;strong&gt;T&lt;/strong&gt;ime: &lt;strong&gt;P&lt;/strong&gt;aid), we can see that this method is inspired by how a &lt;em&gt;One-time Pad&lt;/em&gt; works. One-time pads ensure complete and unbreakable secrecy for a message by encrypting it with a key of the same length, usually with the XOR operation. This encryption is only unbreakable &lt;em&gt;if and only if&lt;/em&gt; that key is used for &lt;strong&gt;only&lt;/strong&gt; that text and is never reused.&lt;/p&gt;

&lt;p&gt;The major weakness in this challenge’s implementation is that is only uses a 64-byte key to encrypt the &lt;em&gt;entire&lt;/em&gt; message. Furthermore, since we know exactly what the first line is, we can extract the key using a &lt;em&gt;known-plaintext attack&lt;/em&gt;, by virtue of how the XOR operation works. In XOR (\(\oplus\)) encryption, we can encrypt plaintext (\(P\)) into ciphertext (\(C\)) by XORing the plaintext with a key (\(K\)).&lt;/p&gt;

\[P \oplus K = C\]

&lt;p&gt;To decrypt the ciphertext, we only need to XOR the ciphertext with the key.&lt;/p&gt;

\[C \oplus K = P\]

&lt;p&gt;However, the mathematical properties of XOR also allow us to compute the &lt;em&gt;key&lt;/em&gt; by XORing the plaintext and ciphertext together.&lt;/p&gt;

\[P \oplus C = K\]

&lt;p&gt;In this challenge, the script provides us with a hardcoded intro statement, which is our plaintext for this attack. Since is the first line of text, we also know this corresponds to the first line of ciphertext in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;document.encrypted&lt;/code&gt;. By XORing these two lines together, we can compute the 64-byte key used throughout the encrypted document using &lt;a href=&quot;https://gchq.github.io/CyberChef/#recipe=XOR(%7B'option':'Hex','string':'2246e0fe4f69ccb153f209b8cc73a5d87ce7cfdea8fa5ce35bb68b908e5a7e20f557810187bfc8b101a69b27edce27e15802d1f3eb7ef3dfb87eac2c6e12f4c0'%7D,'Standard',false)To_Hex('None',0)&amp;amp;input=VGhlIGZvbGxvd2luZyBlbmNvZGVkIGluZGl2aWR1YWxzIGFyZSB0byBiZSBnaXZlbiBhICQyNy4zayBib251cw&quot;&gt;CyberChef&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Note: We also need to make sure the lengths of the plaintext and ciphertext match, so we have to remove the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:&lt;/code&gt; at the end of the plaintext.&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;Plaintext:  The following encoded individuals are to be given a $27.3k bonus
Ciphertext: 2246e0fe4f69ccb153f209b8cc73a5d87ce7cfdea8fa5ce35bb68b908e5a7e20f557810187bfc8b101a69b27edce27e15802d1f3eb7ef3dfb87eac2c6e12f4c0
Key:        762e85de2906a0dd3c8560d6ab53c0b61f88abbbccda358d3fdffdf9ea2f1f4c8677e073e29fbcde21c4fe078aa751843622b0d3cf4cc4f18b158c4e017c81b3
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Finally, we can use this key in &lt;a href=&quot;https://gchq.github.io/CyberChef/#recipe=From_Hex('Auto')XOR(%7B'option':'Hex','string':'762e85de2906a0dd3c8560d6ab53c0b61f88abbbccda358d3fdffdf9ea2f1f4c8677e073e29fbcde21c4fe078aa751843622b0d3cf4cc4f18b158c4e017c81b3'%7D,'Standard',false)&amp;amp;input=MjI0NmUwZmU0ZjY5Y2NiMTUzZjIwOWI4Y2M3M2E1ZDg3Y2U3Y2ZkZWE4ZmE1Y2UzNWJiNjhiOTA4ZTVhN2UyMGY1NTc4MTAxODdiZmM4YjEwMWE2OWIyN2VkY2UyN2UxNTgwMmQxZjNlYjdlZjNkZmI4N2VhYzJjNmUxMmY0YzAKNGMyNGQ2OTc2YzU0ZjI5YzFjYzYyODk3ZjkxZjg5ZjMzZmQyZWVlZjhkZmE3Y2MzN2I5NmJjZDlhYjYzNGYwNGM3NTdhMTNmYjJkN2ZkZmU2ODhhYmE0ZWNiODcxOGNhNzI2YmYxZjM4ZTAwOTRiOWNhMzVjZTFjNDAyYWNlOTMKNTYyNGMxOWI2NTUyZTFmZDY4YzQyZTkxZTQ3Mzk0Zjc1MWNmZTQ5YjhiOTU3OWNiMWY4YmJjYjdhZDYwM2YwNGM5MjNhNTNmYzJjNWY5OGE2MGU0YjY0OGRlZTIxZGE0NzE2ZGZjOTVlZjBkODhhMWMzNTRhYzBiNDIzNGNlOTMKNTYyNGM2OTY2ODU0ZWM5NDc5YTUzNDk3ZTUxNDhmOTY0Y2MxZWVlOTllOWIxNWM0NzE5YmI0YjhjYTdjNTYwOWQ0MjVhMTUzYTZkYWYwOGE2MGU0YmM1NWNiZjExZWE0NjI2M2ZlOTQ4MDZjOGNiZWRmNTBjMDZlNDYzM2NkZjUKNTYyNGQxOWY2NzQxZWZmZDc4YzAyYzgyZWE3Mzg0ZjM1M2RjZWE5YjhkOTY2NWM1N2VmZmJjYjViYTY3NWU2Y2M1M2ZhMTIxYWVkNmY5ZmU2MjhjYmY1NWM2ZWUxNGE0NmM2N2U0OTJlZjE2ODFhNWNhMzVkZjA3NDQyZWQzZjIKNTYyNGMyOTE2NTQwODA5NDcyYzEyOTk3OGIxNjgzZmU1MGE4ZjFmZTk4OWIxNWM5N2E5M2E5YjhjYTY4NTAwMGMwNTdhNzNjYWVkOTljOWE2NDg4YWE0NmFhZTIxMmNjNzkwMmY1OTA4NzAzZTRiOGM1NTFjNTBmMjE1Y2ExOTMKNTYyNGQ2OTc2YzU0ZjI5YzFjYzMyZjhlZmYwMThmZTIzZmRjZWFmNThiOTUxNWM4N2M5N2IyZDlhZjZjNTcwM2E2MzNhNTNmYjZkZTljOWY2ZDk0YjY0NmFhZWYxZWQwNzM2ZTkwODc4ZTAyODNiZWFiNDFjZDAwNDYzM2ExOTMKNTYyNGNkOTE3ZDQzZWNmZDc4YzAyYzgyZWE3MzlhZjM0YmM5OGJmMzgzOGU3MGMxMWY5OWIyYTFiZTdkNTAxOGE2MmRhNTI3YTNiZmU4OWY2ZjgzYjEyN2MzZTkxNWNkNzcwMmY4OWM5YjA5ODhkMWNjNWFjMDA4MjE1Y2ExOTMKNTYyNGRmOWI3ZDQ3ODA5YTczYzkyNmY2ZTkwMTgxZTA1MGE4ZmZmYTgyOWQ3YWFkNzc5MGE5YmNhNjBmNGIwZGM4MzBhZjUzYTFkN2ZkOGM2ZDhkYmIyN2RlZTYxZmMzNzkwMmU0OTI4MTBiOGJkMWQ4NWNjOTFjNTMzZGExOTMKNTYyNGMzOTE3MTUyZjI5MjY4YTUyOTk4ZWYxYTgxOTY1YWNiZTNmNGVjOWI3OWRkNzc5ZWRkYWFhMzZhNGQxZWM3NTdhMjIxYTNjOWYzZmU2OThiYWE0MmM2ODcxOGNhNzI2YmYxZjM4NzAzOTBiNGM3MzVjZDAyNTEzNGMwOTMKNTYyNGQ2OTc2YzU0ZjI5YzFjY2QyZjgyZWUxZmUwZWM1YWRjZWE5Yjg1OTQ3MWM0N2VmZmI5YmNhNjdiNWU2Y2M0MjVhMTI1YWRiZmZiOTE2ZDgyZGU0MGM1ZWIxN2E0NjI2M2ZlOTQ4MDZjODNiZWM3NTNhYzZlMjE1Y2ExOTMKNTYyNGE1ZmUwOTI2ODBmZDFjYTU0MGY2OGI3M2UwOTYzZmE4OGI5YmVjZmExNWFkMWZmZmRkZDljYTBmM2Y2Y2E2NTdjMDUzYzJiZjljZmUwMWU0ZGUyN2FhODc3MWE0MTYwMjkwZjNlZjZjZTRkMWFiMzVhYzZlMjE1Y2ExOTMKNTYyNGMzYWI1YjcyYzhiODRlZTgwZmE0Y2U3ZmUwYzI3N2VkOGJmZDgwOWI3MmFkNTZhY2M3ZDljYTBmM2Y2Y2E2NTdjMDUzYzJiZjljZmUwMWU0ZGUyN2FhODc3MWE0MTYwMjkwZjNlZjZjZTRkMWFiMzVhYzZlMjE1Y2ExOTMKNTYyNDhmOWY2YTRmZGJlYjU5YjMwNWUyOWEzMWY2ODMyN2VkY2ZkOWFkZWE1M2JmMGFiYTlmY2NkYTFiMjYyOWUzNDY5ZDUzYzJiZjljZmUwMWU0ZGUyN2FhODc3MWE0MTYwMjkwZjNlZjZjZTRkMWFiMzVhYzZlMjE1Y2ExOTMKNTYwZThmCg&quot;&gt;CyberChef&lt;/a&gt; to XOR the remaining lines and decrypt the entire document and extract the flag.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;[..snip..]
Furthermore, the FLAG is:                                      

ACI{6e6e41b658edba0f25eb5049ee1}                               
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;script type=&quot;text/x-mathjax-config&quot;&gt;
  MathJax.Hub.Config({
    extensions: [
      &quot;MathMenu.js&quot;,
      &quot;MathZoom.js&quot;,
      &quot;AssistiveMML.js&quot;,
      &quot;a11y/accessibility-menu.js&quot;
    ],
    jax: [&quot;input/TeX&quot;, &quot;output/CommonHTML&quot;],
    TeX: {
      extensions: [
        &quot;AMSmath.js&quot;,
        &quot;AMSsymbols.js&quot;,
        &quot;noErrors.js&quot;,
        &quot;noUndefined.js&quot;,
      ]
    }
  });
&lt;/script&gt;

&lt;script type=&quot;text/javascript&quot; async=&quot;&quot; src=&quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML&quot;&gt;
&lt;/script&gt;</content><author><name></name></author><category term="CTF" /><category term="AllArmyCyberStakes4" /><category term="cryptography" /><summary type="html">Over Time: Paid (50 Points) This is where the challenges start getting more difficult. This problem starts with two files again: document.encrypted, which contains 15 lines of hex, and source.py, which contains what appears to be the script that generated the document. The script performs two key steps to create the document: Generates the plaintext of the document with a static intro line, 10 random lines, a static outro line, and finally the flag. Generates a random, 64-byte long key and XORs each line with it. Based on the name of the challenge (Over Time: Paid), we can see that this method is inspired by how a One-time Pad works. One-time pads ensure complete and unbreakable secrecy for a message by encrypting it with a key of the same length, usually with the XOR operation. This encryption is only unbreakable if and only if that key is used for only that text and is never reused. The major weakness in this challenge’s implementation is that is only uses a 64-byte key to encrypt the entire message. Furthermore, since we know exactly what the first line is, we can extract the key using a known-plaintext attack, by virtue of how the XOR operation works. In XOR (\(\oplus\)) encryption, we can encrypt plaintext (\(P\)) into ciphertext (\(C\)) by XORing the plaintext with a key (\(K\)). \[P \oplus K = C\] To decrypt the ciphertext, we only need to XOR the ciphertext with the key. \[C \oplus K = P\] However, the mathematical properties of XOR also allow us to compute the key by XORing the plaintext and ciphertext together. \[P \oplus C = K\] In this challenge, the script provides us with a hardcoded intro statement, which is our plaintext for this attack. Since is the first line of text, we also know this corresponds to the first line of ciphertext in document.encrypted. By XORing these two lines together, we can compute the 64-byte key used throughout the encrypted document using CyberChef. Note: We also need to make sure the lengths of the plaintext and ciphertext match, so we have to remove the : at the end of the plaintext. 1 2 3 Plaintext: The following encoded individuals are to be given a $27.3k bonus Ciphertext: 2246e0fe4f69ccb153f209b8cc73a5d87ce7cfdea8fa5ce35bb68b908e5a7e20f557810187bfc8b101a69b27edce27e15802d1f3eb7ef3dfb87eac2c6e12f4c0 Key: 762e85de2906a0dd3c8560d6ab53c0b61f88abbbccda358d3fdffdf9ea2f1f4c8677e073e29fbcde21c4fe078aa751843622b0d3cf4cc4f18b158c4e017c81b3 Finally, we can use this key in CyberChef to XOR the remaining lines and decrypt the entire document and extract the flag. 1 2 3 4 [..snip..] Furthermore, the FLAG is: ACI{6e6e41b658edba0f25eb5049ee1}</summary></entry><entry><title type="html">All-Army CyberStakes 4 - Cryptography (Really Senseless Admins)</title><link href="https://bernardsmith0892.github.io/posts/acictf4-rsa/" rel="alternate" type="text/html" title="All-Army CyberStakes 4 - Cryptography (Really Senseless Admins)" /><published>2020-05-14T01:00:00-10:00</published><updated>2020-05-14T01:00:00-10:00</updated><id>https://bernardsmith0892.github.io/posts/acictf4-rsa</id><content type="html" xml:base="https://bernardsmith0892.github.io/posts/acictf4-rsa/">&lt;h1 id=&quot;really-senseless-admins-35-points&quot;&gt;Really Senseless Admins (35 Points)&lt;/h1&gt;

&lt;p&gt;Here, we are provided with two files: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;flag.enc&lt;/code&gt;, containing a very large decimal number, and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;params.txt&lt;/code&gt;, containing three decimal numbers, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;p&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;q&lt;/code&gt;, and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;e&lt;/code&gt;. Based on the challenge’s title (&lt;strong&gt;R&lt;/strong&gt;eally &lt;strong&gt;S&lt;/strong&gt;enseless &lt;strong&gt;A&lt;/strong&gt;dmins), these numbers must be the parameters that generate the &lt;em&gt;RSA&lt;/em&gt; private key which decrypts the flag. Using the tool provided by &lt;a href=&quot;https://www.cryptool.org/en/cto-highlights/rsa-step-by-step&quot;&gt;CrypTool&lt;/a&gt;, we can easily generate the key and decrypt the flag by simply copying and pasting the values into it. However, it’s still worthwhile to understand the underlying theory behind how RSA works, for both knowledge purposes and to help in a later challenge. You can read into it &lt;a href=&quot;https://en.wikipedia.org/wiki/RSA_(cryptosystem)#Key_generation&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;After decrypting the message contained in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;flag.enc&lt;/code&gt;, we get a slightly smaller decimal number. One thing to remember is that all information contained in memory is stored as and can by represented by a number. Hexadecimal numbers are used since it’s easy to represent individual bytes of data with it. Every 4-bits of data are represented by one hex number, so a byte (8-bits) is represented by two hex numbers. For example, the string &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ABCDE&lt;/code&gt; is represented in hex as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x4142434445&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We can also represent these hex numbers as a normal decimal number. If we convert the previous hex number into decimal, we can also write the string &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ABCDE&lt;/code&gt; as the number &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;280284578885&lt;/code&gt;. Keep in mind, this is an unusual way to represent strings since, unlike hex, a small change in any character will drastically change the entire decimal number. Changing the string to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BBCDE&lt;/code&gt; causes it to become the number &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;284579546181&lt;/code&gt;, while its hex version simply sees a change in the first two places, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x4242434445&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;To get the flag, we just need to apply this principle in the reverse direction: Convert the decimal number into hex and then decode each byte into its character equivalent. We can easily perform this task by using &lt;a href=&quot;https://gchq.github.io/CyberChef/#recipe=To_Base(16)From_Hex('Auto')&amp;amp;input=MTA0ODczMzQwNDU5MDU0OTI0MTgxMTE1MjkyNTQ2MzE1OTEzMDkyNjcwNTAwNDkwNTE1ODI2NDE3NDgxMzQx&quot;&gt;CyberChef&lt;/a&gt; again.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;Decimal Plaintext: 104873340459054924181115292546315913092670500490515826417481341
Hex Plaintext:     0x4143497b5072316d33735f54214d337a5f34373533393062367d
ASCII Plaintext:   ACI{Pr1m3s_T!M3z_475390b6}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;!--The operation of RSA depends on three key values, `e`, `d`, and `n`. `e` is called the *encryption exponent*, and combined with `n` makes up the *public key*. `d` is called the *decryption exponent*, and combined with `n` makes up the *private key*. These two keys have a relationship where anything that is encrypted by the *public key* can **only** be decrypted by the *private key*. And the reverse applies too; anything encrypted by the *private key* can only be decrypted by the *public key*.--&gt;</content><author><name></name></author><category term="CTF" /><category term="AllArmyCyberStakes4" /><category term="cryptography" /><summary type="html">Really Senseless Admins (35 Points) Here, we are provided with two files: flag.enc, containing a very large decimal number, and params.txt, containing three decimal numbers, p, q, and e. Based on the challenge’s title (Really Senseless Admins), these numbers must be the parameters that generate the RSA private key which decrypts the flag. Using the tool provided by CrypTool, we can easily generate the key and decrypt the flag by simply copying and pasting the values into it. However, it’s still worthwhile to understand the underlying theory behind how RSA works, for both knowledge purposes and to help in a later challenge. You can read into it here. After decrypting the message contained in flag.enc, we get a slightly smaller decimal number. One thing to remember is that all information contained in memory is stored as and can by represented by a number. Hexadecimal numbers are used since it’s easy to represent individual bytes of data with it. Every 4-bits of data are represented by one hex number, so a byte (8-bits) is represented by two hex numbers. For example, the string ABCDE is represented in hex as 0x4142434445. We can also represent these hex numbers as a normal decimal number. If we convert the previous hex number into decimal, we can also write the string ABCDE as the number 280284578885. Keep in mind, this is an unusual way to represent strings since, unlike hex, a small change in any character will drastically change the entire decimal number. Changing the string to BBCDE causes it to become the number 284579546181, while its hex version simply sees a change in the first two places, 0x4242434445. To get the flag, we just need to apply this principle in the reverse direction: Convert the decimal number into hex and then decode each byte into its character equivalent. We can easily perform this task by using CyberChef again. 1 2 3 Decimal Plaintext: 104873340459054924181115292546315913092670500490515826417481341 Hex Plaintext: 0x4143497b5072316d33735f54214d337a5f34373533393062367d ASCII Plaintext: ACI{Pr1m3s_T!M3z_475390b6}</summary></entry><entry><title type="html">All-Army CyberStakes 4 - Cryptography (Rotate Me)</title><link href="https://bernardsmith0892.github.io/posts/acictf4-rotateme/" rel="alternate" type="text/html" title="All-Army CyberStakes 4 - Cryptography (Rotate Me)" /><published>2020-05-13T00:00:00-10:00</published><updated>2020-05-13T00:00:00-10:00</updated><id>https://bernardsmith0892.github.io/posts/acictf4-rotateme</id><content type="html" xml:base="https://bernardsmith0892.github.io/posts/acictf4-rotateme/">&lt;h1 id=&quot;rotate-me-5-points&quot;&gt;Rotate Me (5 Points)&lt;/h1&gt;

&lt;p&gt;This one is a very simple problem, especially considering it’s only worth 5 points. We start with a text file that contains enciphered text, which already seems to be in the expected format of a flag.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;IKQ{KzGxBw_NcV_nWz_ItT_ScrflorN}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Based on the name of the challenge and the hints mentioning “Julius”, it’s safe to assume that this is a &lt;em&gt;Caesar cipher&lt;/em&gt;, also known as a &lt;em&gt;Rotation (ROT-N) cipher&lt;/em&gt;. This is a very simple enciphering method where you “shift” each character to the right by &lt;em&gt;N&lt;/em&gt; number of places. Going beyond “Z” just causes you to rotate back around to “A”, which is where the term &lt;em&gt;Rotation cipher&lt;/em&gt; comes from. In order to decrypt the text, you just need to shift the characters the same number of places in the &lt;em&gt;other&lt;/em&gt; direction to the left. For example, in a classic Caesar (or ROT-3) cipher the encryption and decryption process looks like this:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;Plaintext:  HELLO WORLD
Ciphertext: KHOOR ZRUOG
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Since you rotate back to “A” when you hit “Z”, anything above a ROT-25 cipher is equivalent to a cipher between ROT-0 to ROT-25. (You can calculate exactly what it’s equivalent to by computing &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;N mod 26&lt;/code&gt;) This means that the total number of possible keys in a Caesar cipher is only &lt;strong&gt;25&lt;/strong&gt;. This is easily brute-forced by hand and is exceptionally trivial for a computer to crack. However, if we wanted to be fancy about it, we can crack it like a &lt;em&gt;known-plaintext attack&lt;/em&gt;. We know that the first three characters have to be &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ACI&lt;/code&gt;. By comparing first letters of the plaintext and ciphertext, we can calculate that the key is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;9 - 1 = 8&lt;/code&gt;, since &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A&lt;/code&gt; is the 1st character of the alphabet and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;I&lt;/code&gt; is the 9th. So by rotating to the left by &lt;strong&gt;8&lt;/strong&gt; spaces (or 18 spaces to the right, since &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-8 mod 26 = 18&lt;/code&gt;), we can decrypt the flag. It’s easy to do this using a common tool such as &lt;a href=&quot;https://gchq.github.io/CyberChef/#recipe=ROT13(true,true,18)&amp;amp;input=SUtRe0t6R3hCd19OY1Zfbld6X0l0VF9TY3JmbG9yTn0&quot;&gt;CyberChef&lt;/a&gt;.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;Ciphertext: IKQ{KzGxBw_NcV_nWz_ItT_ScrflorN}
Plaintext:  ACI{CrYpTo_FuN_fOr_AlL_KujxdgjF}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><category term="CTF" /><category term="AllArmyCyberStakes4" /><category term="cryptography" /><summary type="html">Rotate Me (5 Points)</summary></entry></feed>