<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2021-06-05T03:23:32-10:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Bernard Smith</title><subtitle>Mostly technology-related</subtitle><entry><title type="html">All-Army CyberStakes 4 - Cryptography (Headpiece Silver)</title><link href="http://localhost:4000/acictf/ctf/cryptography/2020/05/13/acictf4-headpiece-silver.html" rel="alternate" type="text/html" title="All-Army CyberStakes 4 - Cryptography (Headpiece Silver)" /><published>2020-05-13T04:00:00-10:00</published><updated>2020-05-13T04:00:00-10:00</updated><id>http://localhost:4000/acictf/ctf/cryptography/2020/05/13/acictf4-headpiece-silver</id><content type="html" xml:base="http://localhost:4000/acictf/ctf/cryptography/2020/05/13/acictf4-headpiece-silver.html">&lt;h1 id=&quot;headpiece-silver-250-points&quot;&gt;Headpiece Silver (250 Points)&lt;/h1&gt;

&lt;p&gt;This challenge provides us with a server to interact with at challenge.acictf.com:30151. (&lt;em&gt;Your port number may differ&lt;/em&gt;) To get started, lets see what this server is about by connecting to it using &lt;code class=&quot;highlighter-rouge&quot;&gt;ncat&lt;/code&gt;.&lt;/p&gt;

&lt;script id=&quot;asciicast-sNd3fjZW4f9c69nYw88Ieu4G8&quot; src=&quot;https://asciinema.org/a/sNd3fjZW4f9c69nYw88Ieu4G8.js&quot; async=&quot;&quot; data-rows=&quot;20&quot;&gt;&lt;/script&gt;

&lt;p&gt;Based on this information given to us, this is clearly another &lt;em&gt;RSA&lt;/em&gt; related challenge. The server provides us with the components for a &lt;em&gt;public key&lt;/em&gt;, the public modulus &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt;, and the public exponent &lt;code class=&quot;highlighter-rouge&quot;&gt;e&lt;/code&gt;, which are:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;N: 122298190177919866881639090045815514691491489519639425496178483984084352945237
e: 65537
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If we can derive the &lt;em&gt;private key&lt;/em&gt; from this &lt;em&gt;public key&lt;/em&gt;, we will be able to decrypt the encrypted password they provided to us, which is: &lt;code class=&quot;highlighter-rouge&quot;&gt;985be9b7b845a1a09a916437d767c30ae8d7ad4987cb77b0602b04889f7c2301&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Normally, computing the &lt;em&gt;private key&lt;/em&gt; from just the &lt;em&gt;public key&lt;/em&gt; is nearly impossible. However, what makes the key provided here different is in the &lt;em&gt;key length&lt;/em&gt;. Most RSA keys are used today are &lt;strong&gt;2048-bit&lt;/strong&gt; keys, which are practically impossible for current computers to decrypt. But the key provided by the server is only around a &lt;strong&gt;256-bit&lt;/strong&gt; key, which is vastly weaker than what is needed for proper security. To fully compare the strengths of these two key lengths, we need to determine how many &lt;em&gt;bits of security&lt;/em&gt; these keys would have. Since RSA is based on the &lt;em&gt;factoring problem&lt;/em&gt;, brute-forcing an RSA key doesn’t require you to test &lt;strong&gt;all&lt;/strong&gt; possible numbers, unlike &lt;a href=&quot;https://en.wikipedia.org/wiki/Advanced_Encryption_Standard&quot;&gt;AES&lt;/a&gt; where you’d need to check every possible key. So while &lt;em&gt;AES-256&lt;/em&gt; has &lt;em&gt;256-bit security&lt;/em&gt;, 2048-bit RSA key doesn’t have 2048-bit security.&lt;/p&gt;

&lt;p&gt;According to &lt;a href=&quot;https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-57pt1r5.pdf&quot;&gt;NIST (p. 54)&lt;/a&gt;, a 2048-bit RSA key only offers about &lt;strong&gt;112-bit security&lt;/strong&gt;. And while 256-bit RSA is so weak that it isn’t even considered in the NIST publication, &lt;a href=&quot;https://crypto.stackexchange.com/questions/8687/security-strength-of-rsa-in-relation-with-the-modulus-size&quot;&gt;this StackExchange&lt;/a&gt; question tells us that &lt;a href=&quot;https://www.wolframalpha.com/input/?i=N%5BLog2%5BExp%5B%2864%2F9*Log%5B2%5E256%5D%29%5E%281%2F3%29*%28Log%5BLog%5B2%5E256%5D%5D%29%5E%282%2F3%29%5D%5D%5D&quot;&gt;256-bit RSA&lt;/a&gt; only offers around &lt;strong&gt;46-bit security&lt;/strong&gt;. Each extra bit of security makes a key twice as secure, so 256-bit RSA is &lt;em&gt;twice&lt;/em&gt; as easy to break than a key with &lt;em&gt;47-bit security&lt;/em&gt;. Now compared to 2048-bit RSA, 256-bit RSA is about &lt;em&gt;73 quintillion&lt;/em&gt; times easier to break, or &lt;em&gt;73786976294838206464&lt;/em&gt; times easier.&lt;/p&gt;

&lt;p&gt;Now to how we can actually break the key. &lt;a href=&quot;https://github.com/Ganapati/RsaCtfTool&quot;&gt;RsaCtfTool&lt;/a&gt; makes this task very easy. We can provide the &lt;em&gt;public key&lt;/em&gt; components, &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;e&lt;/code&gt;, and the &lt;em&gt;ciphertext&lt;/em&gt; in decimal to this tool in order to quickly derive the &lt;em&gt;private key&lt;/em&gt; and &lt;em&gt;plaintext&lt;/em&gt;. (&lt;em&gt;Note: It appears the challenge’s modulus is now in &lt;a href=&quot;http://factordb.com/index.php?query=122298190177919866881639090045815514691491489519639425496178483984084352945237&quot;&gt;FactorDB&lt;/a&gt;, so RsaCtfTool isn’t conducting the full attack)&lt;/em&gt;.&lt;/p&gt;

&lt;script id=&quot;asciicast-rfequzN91lhn6WrsCDyYnTD34&quot; src=&quot;https://asciinema.org/a/rfequzN91lhn6WrsCDyYnTD34.js&quot; async=&quot;&quot; data-rows=&quot;20&quot;&gt;&lt;/script&gt;

&lt;p&gt;We can see the plaintext password at the end of the unciphered data: &lt;code class=&quot;highlighter-rouge&quot;&gt;4n1a5ebRFmtyysAe&lt;/code&gt;. By providing this password to the server, we can retrieve the flag: &lt;code class=&quot;highlighter-rouge&quot;&gt;ACI{ad94502b4d2437193e9c3fed364}&lt;/code&gt;&lt;/p&gt;

&lt;script id=&quot;asciicast-jeYy2ox48alc3qVHwKL5BTufE&quot; src=&quot;https://asciinema.org/a/jeYy2ox48alc3qVHwKL5BTufE.js&quot; async=&quot;&quot; data-rows=&quot;20&quot;&gt;&lt;/script&gt;

&lt;h2 id=&quot;bonus-solution&quot;&gt;Bonus Solution&lt;/h2&gt;

&lt;p&gt;As it turns out, like many real-world systems, the challenge’s server has a &lt;em&gt;misconfiguration&lt;/em&gt; vulnerability that allows you to skip all of this. What we didn’t check in the previous steps was the fourth option to &lt;em&gt;test ciphertext&lt;/em&gt;. It appears that this was supposed to serve as a &lt;em&gt;decryption oracle&lt;/em&gt; that decrypts whatever you provide it using the server’s private key. However, since the &lt;em&gt;password ciphertext&lt;/em&gt; is encrypted with the public key, we are able to use this test function to simply have the server decrypt the password ciphertext itself.&lt;/p&gt;

&lt;script id=&quot;asciicast-2h6fYvAV9BvBDJYhw3PqUrtN2&quot; src=&quot;https://asciinema.org/a/2h6fYvAV9BvBDJYhw3PqUrtN2.js&quot; async=&quot;&quot; data-rows=&quot;20&quot;&gt;&lt;/script&gt;</content><author><name></name></author><summary type="html">Headpiece Silver (250 Points) This challenge provides us with a server to interact with at challenge.acictf.com:30151. (Your port number may differ) To get started, lets see what this server is about by connecting to it using ncat. Based on this information given to us, this is clearly another RSA related challenge. The server provides us with the components for a public key, the public modulus N, and the public exponent e, which are: N: 122298190177919866881639090045815514691491489519639425496178483984084352945237 e: 65537 If we can derive the private key from this public key, we will be able to decrypt the encrypted password they provided to us, which is: 985be9b7b845a1a09a916437d767c30ae8d7ad4987cb77b0602b04889f7c2301 Normally, computing the private key from just the public key is nearly impossible. However, what makes the key provided here different is in the key length. Most RSA keys are used today are 2048-bit keys, which are practically impossible for current computers to decrypt. But the key provided by the server is only around a 256-bit key, which is vastly weaker than what is needed for proper security. To fully compare the strengths of these two key lengths, we need to determine how many bits of security these keys would have. Since RSA is based on the factoring problem, brute-forcing an RSA key doesn’t require you to test all possible numbers, unlike AES where you’d need to check every possible key. So while AES-256 has 256-bit security, 2048-bit RSA key doesn’t have 2048-bit security. According to NIST (p. 54), a 2048-bit RSA key only offers about 112-bit security. And while 256-bit RSA is so weak that it isn’t even considered in the NIST publication, this StackExchange question tells us that 256-bit RSA only offers around 46-bit security. Each extra bit of security makes a key twice as secure, so 256-bit RSA is twice as easy to break than a key with 47-bit security. Now compared to 2048-bit RSA, 256-bit RSA is about 73 quintillion times easier to break, or 73786976294838206464 times easier. Now to how we can actually break the key. RsaCtfTool makes this task very easy. We can provide the public key components, N and e, and the ciphertext in decimal to this tool in order to quickly derive the private key and plaintext. (Note: It appears the challenge’s modulus is now in FactorDB, so RsaCtfTool isn’t conducting the full attack). We can see the plaintext password at the end of the unciphered data: 4n1a5ebRFmtyysAe. By providing this password to the server, we can retrieve the flag: ACI{ad94502b4d2437193e9c3fed364} Bonus Solution As it turns out, like many real-world systems, the challenge’s server has a misconfiguration vulnerability that allows you to skip all of this. What we didn’t check in the previous steps was the fourth option to test ciphertext. It appears that this was supposed to serve as a decryption oracle that decrypts whatever you provide it using the server’s private key. However, since the password ciphertext is encrypted with the public key, we are able to use this test function to simply have the server decrypt the password ciphertext itself.</summary></entry><entry><title type="html">All-Army CyberStakes 4 - Cryptography (Speak Plainly)</title><link href="http://localhost:4000/acictf/ctf/cryptography/2020/05/13/acictf4-speakplainly.html" rel="alternate" type="text/html" title="All-Army CyberStakes 4 - Cryptography (Speak Plainly)" /><published>2020-05-13T03:00:00-10:00</published><updated>2020-05-13T03:00:00-10:00</updated><id>http://localhost:4000/acictf/ctf/cryptography/2020/05/13/acictf4-speakplainly</id><content type="html" xml:base="http://localhost:4000/acictf/ctf/cryptography/2020/05/13/acictf4-speakplainly.html">&lt;h1 id=&quot;speak-plainly-150-points&quot;&gt;Speak Plainly (150 Points)&lt;/h1&gt;

&lt;p&gt;This problem diverts from the previous ones by providing us with a website instead. The hints bring a lot of attention to the website’s login cookies, so we try creating an account and examining the created cookies. &lt;code class=&quot;highlighter-rouge&quot;&gt;auth_token&lt;/code&gt; in particular stands out since it’s not a standard cookie that’s seen on other sites.&lt;/p&gt;

&lt;figure&gt;
  &lt;img src=&quot;http://localhost:4000/assets/imgs/speakplainly/login.png&quot; alt=&quot;Logging In&quot; /&gt;
  &lt;figcaption&gt;Creating an account.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;figure&gt;
  &lt;img src=&quot;http://localhost:4000/assets/imgs/speakplainly/cookies.png&quot; alt=&quot;Cookies&quot; /&gt;
  &lt;figcaption&gt;The list of site cookies from the Chrome DevTools menu.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;After creating an account, the website tells us it’ll give us the flag after we provide it with the &lt;em&gt;StrongToken&lt;/em&gt;. The home page has several information blocks that give us a few hints about what this could mean:&lt;/p&gt;

&lt;figure&gt;
  &lt;img src=&quot;http://localhost:4000/assets/imgs/speakplainly/encryption-info.png&quot; alt=&quot;Speak Plainly Hints&quot; /&gt;
  &lt;figcaption&gt;Information blocks from the website's main menu.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;auth_token&lt;/code&gt; is encrypted with a 128-bit key in &lt;a href=&quot;https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Electronic_codebook_(ECB)&quot;&gt;AES-ECB&lt;/a&gt; mode.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Prior to encryption, the site appends a &lt;em&gt;StrongToken&lt;/em&gt; to the data and then encrypts it.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Since the site is using &lt;em&gt;Electronic Code Book (ECB) mode&lt;/em&gt;, we can perform a &lt;em&gt;chosen-plaintext attack&lt;/em&gt; by using the account creation process as an &lt;em&gt;encryption oracle&lt;/em&gt;. This will allows us to extract the &lt;em&gt;StrongToken&lt;/em&gt;, byte-by-byte. The entire attack process is well-explained in a blog post by &lt;a href=&quot;https://zachgrace.com/posts/attacking-ecb/&quot;&gt;Zach Grace&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Since we’re going to be using the account creation feature quite a bit, we should figure out a way to make the process easier for us. &lt;em&gt;Burp Suite&lt;/em&gt; has a feature called &lt;em&gt;Repeater&lt;/em&gt; that allows us to save a web request and repeatedly modify and resend it, rather than repeating the process in the web browser.&lt;/p&gt;

&lt;figure&gt;
  &lt;img src=&quot;http://localhost:4000/assets/imgs/speakplainly/burp-history.png&quot; alt=&quot;Burp Suite History&quot; /&gt;
  &lt;figcaption&gt;Finding the web request to repeat in the history menu.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;figure&gt;
  &lt;img src=&quot;http://localhost:4000/assets/imgs/speakplainly/burp-choose-repeater.png&quot; alt=&quot;Burp Suite Repeater Option&quot; /&gt;
  &lt;figcaption&gt;Selecting the &lt;i&gt;Send to Repeater&lt;/i&gt; option.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;figure&gt;
  &lt;img src=&quot;http://localhost:4000/assets/imgs/speakplainly/burp-repeater.png&quot; alt=&quot;Burp Suite Repeater&quot; /&gt;
  &lt;figcaption&gt;Modifying the request and seeing the &lt;code&gt;auth_token&lt;/code&gt; change in the response.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Our first step is to figure out exactly what’s being encrypted. We know it comes from the account information, so there’s only two real options: the username and password. By testing out two accounts with the same username but different passwords, we can see that &lt;code class=&quot;highlighter-rouge&quot;&gt;auth_token&lt;/code&gt; doesn’t change as long as the username stays the same. With this, we can determine that &lt;code class=&quot;highlighter-rouge&quot;&gt;auth_token&lt;/code&gt; only uses the username in its encryption.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;testusername:password = 958af5df8adcc6bb0abf0473f6be9bb7684387617f292c4d7e1f689f7f5bf19d
testusername:newpass  = 958af5df8adcc6bb0abf0473f6be9bb7684387617f292c4d7e1f689f7f5bf19d
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The next step is to determine the encryption &lt;em&gt;block size&lt;/em&gt;. By testing out a few different inputs, we can quickly see that ciphertext is added in &lt;strong&gt;16 byte&lt;/strong&gt; blocks.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;AAAAAAAAAAAAAAA  (15 As) = a764ad6331f1ed698044b8f4bf208dd7 73ad7e84d6e3bb6e8c85112732e0160a
AAAAAAAAAAAAAAAA (16 As) = e5a8d39cc17dd336ac0c0fd443ca5089 23101bd6e92b9703b48b69d5a1d01460 68a9e1b3e5368dc2725eb057cc397065
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Our next step is to figure out the offset between the start of the encrypted data, and where our input begins. We start by sending 2 blocks (32 bytes) of the same information, and then prepending that input with padding characters until we can see two blocks in a row of the same encrypted data. It will also let us estimate the size of the &lt;em&gt;StrongToken&lt;/em&gt; by seeing how much many more blocks appear after the matching blocks.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;AAAAAAAAAAAAAAAA AAAAAAAAAAAAAAAA = e5a8d39cc17dd336ac0c0fd443ca5089 e5a8d39cc17dd336ac0c0fd443ca5089 23101bd6e92b9703b48b69d5a1d01460 68a9e1b3e5368dc2725eb057cc397065
[None]                   = 23101bd6e92b9703b48b69d5a1d01460 68a9e1b3e5368dc2725eb057cc397065
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;These results immediately show that there is no offset between the start of the plaintext and the username, since the first two blocks are already the same without any padding needed. Now that we know the block size and offset, we can begin brute-forcing the &lt;em&gt;StrongToken&lt;/em&gt;. We first provide an input one byte smaller than the block size, &lt;code class=&quot;highlighter-rouge&quot;&gt;AAAAAAAAAAAAAAA&lt;/code&gt;. This creates a ciphertext block using the plaintext &lt;code class=&quot;highlighter-rouge&quot;&gt;AAAAAAAAAAAAAAA?&lt;/code&gt;, where &lt;code class=&quot;highlighter-rouge&quot;&gt;?&lt;/code&gt; is the first byte of the &lt;em&gt;StrongToken&lt;/em&gt;. Using the ciphertext block provided by the website as a &lt;em&gt;reference output&lt;/em&gt;, we can brute-force the first byte of the &lt;em&gt;StrongToken&lt;/em&gt;. By using the &lt;em&gt;reference input&lt;/em&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;AAAAAAAAAAAAAAA&lt;/code&gt;, and iterating through all possible characters for the last byte, we can determine what the &lt;em&gt;StrongToken’s&lt;/em&gt; first byte when our output matches the &lt;em&gt;reference output&lt;/em&gt;.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Reference Value:
AAAAAAAAAAAAAAA  = a764ad6331f1ed698044b8f4bf208dd7

Brute-Forcing:
AAAAAAAAAAAAAAA! = d4e420b6abd4e19033ed1fdea60dabdb
AAAAAAAAAAAAAAA&quot; = caee4360f81620169c15d01da4064629
[...snip...]
AAAAAAAAAAAAAAA: = 0c775d6e025a1ad985ac8c339e261a47
AAAAAAAAAAAAAAA; = a764ad6331f1ed698044b8f4bf208dd7
** MATCH **
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;By repeating this process and replacing more of the reference input with discovered &lt;em&gt;StrongToken&lt;/em&gt; characters, we can slowly determine the &lt;em&gt;StrongToken&lt;/em&gt; byte-by-byte. Using a Python script also makes this process less arduous. With this process, we are able to determine that the full &lt;em&gt;StrongToken&lt;/em&gt; is &lt;code class=&quot;highlighter-rouge&quot;&gt;fY5V/=B80?e4.CA8&lt;/code&gt;. (&lt;em&gt;The initial character &lt;code class=&quot;highlighter-rouge&quot;&gt;;&lt;/code&gt; is only used as a divider between the plaintext and the StrongToken&lt;/em&gt;) By submitting the token to the website, we are able to receive the flag.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Correct! The Flag is: ACI{c0db96acd85091480db76ed49ca}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><summary type="html">Speak Plainly (150 Points) This problem diverts from the previous ones by providing us with a website instead. The hints bring a lot of attention to the website’s login cookies, so we try creating an account and examining the created cookies. auth_token in particular stands out since it’s not a standard cookie that’s seen on other sites. Creating an account. The list of site cookies from the Chrome DevTools menu. After creating an account, the website tells us it’ll give us the flag after we provide it with the StrongToken. The home page has several information blocks that give us a few hints about what this could mean: Information blocks from the website's main menu. auth_token is encrypted with a 128-bit key in AES-ECB mode. Prior to encryption, the site appends a StrongToken to the data and then encrypts it. Since the site is using Electronic Code Book (ECB) mode, we can perform a chosen-plaintext attack by using the account creation process as an encryption oracle. This will allows us to extract the StrongToken, byte-by-byte. The entire attack process is well-explained in a blog post by Zach Grace. Since we’re going to be using the account creation feature quite a bit, we should figure out a way to make the process easier for us. Burp Suite has a feature called Repeater that allows us to save a web request and repeatedly modify and resend it, rather than repeating the process in the web browser. Finding the web request to repeat in the history menu. Selecting the Send to Repeater option. Modifying the request and seeing the auth_token change in the response. Our first step is to figure out exactly what’s being encrypted. We know it comes from the account information, so there’s only two real options: the username and password. By testing out two accounts with the same username but different passwords, we can see that auth_token doesn’t change as long as the username stays the same. With this, we can determine that auth_token only uses the username in its encryption. testusername:password = 958af5df8adcc6bb0abf0473f6be9bb7684387617f292c4d7e1f689f7f5bf19d testusername:newpass = 958af5df8adcc6bb0abf0473f6be9bb7684387617f292c4d7e1f689f7f5bf19d The next step is to determine the encryption block size. By testing out a few different inputs, we can quickly see that ciphertext is added in 16 byte blocks. AAAAAAAAAAAAAAA (15 As) = a764ad6331f1ed698044b8f4bf208dd7 73ad7e84d6e3bb6e8c85112732e0160a AAAAAAAAAAAAAAAA (16 As) = e5a8d39cc17dd336ac0c0fd443ca5089 23101bd6e92b9703b48b69d5a1d01460 68a9e1b3e5368dc2725eb057cc397065 Our next step is to figure out the offset between the start of the encrypted data, and where our input begins. We start by sending 2 blocks (32 bytes) of the same information, and then prepending that input with padding characters until we can see two blocks in a row of the same encrypted data. It will also let us estimate the size of the StrongToken by seeing how much many more blocks appear after the matching blocks. AAAAAAAAAAAAAAAA AAAAAAAAAAAAAAAA = e5a8d39cc17dd336ac0c0fd443ca5089 e5a8d39cc17dd336ac0c0fd443ca5089 23101bd6e92b9703b48b69d5a1d01460 68a9e1b3e5368dc2725eb057cc397065 [None] = 23101bd6e92b9703b48b69d5a1d01460 68a9e1b3e5368dc2725eb057cc397065 These results immediately show that there is no offset between the start of the plaintext and the username, since the first two blocks are already the same without any padding needed. Now that we know the block size and offset, we can begin brute-forcing the StrongToken. We first provide an input one byte smaller than the block size, AAAAAAAAAAAAAAA. This creates a ciphertext block using the plaintext AAAAAAAAAAAAAAA?, where ? is the first byte of the StrongToken. Using the ciphertext block provided by the website as a reference output, we can brute-force the first byte of the StrongToken. By using the reference input, AAAAAAAAAAAAAAA, and iterating through all possible characters for the last byte, we can determine what the StrongToken’s first byte when our output matches the reference output. Reference Value: AAAAAAAAAAAAAAA = a764ad6331f1ed698044b8f4bf208dd7 Brute-Forcing: AAAAAAAAAAAAAAA! = d4e420b6abd4e19033ed1fdea60dabdb AAAAAAAAAAAAAAA&quot; = caee4360f81620169c15d01da4064629 [...snip...] AAAAAAAAAAAAAAA: = 0c775d6e025a1ad985ac8c339e261a47 AAAAAAAAAAAAAAA; = a764ad6331f1ed698044b8f4bf208dd7 ** MATCH ** By repeating this process and replacing more of the reference input with discovered StrongToken characters, we can slowly determine the StrongToken byte-by-byte. Using a Python script also makes this process less arduous. With this process, we are able to determine that the full StrongToken is fY5V/=B80?e4.CA8. (The initial character ; is only used as a divider between the plaintext and the StrongToken) By submitting the token to the website, we are able to receive the flag. Correct! The Flag is: ACI{c0db96acd85091480db76ed49ca}</summary></entry><entry><title type="html">All-Army CyberStakes 4 - Cryptography (Over Time: Paid)</title><link href="http://localhost:4000/acictf/ctf/cryptography/2020/05/13/acictf4-otp.html" rel="alternate" type="text/html" title="All-Army CyberStakes 4 - Cryptography (Over Time: Paid)" /><published>2020-05-13T02:00:00-10:00</published><updated>2020-05-13T02:00:00-10:00</updated><id>http://localhost:4000/acictf/ctf/cryptography/2020/05/13/acictf4-otp</id><content type="html" xml:base="http://localhost:4000/acictf/ctf/cryptography/2020/05/13/acictf4-otp.html">&lt;h1 id=&quot;over-time-paid-50-points&quot;&gt;Over Time: Paid (50 Points)&lt;/h1&gt;

&lt;p&gt;This is where the challegnes start getting more difficult. This problem starts with two files again: &lt;code class=&quot;highlighter-rouge&quot;&gt;document.encrypted&lt;/code&gt;, which contains 15 lines of hex, and &lt;code class=&quot;highlighter-rouge&quot;&gt;source.py&lt;/code&gt;, which contains what appears to be the script that generated the document. The script performs two key steps to create the document:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Generates the plaintext of the document with a static intro line, 10 random lines, a static outro line, and finally the flag.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Generates a random, 64-byte long key and XORs each line with it.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Based on the name of the challenge (&lt;strong&gt;O&lt;/strong&gt;ver &lt;strong&gt;T&lt;/strong&gt;ime: &lt;strong&gt;P&lt;/strong&gt;aid), we can see that this method is inspired by how a &lt;em&gt;One-time Pad&lt;/em&gt; works. One-time pads ensure complete and unbreakable secrecy for a message by encrypting it with a key of the same length, usually with the XOR operation. This encryption is only unbreakable &lt;em&gt;if and only if&lt;/em&gt; that key is used for &lt;strong&gt;only&lt;/strong&gt; that text and is never reused.&lt;/p&gt;

&lt;p&gt;The major weakness in this challenge’s implementation is that is only uses a 64-byte key to encrypt the &lt;em&gt;entire&lt;/em&gt; message. Furthermore, since we know exactly what the first line is, we can extract the key using a &lt;em&gt;known-plaintext attack&lt;/em&gt;, by virtue of how the XOR operation works. In XOR (\(\oplus\)) encryption, we can encrypt plaintext (\(P\)) into ciphertext (\(C\)) by XORing the plaintext with a key (\(K\)).&lt;/p&gt;

\[P \oplus K = C\]

&lt;p&gt;To decrypt the ciphertext, we only need to XOR the ciphertext with the key.&lt;/p&gt;

\[C \oplus K = P\]

&lt;p&gt;However, the mathematical properties of XOR also allow us to compute the &lt;em&gt;key&lt;/em&gt; by XORing the plaintext and ciphertext together.&lt;/p&gt;

\[P \oplus C = K\]

&lt;p&gt;In this challenge, the script provides us with a hardcoded intro statement, which is our plaintext for this attack. Since is the first line of text, we also know this corresponds to the first line of ciphertext in &lt;code class=&quot;highlighter-rouge&quot;&gt;document.encrypted&lt;/code&gt;. By XORing these two lines together, we can compute the 64-byte key used throughout the encrypted document using &lt;a href=&quot;https://gchq.github.io/CyberChef/#recipe=XOR(%7B'option':'Hex','string':'2246e0fe4f69ccb153f209b8cc73a5d87ce7cfdea8fa5ce35bb68b908e5a7e20f557810187bfc8b101a69b27edce27e15802d1f3eb7ef3dfb87eac2c6e12f4c0'%7D,'Standard',false)To_Hex('None',0)&amp;amp;input=VGhlIGZvbGxvd2luZyBlbmNvZGVkIGluZGl2aWR1YWxzIGFyZSB0byBiZSBnaXZlbiBhICQyNy4zayBib251cw&quot;&gt;CyberChef&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Note: We also need to make sure the lengths of the plaintext and ciphertext match, so we have to remove the &lt;code class=&quot;highlighter-rouge&quot;&gt;:&lt;/code&gt; at the end of the plaintext.&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Plaintext:  The following encoded individuals are to be given a $27.3k bonus
Ciphertext: 2246e0fe4f69ccb153f209b8cc73a5d87ce7cfdea8fa5ce35bb68b908e5a7e20f557810187bfc8b101a69b27edce27e15802d1f3eb7ef3dfb87eac2c6e12f4c0
Key:        762e85de2906a0dd3c8560d6ab53c0b61f88abbbccda358d3fdffdf9ea2f1f4c8677e073e29fbcde21c4fe078aa751843622b0d3cf4cc4f18b158c4e017c81b3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Finally, we can use this key in &lt;a href=&quot;https://gchq.github.io/CyberChef/#recipe=From_Hex('Auto')XOR(%7B'option':'Hex','string':'762e85de2906a0dd3c8560d6ab53c0b61f88abbbccda358d3fdffdf9ea2f1f4c8677e073e29fbcde21c4fe078aa751843622b0d3cf4cc4f18b158c4e017c81b3'%7D,'Standard',false)&amp;amp;input=MjI0NmUwZmU0ZjY5Y2NiMTUzZjIwOWI4Y2M3M2E1ZDg3Y2U3Y2ZkZWE4ZmE1Y2UzNWJiNjhiOTA4ZTVhN2UyMGY1NTc4MTAxODdiZmM4YjEwMWE2OWIyN2VkY2UyN2UxNTgwMmQxZjNlYjdlZjNkZmI4N2VhYzJjNmUxMmY0YzAKNGMyNGQ2OTc2YzU0ZjI5YzFjYzYyODk3ZjkxZjg5ZjMzZmQyZWVlZjhkZmE3Y2MzN2I5NmJjZDlhYjYzNGYwNGM3NTdhMTNmYjJkN2ZkZmU2ODhhYmE0ZWNiODcxOGNhNzI2YmYxZjM4ZTAwOTRiOWNhMzVjZTFjNDAyYWNlOTMKNTYyNGMxOWI2NTUyZTFmZDY4YzQyZTkxZTQ3Mzk0Zjc1MWNmZTQ5YjhiOTU3OWNiMWY4YmJjYjdhZDYwM2YwNGM5MjNhNTNmYzJjNWY5OGE2MGU0YjY0OGRlZTIxZGE0NzE2ZGZjOTVlZjBkODhhMWMzNTRhYzBiNDIzNGNlOTMKNTYyNGM2OTY2ODU0ZWM5NDc5YTUzNDk3ZTUxNDhmOTY0Y2MxZWVlOTllOWIxNWM0NzE5YmI0YjhjYTdjNTYwOWQ0MjVhMTUzYTZkYWYwOGE2MGU0YmM1NWNiZjExZWE0NjI2M2ZlOTQ4MDZjOGNiZWRmNTBjMDZlNDYzM2NkZjUKNTYyNGQxOWY2NzQxZWZmZDc4YzAyYzgyZWE3Mzg0ZjM1M2RjZWE5YjhkOTY2NWM1N2VmZmJjYjViYTY3NWU2Y2M1M2ZhMTIxYWVkNmY5ZmU2MjhjYmY1NWM2ZWUxNGE0NmM2N2U0OTJlZjE2ODFhNWNhMzVkZjA3NDQyZWQzZjIKNTYyNGMyOTE2NTQwODA5NDcyYzEyOTk3OGIxNjgzZmU1MGE4ZjFmZTk4OWIxNWM5N2E5M2E5YjhjYTY4NTAwMGMwNTdhNzNjYWVkOTljOWE2NDg4YWE0NmFhZTIxMmNjNzkwMmY1OTA4NzAzZTRiOGM1NTFjNTBmMjE1Y2ExOTMKNTYyNGQ2OTc2YzU0ZjI5YzFjYzMyZjhlZmYwMThmZTIzZmRjZWFmNThiOTUxNWM4N2M5N2IyZDlhZjZjNTcwM2E2MzNhNTNmYjZkZTljOWY2ZDk0YjY0NmFhZWYxZWQwNzM2ZTkwODc4ZTAyODNiZWFiNDFjZDAwNDYzM2ExOTMKNTYyNGNkOTE3ZDQzZWNmZDc4YzAyYzgyZWE3MzlhZjM0YmM5OGJmMzgzOGU3MGMxMWY5OWIyYTFiZTdkNTAxOGE2MmRhNTI3YTNiZmU4OWY2ZjgzYjEyN2MzZTkxNWNkNzcwMmY4OWM5YjA5ODhkMWNjNWFjMDA4MjE1Y2ExOTMKNTYyNGRmOWI3ZDQ3ODA5YTczYzkyNmY2ZTkwMTgxZTA1MGE4ZmZmYTgyOWQ3YWFkNzc5MGE5YmNhNjBmNGIwZGM4MzBhZjUzYTFkN2ZkOGM2ZDhkYmIyN2RlZTYxZmMzNzkwMmU0OTI4MTBiOGJkMWQ4NWNjOTFjNTMzZGExOTMKNTYyNGMzOTE3MTUyZjI5MjY4YTUyOTk4ZWYxYTgxOTY1YWNiZTNmNGVjOWI3OWRkNzc5ZWRkYWFhMzZhNGQxZWM3NTdhMjIxYTNjOWYzZmU2OThiYWE0MmM2ODcxOGNhNzI2YmYxZjM4NzAzOTBiNGM3MzVjZDAyNTEzNGMwOTMKNTYyNGQ2OTc2YzU0ZjI5YzFjY2QyZjgyZWUxZmUwZWM1YWRjZWE5Yjg1OTQ3MWM0N2VmZmI5YmNhNjdiNWU2Y2M0MjVhMTI1YWRiZmZiOTE2ZDgyZGU0MGM1ZWIxN2E0NjI2M2ZlOTQ4MDZjODNiZWM3NTNhYzZlMjE1Y2ExOTMKNTYyNGE1ZmUwOTI2ODBmZDFjYTU0MGY2OGI3M2UwOTYzZmE4OGI5YmVjZmExNWFkMWZmZmRkZDljYTBmM2Y2Y2E2NTdjMDUzYzJiZjljZmUwMWU0ZGUyN2FhODc3MWE0MTYwMjkwZjNlZjZjZTRkMWFiMzVhYzZlMjE1Y2ExOTMKNTYyNGMzYWI1YjcyYzhiODRlZTgwZmE0Y2U3ZmUwYzI3N2VkOGJmZDgwOWI3MmFkNTZhY2M3ZDljYTBmM2Y2Y2E2NTdjMDUzYzJiZjljZmUwMWU0ZGUyN2FhODc3MWE0MTYwMjkwZjNlZjZjZTRkMWFiMzVhYzZlMjE1Y2ExOTMKNTYyNDhmOWY2YTRmZGJlYjU5YjMwNWUyOWEzMWY2ODMyN2VkY2ZkOWFkZWE1M2JmMGFiYTlmY2NkYTFiMjYyOWUzNDY5ZDUzYzJiZjljZmUwMWU0ZGUyN2FhODc3MWE0MTYwMjkwZjNlZjZjZTRkMWFiMzVhYzZlMjE1Y2ExOTMKNTYwZThmCg&quot;&gt;CyberChef&lt;/a&gt; to XOR the remaining lines and decrypt the entire document and extract the flag.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[..snip..]
Furthermore, the FLAG is:                                      

ACI{6e6e41b658edba0f25eb5049ee1}                               
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;script type=&quot;text/x-mathjax-config&quot;&gt;
  MathJax.Hub.Config({
    extensions: [
      &quot;MathMenu.js&quot;,
      &quot;MathZoom.js&quot;,
      &quot;AssistiveMML.js&quot;,
      &quot;a11y/accessibility-menu.js&quot;
    ],
    jax: [&quot;input/TeX&quot;, &quot;output/CommonHTML&quot;],
    TeX: {
      extensions: [
        &quot;AMSmath.js&quot;,
        &quot;AMSsymbols.js&quot;,
        &quot;noErrors.js&quot;,
        &quot;noUndefined.js&quot;,
      ]
    }
  });
&lt;/script&gt;

&lt;script type=&quot;text/javascript&quot; async=&quot;&quot; src=&quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML&quot;&gt;
&lt;/script&gt;</content><author><name></name></author><summary type="html">Over Time: Paid (50 Points) This is where the challegnes start getting more difficult. This problem starts with two files again: document.encrypted, which contains 15 lines of hex, and source.py, which contains what appears to be the script that generated the document. The script performs two key steps to create the document: Generates the plaintext of the document with a static intro line, 10 random lines, a static outro line, and finally the flag. Generates a random, 64-byte long key and XORs each line with it. Based on the name of the challenge (Over Time: Paid), we can see that this method is inspired by how a One-time Pad works. One-time pads ensure complete and unbreakable secrecy for a message by encrypting it with a key of the same length, usually with the XOR operation. This encryption is only unbreakable if and only if that key is used for only that text and is never reused. The major weakness in this challenge’s implementation is that is only uses a 64-byte key to encrypt the entire message. Furthermore, since we know exactly what the first line is, we can extract the key using a known-plaintext attack, by virtue of how the XOR operation works. In XOR (\(\oplus\)) encryption, we can encrypt plaintext (\(P\)) into ciphertext (\(C\)) by XORing the plaintext with a key (\(K\)). \[P \oplus K = C\] To decrypt the ciphertext, we only need to XOR the ciphertext with the key. \[C \oplus K = P\] However, the mathematical properties of XOR also allow us to compute the key by XORing the plaintext and ciphertext together. \[P \oplus C = K\] In this challenge, the script provides us with a hardcoded intro statement, which is our plaintext for this attack. Since is the first line of text, we also know this corresponds to the first line of ciphertext in document.encrypted. By XORing these two lines together, we can compute the 64-byte key used throughout the encrypted document using CyberChef. Note: We also need to make sure the lengths of the plaintext and ciphertext match, so we have to remove the : at the end of the plaintext. Plaintext: The following encoded individuals are to be given a $27.3k bonus Ciphertext: 2246e0fe4f69ccb153f209b8cc73a5d87ce7cfdea8fa5ce35bb68b908e5a7e20f557810187bfc8b101a69b27edce27e15802d1f3eb7ef3dfb87eac2c6e12f4c0 Key: 762e85de2906a0dd3c8560d6ab53c0b61f88abbbccda358d3fdffdf9ea2f1f4c8677e073e29fbcde21c4fe078aa751843622b0d3cf4cc4f18b158c4e017c81b3 Finally, we can use this key in CyberChef to XOR the remaining lines and decrypt the entire document and extract the flag. [..snip..] Furthermore, the FLAG is: ACI{6e6e41b658edba0f25eb5049ee1}</summary></entry><entry><title type="html">All-Army CyberStakes 4 - Cryptography (Really Senseless Admins)</title><link href="http://localhost:4000/acictf/ctf/cryptography/2020/05/13/acictf4-rsa.html" rel="alternate" type="text/html" title="All-Army CyberStakes 4 - Cryptography (Really Senseless Admins)" /><published>2020-05-13T01:00:00-10:00</published><updated>2020-05-13T01:00:00-10:00</updated><id>http://localhost:4000/acictf/ctf/cryptography/2020/05/13/acictf4-rsa</id><content type="html" xml:base="http://localhost:4000/acictf/ctf/cryptography/2020/05/13/acictf4-rsa.html">&lt;h1 id=&quot;really-senseless-admins-35-points&quot;&gt;Really Senseless Admins (35 Points)&lt;/h1&gt;

&lt;p&gt;Here, we are provided with two files: &lt;code class=&quot;highlighter-rouge&quot;&gt;flag.enc&lt;/code&gt;, containing a very large decimal number, and &lt;code class=&quot;highlighter-rouge&quot;&gt;params.txt&lt;/code&gt;, containing three decimal numbers, &lt;code class=&quot;highlighter-rouge&quot;&gt;p&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;q&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;e&lt;/code&gt;. Based on the challenge’s title (&lt;strong&gt;R&lt;/strong&gt;eally &lt;strong&gt;S&lt;/strong&gt;enseless &lt;strong&gt;A&lt;/strong&gt;dmins), these numbers must be the parameters that generate the &lt;em&gt;RSA&lt;/em&gt; private key which decrypts the flag. Using the tool provided by &lt;a href=&quot;https://www.cryptool.org/en/cto-highlights/rsa-step-by-step&quot;&gt;CrypTool&lt;/a&gt;, we can easily generate the key and decrypt the flag by simply copying and pasting the values into it. However, it’s still worthwhile to understand the underlying theory behind how RSA works, for both knowledge purposes and to help in a later challenge. You can read into it &lt;a href=&quot;https://en.wikipedia.org/wiki/RSA_(cryptosystem)#Key_generation&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;After decrypting the message contained in &lt;code class=&quot;highlighter-rouge&quot;&gt;flag.enc&lt;/code&gt;, we get a slightly smaller decimal number. One thing to remember is that all information contained in memory is stored as and can by represented by a number. Hexadecimal numbers are used since it’s easy to represent individual bytes of data with it. Every 4-bits of data are represented by one hex number, so a byte (8-bits) is represented by two hex numbers. For example, the string &lt;code class=&quot;highlighter-rouge&quot;&gt;ABCDE&lt;/code&gt; is represented in hex as &lt;code class=&quot;highlighter-rouge&quot;&gt;0x4142434445&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We can also represent these hex numbers as a normal decimal number. If we convert the previous hex number into decimal, we can also write the string &lt;code class=&quot;highlighter-rouge&quot;&gt;ABCDE&lt;/code&gt; as the number &lt;code class=&quot;highlighter-rouge&quot;&gt;280284578885&lt;/code&gt;. Keep in mind, this is an unusual way to represent strings since, unlike hex, a small change in any character will drastically change the entire decimal number. Changing the string to &lt;code class=&quot;highlighter-rouge&quot;&gt;BBCDE&lt;/code&gt; causes it to become the number &lt;code class=&quot;highlighter-rouge&quot;&gt;284579546181&lt;/code&gt;, while its hex version simply sees a change in the first two places, &lt;code class=&quot;highlighter-rouge&quot;&gt;0x4242434445&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;To get the flag, we just need to apply this principle in the reverse direction: Convert the decimal number into hex and then decode each byte into its character equivalent. We can easily perform this task by using &lt;a href=&quot;https://gchq.github.io/CyberChef/#recipe=To_Base(16)From_Hex('Auto')&amp;amp;input=MTA0ODczMzQwNDU5MDU0OTI0MTgxMTE1MjkyNTQ2MzE1OTEzMDkyNjcwNTAwNDkwNTE1ODI2NDE3NDgxMzQx&quot;&gt;CyberChef&lt;/a&gt; again.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Decimal Plaintext: 104873340459054924181115292546315913092670500490515826417481341
Hex Plaintext:     0x4143497b5072316d33735f54214d337a5f34373533393062367d
ASCII Plaintext:   ACI{Pr1m3s_T!M3z_475390b6}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;!--The operation of RSA depends on three key values, `e`, `d`, and `n`. `e` is called the *encryption exponent*, and combined with `n` makes up the *public key*. `d` is called the *decryption exponent*, and combined with `n` makes up the *private key*. These two keys have a relationship where anything that is encrypted by the *public key* can **only** be decrypted by the *private key*. And the reverse applies too; anything encrypted by the *private key* can only be decrypted by the *public key*.--&gt;</content><author><name></name></author><summary type="html">Really Senseless Admins (35 Points) Here, we are provided with two files: flag.enc, containing a very large decimal number, and params.txt, containing three decimal numbers, p, q, and e. Based on the challenge’s title (Really Senseless Admins), these numbers must be the parameters that generate the RSA private key which decrypts the flag. Using the tool provided by CrypTool, we can easily generate the key and decrypt the flag by simply copying and pasting the values into it. However, it’s still worthwhile to understand the underlying theory behind how RSA works, for both knowledge purposes and to help in a later challenge. You can read into it here. After decrypting the message contained in flag.enc, we get a slightly smaller decimal number. One thing to remember is that all information contained in memory is stored as and can by represented by a number. Hexadecimal numbers are used since it’s easy to represent individual bytes of data with it. Every 4-bits of data are represented by one hex number, so a byte (8-bits) is represented by two hex numbers. For example, the string ABCDE is represented in hex as 0x4142434445. We can also represent these hex numbers as a normal decimal number. If we convert the previous hex number into decimal, we can also write the string ABCDE as the number 280284578885. Keep in mind, this is an unusual way to represent strings since, unlike hex, a small change in any character will drastically change the entire decimal number. Changing the string to BBCDE causes it to become the number 284579546181, while its hex version simply sees a change in the first two places, 0x4242434445. To get the flag, we just need to apply this principle in the reverse direction: Convert the decimal number into hex and then decode each byte into its character equivalent. We can easily perform this task by using CyberChef again. Decimal Plaintext: 104873340459054924181115292546315913092670500490515826417481341 Hex Plaintext: 0x4143497b5072316d33735f54214d337a5f34373533393062367d ASCII Plaintext: ACI{Pr1m3s_T!M3z_475390b6}</summary></entry><entry><title type="html">All-Army CyberStakes 4 - Cryptography (Rotate Me)</title><link href="http://localhost:4000/acictf/ctf/cryptography/2020/05/13/acictf4-rotateme.html" rel="alternate" type="text/html" title="All-Army CyberStakes 4 - Cryptography (Rotate Me)" /><published>2020-05-13T00:00:00-10:00</published><updated>2020-05-13T00:00:00-10:00</updated><id>http://localhost:4000/acictf/ctf/cryptography/2020/05/13/acictf4-rotateme</id><content type="html" xml:base="http://localhost:4000/acictf/ctf/cryptography/2020/05/13/acictf4-rotateme.html">&lt;h1 id=&quot;rotate-me-5-points&quot;&gt;Rotate Me (5 Points)&lt;/h1&gt;

&lt;p&gt;This one is a very simple problem, especially considering it’s only worth 5 points. We start with a text file that contains enciphered text, which already seems to be in the expected format of a flag.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;IKQ{KzGxBw_NcV_nWz_ItT_ScrflorN}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Based on the name of the challenge and the hints mentioning “Julius”, it’s safe to assume that this is a &lt;em&gt;Caesar cipher&lt;/em&gt;, also known as a &lt;em&gt;Rotation (ROT-N) cipher&lt;/em&gt;. This is a very simple enciphering method where you “shift” each character to the right by &lt;em&gt;N&lt;/em&gt; number of places. Going beyond “Z” just causes you to rotate back around to “A”, which is where the term &lt;em&gt;Rotation cipher&lt;/em&gt; comes from. In order to decrypt the text, you just need to shift the characters the same number of places in the &lt;em&gt;other&lt;/em&gt; direction to the left. For example, in a classic Caesar (or ROT-3) cipher the encryption and decryption process looks like this:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Plaintext:  HELLO WORLD
Ciphertext: KHOOR ZRUOG
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Since you rotate back to “A” when you hit “Z”, anything above a ROT-25 cipher is equivalent to a cipher between ROT-0 to ROT-25. (You can calculate exactly what it’s equivalent to by computing &lt;code class=&quot;highlighter-rouge&quot;&gt;N mod 26&lt;/code&gt;) This means that the total number of possible keys in a Caesar cipher is only &lt;strong&gt;25&lt;/strong&gt;. This is easily brute-forced by hand and is exceptionally trivial for a computer to crack. However, if we wanted to be fancy about it, we can crack it like a &lt;em&gt;known-plaintext attack&lt;/em&gt;. We know that the first three characters have to be &lt;code class=&quot;highlighter-rouge&quot;&gt;ACI&lt;/code&gt;. By comparing first letters of the plaintext and ciphertext, we can calculate that the key is &lt;code class=&quot;highlighter-rouge&quot;&gt;9 - 1 = 8&lt;/code&gt;, since &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; is the 1st character of the alphabet and &lt;code class=&quot;highlighter-rouge&quot;&gt;I&lt;/code&gt; is the 9th. So by rotating to the left by &lt;strong&gt;8&lt;/strong&gt; spaces (or 18 spaces to the right, since &lt;code class=&quot;highlighter-rouge&quot;&gt;-8 mod 26 = 18&lt;/code&gt;), we can decrypt the flag. It’s easy to do this using a common tool such as &lt;a href=&quot;https://gchq.github.io/CyberChef/#recipe=ROT13(true,true,18)&amp;amp;input=SUtRe0t6R3hCd19OY1Zfbld6X0l0VF9TY3JmbG9yTn0&quot;&gt;CyberChef&lt;/a&gt;.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Ciphertext: IKQ{KzGxBw_NcV_nWz_ItT_ScrflorN}
Plaintext:  ACI{CrYpTo_FuN_fOr_AlL_KujxdgjF}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><summary type="html">Rotate Me (5 Points)</summary></entry></feed>