<!DOCTYPE html>



<html lang="en-US" 
  
    mode="dark"
  
>

  <!--
  The Head
-->

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  

    

    

  

  <!-- Begin Jekyll SEO tag v2.7.1 -->
<meta name="generator" content="Jekyll v4.2.0" />
<meta property="og:title" content="H@CktivityCon 2021 CTF Writeups" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Warmups Six Four Over Two (50 points) We are provided with a short text file containing the string: EBTGYYLHPNQTINLEGRSTOMDCMZRTIMBXGY2DKMJYGVSGIOJRGE2GMOLDGBSWM7IK. Based on the name of the challenge, this could potentially be a Base32-encoded string. (Because \(\frac{64}{2} = 32\)) We test our theory using CyberChef and immediately get the flag: flag{a45d4e70bfc407645185dd9114f9c0ef} Bass64 (50 points) We are provided with another text file, this time containing what appears to be a garbled mess of lines. However, simply disabling word wrap in Notepad allows us to see that it’s just ASCII word art for the string IGZsYWd7MzVhNWQxM2RhNmEyYWZhMGM2MmJmY2JkZDYzMDFhMGF9. Because it’s a relatively short string and I don’t know of anything that can convert from ASCII art back to text, we just manually parse and copy the text. 1 2 3 4 5 6 ___ ____ _____ __ ____ __ _ _____ __ __ __ ___ _ _ __ _____ __ __ ____ ____ _ _ _ _____ __ ____ ________ __ __ ____ __ __ ____ __ __ _ __ ______ _ _ ____ _______ __ __ __ ____ _____ _ __ __ ____ _____ ___ |_ _/ ___|__ /__\ \ / /\ \ / /_| |___ | \/ |___\ \ / / |__ | \ | |\ \ / / _ \ __ _| \/ |___ \| _ \| |__ | \ | |_ __ ___ | ____| _ \ \ / /\ \ / /__ / |__ | \/ |/ ___| \/ |___ \| \/ |_ __ ___ | | _ __ __\ \ / /___ \ | | | __|__ /| _ \ \ / /__| \/ | _ \| ___| |__ | \/ |/ ___| ___/ _ \ | | | _ / // __\ V / \ \ /\ / / _` | / /| |\/| |_ /\ \ / /| &#39;_ \| \| | \ \ /\ / / | | |\ \/ / |\/| | __) | |_) | &#39;_ \| \| | &#39;_ ` _ \| _|| | | | \ V / \ \ /\ / / / /| &#39;_ \| |\/| | | _| |\/| | __) | |\/| | &#39;_ ` _ \ _ | || &#39;_ ` _ \ V / __) | | | |/ / / / | | | \ V /_ / |\/| | | | | |_ | &#39;_ \ | |\/| | | _| |_ | (_) | | | |_| |/ /_\__ \| | \ V V / (_| | / / | | | |/ / \ V / | | | | |\ | \ V V /| |_| | &gt; &lt;| | | |/ __/| _ &lt;| | | | |\ | | | | | | |__| |_| | | | \ V V / / /_| | | | | | | |_| | | | |/ __/| | | | | | | | | |_| || | | | | | | / __/ |_| | &lt; / /_ | |_| || | / /| | | | |_| | _| | | | || | | | |_| | _| \__, | |___\____/____|___/|_| \_/\_/ \__,_|/_/ |_| |_/___| \_/ |_| |_|_| \_| \_/\_/ \__\_\/_/\_\_| |_|_____|_| \_\_| |_|_| \_|_| |_| |_|_____\__, | |_| \_/\_/ /____|_| |_|_| |_|\____|_| |_|_____|_| |_|_| |_| |_|\___/ |_| |_| |_|_| |_____\___/|_|\_\/____ |____/ |_|/___|_| |_|____/|_| |_| |_||_| |_|\____|_| /_/ |___/ Based on both the challenge name and the format of the string, we can assume that this is a Base64-encoded string. Putting this into CyberChef gives us the flag: flag{35a5d13da6a2afa0c62bfcbdd6301a0a} Pimple (50 points) This one is pretty simple. Using file on attachment shows that it’s a GIMP file. Then after opening the file in GIMP and looking through the content, we find the flag printed on one of the inner layers: flag{9a64bc4a390cb0ce31452820ee562c3f} 1 2 $ file pimple pimple: GIMP XCF image data, version 011, 1024 x 1024, RGB Color Tsunami (50 points) Using file again, we discover that this is a .wav file. 1 2 $ file tsunami tsunami: RIFF (little-endian) data, WAVE audio, Microsoft PCM, 16 bit, stereo 44100 Hz The end of the audio is a series of tones that makes me think it’s spectrogram steganography. After finding a website that let’s us view the spectrogram of an audio file(Academo), we see that those series of tones make up the flag value: flag{f8fbb2c761821d3af23859f721cc140b}. If it’s hard to make out the flag yourself, just remember that all of the letters are lowercase so they can’t be confused with a number. Butter Overflow (50 points) This time we’re provided with three files. An executable file: butter_overflow The source code of the executable: source.c A Makefile we can use to compile the source code ourselves After examining the source code, we discover the following information about the program’s behavior: Line 43 - Creates a buffer array that can store up to 512 bytes Line 51 - Directly saves user input into this buffer, without size checks Lines 48 &amp; 10 - Runs the give_flag() function if there’s a segmentation fault So the solution is simple, if we provide enough input to the program to cause a buffer overflow, it’ll trigger a segmentation fault and give us the flag. Sure enough, sending 600 A’s to the challenge server prints out the flag: flag{72d8784a5da3a8f56d2106c12dbab989} Oddball (103 points) Funnily enough, this warmup challenge ended up being worth more than some of the “real” challenges. Here, we are given an oddball file containing several lines of numbers. 1 2 3 4 5 6 7 8 0000000 067531 020165 067165 067543 062566 062562 020144 064164 0000020 020145 062563 071143 072145 066440 071545 060563 062547 0000040 035440 005051 072516 061155 071145 020163 067151 071040 0000060 067141 062547 030040 033455 020077 066510 066555 020041 0000100 067510 020167 062157 005041 063012 060554 075547 060462 0000120 031065 061462 033062 034143 060467 031546 034461 061062 0000140 031064 031543 063064 031544 033062 034063 061065 005175 0000160 After analyzing the file for a bit, we realize that there are no numbers greater than 7, so the file must be a list of octal numbers. As it turns out, the famous xxd tool has a lesser known uncle called od. But rather than hexdumps, this program creates octal dumps of files in the exact same format as the oddball file. Unfortunately, od doesn’t appear to have a reversal function like xxd does, so we have to make one ourselves. After taking out the first column of numbers, we can use the following python3 script to decode oddball. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from pwn import * oct = &quot;&quot;&quot;067531 020165 067165 067543 062566 062562 020144 064164 020145 062563 071143 072145 066440 071545 060563 062547 035440 005051 072516 061155 071145 020163 067151 071040 067141 062547 030040 033455 020077 066510 066555 020041 067510 020167 062157 005041 063012 060554 075547 060462 031065 061462 033062 034143 060467 031546 034461 061062 031064 031543 063064 031544 033062 034063 061065 005175&quot;&quot;&quot;.split() for num in oct: # Decodes the octal string into its byte form # ^──────────────┐ # Reverses the endianess of the byte so it prints correctly # ^────┐ | # Decodes the byte into a printable string # ^────|─────────|───────┐ # V V V print(p16(int(num, 8)).decode(&#39;utf-8&#39;), end=&#39;&#39;) Running this script provides us with the following output containing the flag: 1 2 3 4 You uncovered the secret message ;) Numbers in range 0-7? Hmmm! How od! flag{2a522c26c87af3192b42c34fd326385b} Web Confidentiality (50 points) This challenge involves a simple command injection vulnerability. We’re provided with a web application that gives us the ability to check the access control settings for any given file on the server. To start, we test it out with a known file, /etc/passwd. These results seem eerily similar to what ls -l does. It appears that the application is simply taking our input and appending it to an ls -l command. So if we wanted to see the files in our current directory, we could provide it with a period (.). Of course, we would normally just run ls -l on its own for the same effect, but the application rejects an empty input. This is the exact output we would expect from an ls -l . command. So our goal now is to output the contents of the flag.txt file within this directory. To verify our command injection capabilities, we can use the ; character to append a second command to this line. By sending a request for ; whoami, we predict that the server will run the command ls -l ; whoami, showing us the current directory and username. Success! This shows us that we have the ability to execute commands on the server. Now we just need to send a ; cat flag.txt request to output the flag, which ends up being: flag{e56abbce7b83d62dac05e59fb1e81c68} Bonus: If we wanted to, we can also see the source code for the application itself. A ; cat main.py request outputs the contents of main.py and shows how the application operates. And exactly how we predicted, the application is simply appending our input to the end of an ls -l command, without any verification or sanitization. Titanic (50 points) This challenge involves leveraging a server-side request forgery (SSRF) to access sensitive, internal information. The website contains two main features that we will use: an admin login page and a URL capturer service. The admin login is fairly normal. Since we obviously don’t have any admin credentials, we cannot make real use of this section right now. However, one thing of note about this page is the unique way it sends login attempts. Normally, logins would be sent as a POST request, with the username and password in the body. But here, the login attempt is made as a GET request, with the username and password in the URL. A username and password of test:test is performed with the URL http://challenge.ctf.games:31971/admin.php?uname=test&amp;psw=test. While this behavior isn’t particularly useful to us right now, it will become very important later on. Moving on to the URL capturer service. This service simply takes the URL we provide, makes a request to that URL on our behalf, and gives back a screenshot of the webpage. This service can allow us to perform an SSRF to disclose sensitive, local information on the server. It’s actually difficult to really call it an SSRF vulnerability because it’s clearly intended behavior. But to first validate that we can use it for SSRF, we will make a request to http://localhost and verify that we receive the same webpage. The request is successful! We receive back the loading circle for the website, showing that it is successfully making a request to http://localhost. As far as how to use it though, the robots.txt file for the website points to the /server-status page as an option. When we make a request to that page ourselves, it gives back a 403 Forbidden error. However, if we ask the server to request it locally at http://localhost/server-status, we get back the full status page for this webserver. Remember how login attempts are made as a GET request? Because of that, now we can clearly see a username and password for a previously successful login attempt: root:EYNDR4NhadwX9rtef. Using these credentials, we can access the admin page and retrieve the flag: flag{88269d5ef52a5ee961ea6449e1b610a9}. Cryptography N1TP (50 Points) This challenge is deceptively simple. When we first connect to the server, “Nina” provides us with the ciphertext of the flag. We should also note that the ciphertext changes between connections. After this, they give us the option to provide our own plaintext to see the resulting ciphertext. While providing the ciphertext, Nina also confirms that we’re dealing with a one-time pad (OTP). Nina is correct in saying that OTPs are unbreakable. However, this is with the giant caveat that the OTP is used correctly. If you were to ever reuse a OTP’s key, like what Nina is doing here, it gives an attacker an opportunity to break the encryption. Even worse, if you reuse the key on plaintext that the attacker already knows, that OTP is completely broken. The reason for this is that a OTP uses the exclusive OR (XOR) operation to perform its encryption and decryption. Normal use of an XOR (\(\oplus\)) cipher goes like this: [\textbf{Encryption: } \text{Plaintext} \oplus \text{Key} = \text{Ciphertext}] [\textbf{Decryption: } \text{Ciphertext} \oplus \text{Key} = \text{Plaintext}] However, we if know the plaintext and ciphertext of a message, we can also compute the key using the properties of the XOR operation. [\text{Plaintext} \oplus \text{Ciphertext} = \text{Key}] So using this principle, we can perform a known-plaintext attack on Nina’s OTP to derive the key. Our first step is to encrypt a plaintext value the same length of the flag. For this, we will choose 00000000000000000000000000000000000000. After receiving back the ciphertext for this message, we can XOR the plaintext and ciphertext together to determine the OTP key using CyberChef. Finally, we can XOR the flag’s ciphertext and the key together to reveal the flag in plaintext: flag{9276cdb76a3dd6b1f523209cd9c0a11b}. Miscellanious Bad Words (50 points) This challenge generously gives us a bash shell on the server at the jump. The catch is that we’re placed into an extremely restrictive jailshell. If we attempt to use many of our common commands, such as ls, id, and whoami, the shell yells at us for using a “bad word”. Thankfully after testing several options, we finally have success with the command /bin/sh -i. This breaks us out of the jailshell and drops us into a non-restricted sh shell. A few ls commands reveals the path to the flag file in ~/just/out/of/reach/flag.txt, which we can cat to retrieve the flag: flag{2d43e30a358d3f30fe65cc47a9cbbe98}. If you want to know how the jailshell works, its code is contained within the .bashrc file. It defines a bad_words() function that compares each argument in a user’s commands against a list of “bad words”. Then using the trap &#39;bad_words&#39; DEBUG command, it forces this function to run before any command is executed by the user. If one of the arguments matches one of the bad words, it stops the user’s command from running. However, we are able to get past it because it only checks for bad words starting from the beginning of the argument. This is because of the regex they’re using for matching (^$i.*). The ^ character anchors the match to only from the beginning of the string. So although sh is a bad word, /bin/sh goes undetected because the preceding /bin/ breaks the match. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 shopt -s extdebug function bad_words() { declare -a arr=(&quot;alert&quot; &quot;egrep&quot; &quot;fgrep&quot; &quot;grep&quot; &quot;l&quot; &quot;la&quot; &quot;ll&quot; &quot;ls&quot; [...snip...] &quot;less&quot; &quot;lessecho&quot; &quot;flag&quot; &quot;root&quot;) for i in &quot;${arr[@]}&quot; do if [[ &quot;$BASH_COMMAND&quot; =~ ^$i.* ]]; then echo &quot;You said a bad word, \&quot;$i\&quot;!!&quot; return 1; fi; done return; } trap &#39;bad_words&#39; DEBUG OSINT Jed Sheeran (50 points) This challenge asks us to look for an aspiring music artist named Jed Sheeran. The actual discovery process is simple because a Google search for “Jed Sheeran” puts his SoundCloud as the first result. Jed’s profile has one song that contains a mess of beeps and squeaks. This sound is actually a Slow-Scan Television (SSTV) signal, a method to transmit images as an analog signal. SSTV is popular within the amateur radio community particularly because it’s a way to send and receive images using very little bandwidth. It’s also common to see this in augmented reality games (ARG) or easter eggs as a way to hide pictures, like here in Portal 2. So to retrieve the flag from this audio file, all we need to do is decode the SSTV signal it’s playing. One way to do it is to download an SSTV decoder app like Robot36 and hold your phone’s microphone up to your computer speakers. But you need to keep in mind that SSTV is an analog signal. So any noise in the signal will cause us to receive a degraded image. The more noise, the worse the image looks. However, we could use a something called a virtual audio cable, such as VB-CABLE, to connect our browser’s audio directly to an SSTV decoder program, like RX-SSTV. This will theoretically send the SSTV signal directly from SoundCloud to our decoder without any noise. Well… the flag is clearly there, but it’s extremely hard to decipher. A lot of things could be happening here. SoundCloud could be compressing the SSTV audio before it’s stored, causing additional distortion in our image. It could also be that the flag’s text is too small for this SSTV mode. SSTV isn’t exactly known for sending extremely clear images, even in a perfect world. So people normally use bigger text in an image to compensate for that or switch to a more “robust” SSTV mode. The Jed Sheeran signal appears to be using the Robot 36 mode and is about 36 seconds long. Compare this to the following SSTV image I picked up from the International Space Station that uses PD120 and is about 120 seconds long. It has text about the same size as the Jed Sheeran signal, but this time it’s actually intelligible. Keep in mind that I received this signal from space, as well. So where do we go from here? We could try really hard to determine what each character is. But, it seems that the challenge creator recognized how hard this was and decided to just put the flag in the song’s description: flag{59e56590445321ccefb4d91bba61f16c}. Scripting Words Church (407 points) It appears that people either don’t like scripting or just don’t know how to script because these challenges ended up being worth a lot of points. The description tells us we’ll have to solve 30 word searches, so let’s connect to the server and see what we’re dealing with. It looks fairly simple. We’re provided with a \(15 \times 15\) grid of characters and five words to find. The biggest challenge is really going to be how to parse everything. pwntools makes the sending and receiving part of the challenge easy, so all we have to worry about is how to process the information. The following python3 script let’s use receive the grid used for the game: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from pwn import * io = remote(&#39;challenge.ctf.games&#39;, 32497) io.recvuntil(&#39;&gt;&#39;) io.send(&#39;play&#39;) # Header lines io.recvlines(3) # Grid lines io.recvlines(16) # Trailing lines io.recvlines(2) After putting this into the python3 interpreter, we verify that we’re correctly aligned to process the grid. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 Python 3.9.2 (default, Feb 28 2021, 17:03:44) [GCC 10.2.1 20210110] on linux Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information. &gt;&gt;&gt; from pwn import * &gt;&gt;&gt; io = remote(&#39;challenge.ctf.games&#39;, 32497) (&#39;&gt;&#39;) io.send(&#39;play&#39;)[x] Opening connection to challenge.ctf.games on port 32497 [x] Opening connection to challenge.ctf.games on port 32497: Trying 34.122.187.139 [+] Opening connection to challenge.ctf.games on port 32497: Done &gt;&gt;&gt; io.recvuntil(&#39;&gt;&#39;) b&quot;Words Church v1.0\n\n Let&#39;s play a game of wordsearch! We will display the grid\n and offer you words to find. Please submit the locations of\n each word in the format [(X,Y), (X,Y), (X,Y), ...] for each letter.\n\n Please enter &#39;example&#39; if you would like to see an \n example, or &#39;play&#39; if you would like to get started.\n &gt;&quot; &gt;&gt;&gt; io.send(&#39;play&#39;) &gt;&gt;&gt; &gt;&gt;&gt; # Headers &gt;&gt;&gt; io.recvlines(3) [b&#39; Wordsearch # 1/30:&#39;, b&#39;\t 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 : X&#39;, b&#39;\t--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---&#39;] &gt;&gt;&gt; &gt;&gt;&gt; # Grid lines &gt;&gt;&gt; io.recvlines(16) [b&#39; 0 | \t L P U C E U N K F C A Q T Q S H &#39;, b&#39; 1 | \t Q L Q Q K E S P U V A W X T M E &#39;, b&#39; 2 | \t E G O U H O U A Q D S K Z M T Y &#39;, b&#39; 3 | \t L Z S I F O S U J S S E N A O V &#39;, b&#39; 4 | \t I S M V D Y B B U G U O N J D J &#39;, b&#39; 5 | \t S J Q E T N L A V K R K Z W S I &#39;, b&#39; 6 | \t C P C R Y S E L K D E P S X A L &#39;, b&#39; 7 | \t Q Q T E W F Z L I M D E U S C O &#39;, b&#39; 8 | \t T G L D N N T Y J K I S Y L S B &#39;, b&#39; 9 | \t N E Q J I I X H S K B L K O H S &#39;, b&#39; 10 | \t V K M I U V U O K S K T Y E I T &#39;, b&#39; 11 | \t I M N F G V S O Z O S H R T T E &#39;, b&#39; 12 | \t H F Y K F S Q S Z J I I Z T J R &#39;, b&#39; 13 | \t H U X E T R Y N R Z J M Z S U S &#39;, b&#39; 14 | \t F R B D P Z K P K U N G A Q Y O &#39;, b&#39; 15 | \t M S O T B F R P F R R P M M Z T &#39;] &gt;&gt;&gt; &gt;&gt;&gt; # Trailing lines &gt;&gt;&gt; io.recvlines(2) [b&#39; ---&#39;, b&#39; Y &#39;] Translating the grid into a 2D-array is fairly trivial. All we have to do is split each line on whitespace to get a list of all characters, and then skip the first two characters that contain the Y coordinate and | separator. The following code does this for us: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 # Process grid lines for _ in range(16): # Decode the input from a bytestring into a normal string # ^─────────────────────────┐ # Split the string on whitespace, returning a list of each # ^ character in the string # └─────────────────────────│───────────────┐ # Skip the first two characters in the new list # ^─────────────────────────│───────────────│──────┐ grid.append( io.recvline().decode(&#39;utf-8&#39;).split()[2:] ) # Test grid print(grid) # Output &quot;&quot;&quot; [[&#39;L&#39;, &#39;P&#39;, &#39;U&#39;, &#39;C&#39;, &#39;E&#39;, &#39;U&#39;, &#39;N&#39;, &#39;K&#39;, &#39;F&#39;, &#39;C&#39;, &#39;A&#39;, &#39;Q&#39;, &#39;T&#39;, &#39;Q&#39;, &#39;S&#39;, &#39;H&#39;], [&#39;Q&#39;, &#39;L&#39;, &#39;Q&#39;, &#39;Q&#39;, &#39;K&#39;, &#39;E&#39;, &#39;S&#39;, &#39;P&#39;, &#39;U&#39;, &#39;V&#39;, &#39;A&#39;, &#39;W&#39;, &#39;X&#39;, &#39;T&#39;, &#39;M&#39;, &#39;E&#39;], [&#39;E&#39;, &#39;G&#39;, &#39;O&#39;, &#39;U&#39;, &#39;H&#39;, &#39;O&#39;, &#39;U&#39;, &#39;A&#39;, &#39;Q&#39;, &#39;D&#39;, &#39;S&#39;, &#39;K&#39;, &#39;Z&#39;, &#39;M&#39;, &#39;T&#39;, &#39;Y&#39;], [&#39;L&#39;, &#39;Z&#39;, &#39;S&#39;, &#39;I&#39;, &#39;F&#39;, &#39;O&#39;, &#39;S&#39;, &#39;U&#39;, &#39;J&#39;, &#39;S&#39;, &#39;S&#39;, &#39;E&#39;, &#39;N&#39;, &#39;A&#39;, &#39;O&#39;, &#39;V&#39;], [&#39;I&#39;, &#39;S&#39;, &#39;M&#39;, &#39;V&#39;, &#39;D&#39;, &#39;Y&#39;, &#39;B&#39;, &#39;B&#39;, &#39;U&#39;, &#39;G&#39;, &#39;U&#39;, &#39;O&#39;, &#39;N&#39;, &#39;J&#39;, &#39;D&#39;, &#39;J&#39;], [&#39;S&#39;, &#39;J&#39;, &#39;Q&#39;, &#39;E&#39;, &#39;T&#39;, &#39;N&#39;, &#39;L&#39;, &#39;A&#39;, &#39;V&#39;, &#39;K&#39;, &#39;R&#39;, &#39;K&#39;, &#39;Z&#39;, &#39;W&#39;, &#39;S&#39;, &#39;I&#39;], [&#39;C&#39;, &#39;P&#39;, &#39;C&#39;, &#39;R&#39;, &#39;Y&#39;, &#39;S&#39;, &#39;E&#39;, &#39;L&#39;, &#39;K&#39;, &#39;D&#39;, &#39;E&#39;, &#39;P&#39;, &#39;S&#39;, &#39;X&#39;, &#39;A&#39;, &#39;L&#39;], [&#39;Q&#39;, &#39;Q&#39;, &#39;T&#39;, &#39;E&#39;, &#39;W&#39;, &#39;F&#39;, &#39;Z&#39;, &#39;L&#39;, &#39;I&#39;, &#39;M&#39;, &#39;D&#39;, &#39;E&#39;, &#39;U&#39;, &#39;S&#39;, &#39;C&#39;, &#39;O&#39;], [&#39;T&#39;, &#39;G&#39;, &#39;L&#39;, &#39;D&#39;, &#39;N&#39;, &#39;N&#39;, &#39;T&#39;, &#39;Y&#39;, &#39;J&#39;, &#39;K&#39;, &#39;I&#39;, &#39;S&#39;, &#39;Y&#39;, &#39;L&#39;, &#39;S&#39;, &#39;B&#39;], [&#39;N&#39;, &#39;E&#39;, &#39;Q&#39;, &#39;J&#39;, &#39;I&#39;, &#39;I&#39;, &#39;X&#39;, &#39;H&#39;, &#39;S&#39;, &#39;K&#39;, &#39;B&#39;, &#39;L&#39;, &#39;K&#39;, &#39;O&#39;, &#39;H&#39;, &#39;S&#39;], [&#39;V&#39;, &#39;K&#39;, &#39;M&#39;, &#39;I&#39;, &#39;U&#39;, &#39;V&#39;, &#39;U&#39;, &#39;O&#39;, &#39;K&#39;, &#39;S&#39;, &#39;K&#39;, &#39;T&#39;, &#39;Y&#39;, &#39;E&#39;, &#39;I&#39;, &#39;T&#39;], [&#39;I&#39;, &#39;M&#39;, &#39;N&#39;, &#39;F&#39;, &#39;G&#39;, &#39;V&#39;, &#39;S&#39;, &#39;O&#39;, &#39;Z&#39;, &#39;O&#39;, &#39;S&#39;, &#39;H&#39;, &#39;R&#39;, &#39;T&#39;, &#39;T&#39;, &#39;E&#39;], [&#39;H&#39;, &#39;F&#39;, &#39;Y&#39;, &#39;K&#39;, &#39;F&#39;, &#39;S&#39;, &#39;Q&#39;, &#39;S&#39;, &#39;Z&#39;, &#39;J&#39;, &#39;I&#39;, &#39;I&#39;, &#39;Z&#39;, &#39;T&#39;, &#39;J&#39;, &#39;R&#39;], [&#39;H&#39;, &#39;U&#39;, &#39;X&#39;, &#39;E&#39;, &#39;T&#39;, &#39;R&#39;, &#39;Y&#39;, &#39;N&#39;, &#39;R&#39;, &#39;Z&#39;, &#39;J&#39;, &#39;M&#39;, &#39;Z&#39;, &#39;S&#39;, &#39;U&#39;, &#39;S&#39;], [&#39;F&#39;, &#39;R&#39;, &#39;B&#39;, &#39;D&#39;, &#39;P&#39;, &#39;Z&#39;, &#39;K&#39;, &#39;P&#39;, &#39;K&#39;, &#39;U&#39;, &#39;N&#39;, &#39;G&#39;, &#39;A&#39;, &#39;Q&#39;, &#39;Y&#39;, &#39;O&#39;], [&#39;M&#39;, &#39;S&#39;, &#39;O&#39;, &#39;T&#39;, &#39;B&#39;, &#39;F&#39;, &#39;R&#39;, &#39;P&#39;, &#39;F&#39;, &#39;R&#39;, &#39;R&#39;, &#39;P&#39;, &#39;M&#39;, &#39;M&#39;, &#39;Z&#39;, &#39;T&#39;]] &quot;&quot;&quot; The next step is to determine how to receive the words we need to search for. After we receive the grid lines, the questions are sent to us in the following format: LIEU: &gt; . All we need to do here is extract the word, which is very easy to do using split() again. 1 2 3 4 # Receive input until we hit the &#39;&gt;&#39; character question = io.recvuntil(&#39;&gt;&#39;).decode(&#39;utf-8&#39;) # Split the line on the &#39;:&#39; character and take everything before the &#39;:&#39; word = question.split(&#39;:&#39;)[0].strip() Now that we have our grid and words in a format we can process, it’s time to create the searching functions. While I’m sure there are super fast algorithms specifically designed to solve this problem, we’re going to stick with the naïve solution: go through every coordinate that matches the first letter of the word and search out from all eight directions to see if the rest of it matches. Here we have two components to design, the function to search through the entire grid, and the function to search out from a position to determine if the word matches. I’ve implemented them both in python3, as seen below: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 # Search from a given (x,y) position out a given direction # and return the positions of matching characters. # Returns an empty list `[]` if the match fails. def direction_search(word, grid, x, y, x_delta, y_delta): tiles = [] for c in word: # If this tile doesn&#39;t match the current character, # return an empty list. # The position also wraps around the edges of the grid. if grid[y % len(grid)][x % len(grid)] != c: return [] else: # If we&#39;re still matching, add this position as an # (x, y) tuple to the position list. tiles.append( (x, y) ) # Move in the given direction y += y_delta x += x_delta return tiles # Search each tile in the grid and determine if the word is found # in any 8 directions from each tile. # Returns list of positions if the word is found, empty list `[]`, # if not. def word_search(word, grid): for (y, row) in enumerate(grid): for (x, tile) in enumerate(row): # If this tile matches the first letter of the word, then # check if the rest of the word is found in any of the # 8 directions from this position. if tile == word[0]: for x_delta in [-1, 0, 1]: for y_delta in [-1, 0, 1]: search = direction_search(word, x, y, grid, x_delta, y_delta) if len(search) &gt; 0: return search return [] Finally, we can combine all of these elements in the final script and run it to solve the challenge to receive the flag: flag{ac670e1f34da9eb748b3f241eb03f51b}. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 #!/usr/bin/python3 from pwn import * import sys def direction_search(word, grid, x, y, x_delta, y_delta): tiles = [] for c in word: if grid[y % len(grid)][x % len(grid)] != c: return [] else: tiles.append( (x, y) ) y += y_delta x += x_delta return tiles def word_search(word, grid): for (y, row) in enumerate(grid): for (x, tile) in enumerate(row): if tile == word[0]: for x_delta in [-1, 0, 1]: for y_delta in [-1, 0, 1]: search = direction_search(word, grid, x, y, x_delta, y_delta) if len(search) &gt; 0: return search return [] def main(): # Connect to the challenge server port = int(sys.argv[1]) io = remote(&#39;challenge.ctf.games&#39;, port) # Start a game io.recvuntil(&#39;&gt;&#39;) io.send(&#39;play&#39;) for _ in range(30): # Skip header lines print(io.recvline().decode(&#39;utf-8&#39;).strip()) io.recvlines(2) # Process grid grid = [] for _ in range(16): grid.append( io.recvline().decode(&#39;utf-8&#39;).split()[2:] ) # Skip trailing lines io.recvlines(2) # Answer questions for _ in range(5): question = io.recvuntil(&#39;&gt;&#39;).decode(&#39;utf-8&#39;) word = question.split(&#39;:&#39;)[0].strip() answer = word_search(word, grid) io.sendline( str(answer).encode(&#39;utf-8&#39;) ) # Skip post-game lines io.recvlines(3) # Print the final output print(io.recvrepeat(5).decode(&#39;utf-8&#39;)) if __name__ == &quot;__main__&quot;: main() OTP Smasher (283 points) This is a pretty interesting challenge because it requires us to do some optical character recognition (OCR). We’re presented with a simple webpage displaying a picture of numbers, an submission field, and a counter in the upper-left. Chrome DevTools also shows that the page also attempts to display the image static/flag.png. Based on the challenge’s name, the number picture might be intended to act as a one-time password (OTP). Submitting the OTP increments the upper-left counter by one and waiting too long to submit another OTP resets it to zero. While this challenge was up, the creator eventually decided to increase the length of time allowed until a reset to help make the challenge a bit easier. So right now, we could technically manually submit 45 passwords to get the flag. But of course, that is no fun learning-wise and no fun because it’s super tedious. Using Chrome DevTools, we were able to figure out the format of the submission: a POST request to the main page with the password in a field called otp_entry. Using this information, we are now able to automate OTP submissions. 1 2 3 4 5 6 7 8 import requests from bs4 import BeautifulSoup as bs # Send the current `otp` to the server post = requests.post(f&quot;http://challenge.ctf.games:{port}/&quot;, data={&quot;otp_entry&quot;:otp}) # Print out the current counter value print( bs(post.text, &#39;html.parser&#39;).p ) The remaining problem is how to know what numbers to send? To accomplish this, we will make use of a software called Tesseract and its companion Python module, pytesseract. Combining this with the requests module to download the image and the PIL module to store the image, we can now automate OCR on the images to determine the OTP’s numbers. 1 2 3 4 5 6 7 8 9 10 11 12 13 import requests import pytesseract from PIL import Image from io import BytesIO # Retrieve the current OTP image get = requests.get(f&quot;http://challenge.ctf.games:{port}/static/otp.png&quot;) # Save the image into a PIL Image object image = Image.open(BytesIO(get.content)) # OCR the image to determine the OTP otp = pytesseract.image_to_string(image).strip() This gives us an 80% solution to the challenge. I say 80% because while it works most of the time, it fails enough that we have to manually step in every once in awhile. There’s probably a way to train tesseract to better recognize the OTP numbers, but we won’t dive into that realm for this challenge. For now, we’ll just check if the string from tesseract is a number. If it isn’t, then have the user type in the OTP manually. 1 2 3 4 5 6 # See if we get an error when converting the OTP to a number try: int(otp) except: # If the OTP isn&#39;t a number, make the user type it in manually otp = input(&quot;&gt;&quot;) Now that all of our components are created, we can combine them into the final script that’ll automatically send the OTPs to the server until it sees the flag: flag{f994cd9c756675b743b10c44b32e36b6}. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 import requests import pytesseract import sys from PIL import Image from io import BytesIO from bs4 import BeautifulSoup as bs port = int(sys.argv[1]) while True: # Retrieve the current OTP image get = requests.get(f&quot;http://challenge.ctf.games:{port}/static/otp.png&quot;) # Save the image into a PIL Image object image = Image.open(BytesIO(get.content)) # OCR the image to determine the OTP otp = pytesseract.image_to_string(image).strip() print(f&quot;OTP - {otp}&quot;) # See if we get an error when converting the OTP to a number try: int(otp) except: # If the OTP isn&#39;t a number, make the user type it in manually otp = input(&quot;&gt;&quot;) # Send the current `otp` to the server post = requests.post(f&quot;http://challenge.ctf.games:{port}/&quot;, data={&quot;otp_entry&quot;:otp}) # Print out the current counter value print( bs(post.text, &#39;html.parser&#39;).p ) # Check if the flag image is available yet flag = requests.get(f&quot;http://challenge.ctf.games:{port}/static/flag.png&quot;) if flag.status_code != 404: # If we find the flag, save it and end the script print(&quot;Flag found&quot;) with open(&quot;flag.png&quot;, &quot;wb&quot;) as f: f.write(flag.content) exit()" />
<meta property="og:description" content="Warmups Six Four Over Two (50 points) We are provided with a short text file containing the string: EBTGYYLHPNQTINLEGRSTOMDCMZRTIMBXGY2DKMJYGVSGIOJRGE2GMOLDGBSWM7IK. Based on the name of the challenge, this could potentially be a Base32-encoded string. (Because \(\frac{64}{2} = 32\)) We test our theory using CyberChef and immediately get the flag: flag{a45d4e70bfc407645185dd9114f9c0ef} Bass64 (50 points) We are provided with another text file, this time containing what appears to be a garbled mess of lines. However, simply disabling word wrap in Notepad allows us to see that it’s just ASCII word art for the string IGZsYWd7MzVhNWQxM2RhNmEyYWZhMGM2MmJmY2JkZDYzMDFhMGF9. Because it’s a relatively short string and I don’t know of anything that can convert from ASCII art back to text, we just manually parse and copy the text. 1 2 3 4 5 6 ___ ____ _____ __ ____ __ _ _____ __ __ __ ___ _ _ __ _____ __ __ ____ ____ _ _ _ _____ __ ____ ________ __ __ ____ __ __ ____ __ __ _ __ ______ _ _ ____ _______ __ __ __ ____ _____ _ __ __ ____ _____ ___ |_ _/ ___|__ /__\ \ / /\ \ / /_| |___ | \/ |___\ \ / / |__ | \ | |\ \ / / _ \ __ _| \/ |___ \| _ \| |__ | \ | |_ __ ___ | ____| _ \ \ / /\ \ / /__ / |__ | \/ |/ ___| \/ |___ \| \/ |_ __ ___ | | _ __ __\ \ / /___ \ | | | __|__ /| _ \ \ / /__| \/ | _ \| ___| |__ | \/ |/ ___| ___/ _ \ | | | _ / // __\ V / \ \ /\ / / _` | / /| |\/| |_ /\ \ / /| &#39;_ \| \| | \ \ /\ / / | | |\ \/ / |\/| | __) | |_) | &#39;_ \| \| | &#39;_ ` _ \| _|| | | | \ V / \ \ /\ / / / /| &#39;_ \| |\/| | | _| |\/| | __) | |\/| | &#39;_ ` _ \ _ | || &#39;_ ` _ \ V / __) | | | |/ / / / | | | \ V /_ / |\/| | | | | |_ | &#39;_ \ | |\/| | | _| |_ | (_) | | | |_| |/ /_\__ \| | \ V V / (_| | / / | | | |/ / \ V / | | | | |\ | \ V V /| |_| | &gt; &lt;| | | |/ __/| _ &lt;| | | | |\ | | | | | | |__| |_| | | | \ V V / / /_| | | | | | | |_| | | | |/ __/| | | | | | | | | |_| || | | | | | | / __/ |_| | &lt; / /_ | |_| || | / /| | | | |_| | _| | | | || | | | |_| | _| \__, | |___\____/____|___/|_| \_/\_/ \__,_|/_/ |_| |_/___| \_/ |_| |_|_| \_| \_/\_/ \__\_\/_/\_\_| |_|_____|_| \_\_| |_|_| \_|_| |_| |_|_____\__, | |_| \_/\_/ /____|_| |_|_| |_|\____|_| |_|_____|_| |_|_| |_| |_|\___/ |_| |_| |_|_| |_____\___/|_|\_\/____ |____/ |_|/___|_| |_|____/|_| |_| |_||_| |_|\____|_| /_/ |___/ Based on both the challenge name and the format of the string, we can assume that this is a Base64-encoded string. Putting this into CyberChef gives us the flag: flag{35a5d13da6a2afa0c62bfcbdd6301a0a} Pimple (50 points) This one is pretty simple. Using file on attachment shows that it’s a GIMP file. Then after opening the file in GIMP and looking through the content, we find the flag printed on one of the inner layers: flag{9a64bc4a390cb0ce31452820ee562c3f} 1 2 $ file pimple pimple: GIMP XCF image data, version 011, 1024 x 1024, RGB Color Tsunami (50 points) Using file again, we discover that this is a .wav file. 1 2 $ file tsunami tsunami: RIFF (little-endian) data, WAVE audio, Microsoft PCM, 16 bit, stereo 44100 Hz The end of the audio is a series of tones that makes me think it’s spectrogram steganography. After finding a website that let’s us view the spectrogram of an audio file(Academo), we see that those series of tones make up the flag value: flag{f8fbb2c761821d3af23859f721cc140b}. If it’s hard to make out the flag yourself, just remember that all of the letters are lowercase so they can’t be confused with a number. Butter Overflow (50 points) This time we’re provided with three files. An executable file: butter_overflow The source code of the executable: source.c A Makefile we can use to compile the source code ourselves After examining the source code, we discover the following information about the program’s behavior: Line 43 - Creates a buffer array that can store up to 512 bytes Line 51 - Directly saves user input into this buffer, without size checks Lines 48 &amp; 10 - Runs the give_flag() function if there’s a segmentation fault So the solution is simple, if we provide enough input to the program to cause a buffer overflow, it’ll trigger a segmentation fault and give us the flag. Sure enough, sending 600 A’s to the challenge server prints out the flag: flag{72d8784a5da3a8f56d2106c12dbab989} Oddball (103 points) Funnily enough, this warmup challenge ended up being worth more than some of the “real” challenges. Here, we are given an oddball file containing several lines of numbers. 1 2 3 4 5 6 7 8 0000000 067531 020165 067165 067543 062566 062562 020144 064164 0000020 020145 062563 071143 072145 066440 071545 060563 062547 0000040 035440 005051 072516 061155 071145 020163 067151 071040 0000060 067141 062547 030040 033455 020077 066510 066555 020041 0000100 067510 020167 062157 005041 063012 060554 075547 060462 0000120 031065 061462 033062 034143 060467 031546 034461 061062 0000140 031064 031543 063064 031544 033062 034063 061065 005175 0000160 After analyzing the file for a bit, we realize that there are no numbers greater than 7, so the file must be a list of octal numbers. As it turns out, the famous xxd tool has a lesser known uncle called od. But rather than hexdumps, this program creates octal dumps of files in the exact same format as the oddball file. Unfortunately, od doesn’t appear to have a reversal function like xxd does, so we have to make one ourselves. After taking out the first column of numbers, we can use the following python3 script to decode oddball. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from pwn import * oct = &quot;&quot;&quot;067531 020165 067165 067543 062566 062562 020144 064164 020145 062563 071143 072145 066440 071545 060563 062547 035440 005051 072516 061155 071145 020163 067151 071040 067141 062547 030040 033455 020077 066510 066555 020041 067510 020167 062157 005041 063012 060554 075547 060462 031065 061462 033062 034143 060467 031546 034461 061062 031064 031543 063064 031544 033062 034063 061065 005175&quot;&quot;&quot;.split() for num in oct: # Decodes the octal string into its byte form # ^──────────────┐ # Reverses the endianess of the byte so it prints correctly # ^────┐ | # Decodes the byte into a printable string # ^────|─────────|───────┐ # V V V print(p16(int(num, 8)).decode(&#39;utf-8&#39;), end=&#39;&#39;) Running this script provides us with the following output containing the flag: 1 2 3 4 You uncovered the secret message ;) Numbers in range 0-7? Hmmm! How od! flag{2a522c26c87af3192b42c34fd326385b} Web Confidentiality (50 points) This challenge involves a simple command injection vulnerability. We’re provided with a web application that gives us the ability to check the access control settings for any given file on the server. To start, we test it out with a known file, /etc/passwd. These results seem eerily similar to what ls -l does. It appears that the application is simply taking our input and appending it to an ls -l command. So if we wanted to see the files in our current directory, we could provide it with a period (.). Of course, we would normally just run ls -l on its own for the same effect, but the application rejects an empty input. This is the exact output we would expect from an ls -l . command. So our goal now is to output the contents of the flag.txt file within this directory. To verify our command injection capabilities, we can use the ; character to append a second command to this line. By sending a request for ; whoami, we predict that the server will run the command ls -l ; whoami, showing us the current directory and username. Success! This shows us that we have the ability to execute commands on the server. Now we just need to send a ; cat flag.txt request to output the flag, which ends up being: flag{e56abbce7b83d62dac05e59fb1e81c68} Bonus: If we wanted to, we can also see the source code for the application itself. A ; cat main.py request outputs the contents of main.py and shows how the application operates. And exactly how we predicted, the application is simply appending our input to the end of an ls -l command, without any verification or sanitization. Titanic (50 points) This challenge involves leveraging a server-side request forgery (SSRF) to access sensitive, internal information. The website contains two main features that we will use: an admin login page and a URL capturer service. The admin login is fairly normal. Since we obviously don’t have any admin credentials, we cannot make real use of this section right now. However, one thing of note about this page is the unique way it sends login attempts. Normally, logins would be sent as a POST request, with the username and password in the body. But here, the login attempt is made as a GET request, with the username and password in the URL. A username and password of test:test is performed with the URL http://challenge.ctf.games:31971/admin.php?uname=test&amp;psw=test. While this behavior isn’t particularly useful to us right now, it will become very important later on. Moving on to the URL capturer service. This service simply takes the URL we provide, makes a request to that URL on our behalf, and gives back a screenshot of the webpage. This service can allow us to perform an SSRF to disclose sensitive, local information on the server. It’s actually difficult to really call it an SSRF vulnerability because it’s clearly intended behavior. But to first validate that we can use it for SSRF, we will make a request to http://localhost and verify that we receive the same webpage. The request is successful! We receive back the loading circle for the website, showing that it is successfully making a request to http://localhost. As far as how to use it though, the robots.txt file for the website points to the /server-status page as an option. When we make a request to that page ourselves, it gives back a 403 Forbidden error. However, if we ask the server to request it locally at http://localhost/server-status, we get back the full status page for this webserver. Remember how login attempts are made as a GET request? Because of that, now we can clearly see a username and password for a previously successful login attempt: root:EYNDR4NhadwX9rtef. Using these credentials, we can access the admin page and retrieve the flag: flag{88269d5ef52a5ee961ea6449e1b610a9}. Cryptography N1TP (50 Points) This challenge is deceptively simple. When we first connect to the server, “Nina” provides us with the ciphertext of the flag. We should also note that the ciphertext changes between connections. After this, they give us the option to provide our own plaintext to see the resulting ciphertext. While providing the ciphertext, Nina also confirms that we’re dealing with a one-time pad (OTP). Nina is correct in saying that OTPs are unbreakable. However, this is with the giant caveat that the OTP is used correctly. If you were to ever reuse a OTP’s key, like what Nina is doing here, it gives an attacker an opportunity to break the encryption. Even worse, if you reuse the key on plaintext that the attacker already knows, that OTP is completely broken. The reason for this is that a OTP uses the exclusive OR (XOR) operation to perform its encryption and decryption. Normal use of an XOR (\(\oplus\)) cipher goes like this: [\textbf{Encryption: } \text{Plaintext} \oplus \text{Key} = \text{Ciphertext}] [\textbf{Decryption: } \text{Ciphertext} \oplus \text{Key} = \text{Plaintext}] However, we if know the plaintext and ciphertext of a message, we can also compute the key using the properties of the XOR operation. [\text{Plaintext} \oplus \text{Ciphertext} = \text{Key}] So using this principle, we can perform a known-plaintext attack on Nina’s OTP to derive the key. Our first step is to encrypt a plaintext value the same length of the flag. For this, we will choose 00000000000000000000000000000000000000. After receiving back the ciphertext for this message, we can XOR the plaintext and ciphertext together to determine the OTP key using CyberChef. Finally, we can XOR the flag’s ciphertext and the key together to reveal the flag in plaintext: flag{9276cdb76a3dd6b1f523209cd9c0a11b}. Miscellanious Bad Words (50 points) This challenge generously gives us a bash shell on the server at the jump. The catch is that we’re placed into an extremely restrictive jailshell. If we attempt to use many of our common commands, such as ls, id, and whoami, the shell yells at us for using a “bad word”. Thankfully after testing several options, we finally have success with the command /bin/sh -i. This breaks us out of the jailshell and drops us into a non-restricted sh shell. A few ls commands reveals the path to the flag file in ~/just/out/of/reach/flag.txt, which we can cat to retrieve the flag: flag{2d43e30a358d3f30fe65cc47a9cbbe98}. If you want to know how the jailshell works, its code is contained within the .bashrc file. It defines a bad_words() function that compares each argument in a user’s commands against a list of “bad words”. Then using the trap &#39;bad_words&#39; DEBUG command, it forces this function to run before any command is executed by the user. If one of the arguments matches one of the bad words, it stops the user’s command from running. However, we are able to get past it because it only checks for bad words starting from the beginning of the argument. This is because of the regex they’re using for matching (^$i.*). The ^ character anchors the match to only from the beginning of the string. So although sh is a bad word, /bin/sh goes undetected because the preceding /bin/ breaks the match. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 shopt -s extdebug function bad_words() { declare -a arr=(&quot;alert&quot; &quot;egrep&quot; &quot;fgrep&quot; &quot;grep&quot; &quot;l&quot; &quot;la&quot; &quot;ll&quot; &quot;ls&quot; [...snip...] &quot;less&quot; &quot;lessecho&quot; &quot;flag&quot; &quot;root&quot;) for i in &quot;${arr[@]}&quot; do if [[ &quot;$BASH_COMMAND&quot; =~ ^$i.* ]]; then echo &quot;You said a bad word, \&quot;$i\&quot;!!&quot; return 1; fi; done return; } trap &#39;bad_words&#39; DEBUG OSINT Jed Sheeran (50 points) This challenge asks us to look for an aspiring music artist named Jed Sheeran. The actual discovery process is simple because a Google search for “Jed Sheeran” puts his SoundCloud as the first result. Jed’s profile has one song that contains a mess of beeps and squeaks. This sound is actually a Slow-Scan Television (SSTV) signal, a method to transmit images as an analog signal. SSTV is popular within the amateur radio community particularly because it’s a way to send and receive images using very little bandwidth. It’s also common to see this in augmented reality games (ARG) or easter eggs as a way to hide pictures, like here in Portal 2. So to retrieve the flag from this audio file, all we need to do is decode the SSTV signal it’s playing. One way to do it is to download an SSTV decoder app like Robot36 and hold your phone’s microphone up to your computer speakers. But you need to keep in mind that SSTV is an analog signal. So any noise in the signal will cause us to receive a degraded image. The more noise, the worse the image looks. However, we could use a something called a virtual audio cable, such as VB-CABLE, to connect our browser’s audio directly to an SSTV decoder program, like RX-SSTV. This will theoretically send the SSTV signal directly from SoundCloud to our decoder without any noise. Well… the flag is clearly there, but it’s extremely hard to decipher. A lot of things could be happening here. SoundCloud could be compressing the SSTV audio before it’s stored, causing additional distortion in our image. It could also be that the flag’s text is too small for this SSTV mode. SSTV isn’t exactly known for sending extremely clear images, even in a perfect world. So people normally use bigger text in an image to compensate for that or switch to a more “robust” SSTV mode. The Jed Sheeran signal appears to be using the Robot 36 mode and is about 36 seconds long. Compare this to the following SSTV image I picked up from the International Space Station that uses PD120 and is about 120 seconds long. It has text about the same size as the Jed Sheeran signal, but this time it’s actually intelligible. Keep in mind that I received this signal from space, as well. So where do we go from here? We could try really hard to determine what each character is. But, it seems that the challenge creator recognized how hard this was and decided to just put the flag in the song’s description: flag{59e56590445321ccefb4d91bba61f16c}. Scripting Words Church (407 points) It appears that people either don’t like scripting or just don’t know how to script because these challenges ended up being worth a lot of points. The description tells us we’ll have to solve 30 word searches, so let’s connect to the server and see what we’re dealing with. It looks fairly simple. We’re provided with a \(15 \times 15\) grid of characters and five words to find. The biggest challenge is really going to be how to parse everything. pwntools makes the sending and receiving part of the challenge easy, so all we have to worry about is how to process the information. The following python3 script let’s use receive the grid used for the game: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from pwn import * io = remote(&#39;challenge.ctf.games&#39;, 32497) io.recvuntil(&#39;&gt;&#39;) io.send(&#39;play&#39;) # Header lines io.recvlines(3) # Grid lines io.recvlines(16) # Trailing lines io.recvlines(2) After putting this into the python3 interpreter, we verify that we’re correctly aligned to process the grid. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 Python 3.9.2 (default, Feb 28 2021, 17:03:44) [GCC 10.2.1 20210110] on linux Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information. &gt;&gt;&gt; from pwn import * &gt;&gt;&gt; io = remote(&#39;challenge.ctf.games&#39;, 32497) (&#39;&gt;&#39;) io.send(&#39;play&#39;)[x] Opening connection to challenge.ctf.games on port 32497 [x] Opening connection to challenge.ctf.games on port 32497: Trying 34.122.187.139 [+] Opening connection to challenge.ctf.games on port 32497: Done &gt;&gt;&gt; io.recvuntil(&#39;&gt;&#39;) b&quot;Words Church v1.0\n\n Let&#39;s play a game of wordsearch! We will display the grid\n and offer you words to find. Please submit the locations of\n each word in the format [(X,Y), (X,Y), (X,Y), ...] for each letter.\n\n Please enter &#39;example&#39; if you would like to see an \n example, or &#39;play&#39; if you would like to get started.\n &gt;&quot; &gt;&gt;&gt; io.send(&#39;play&#39;) &gt;&gt;&gt; &gt;&gt;&gt; # Headers &gt;&gt;&gt; io.recvlines(3) [b&#39; Wordsearch # 1/30:&#39;, b&#39;\t 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 : X&#39;, b&#39;\t--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---&#39;] &gt;&gt;&gt; &gt;&gt;&gt; # Grid lines &gt;&gt;&gt; io.recvlines(16) [b&#39; 0 | \t L P U C E U N K F C A Q T Q S H &#39;, b&#39; 1 | \t Q L Q Q K E S P U V A W X T M E &#39;, b&#39; 2 | \t E G O U H O U A Q D S K Z M T Y &#39;, b&#39; 3 | \t L Z S I F O S U J S S E N A O V &#39;, b&#39; 4 | \t I S M V D Y B B U G U O N J D J &#39;, b&#39; 5 | \t S J Q E T N L A V K R K Z W S I &#39;, b&#39; 6 | \t C P C R Y S E L K D E P S X A L &#39;, b&#39; 7 | \t Q Q T E W F Z L I M D E U S C O &#39;, b&#39; 8 | \t T G L D N N T Y J K I S Y L S B &#39;, b&#39; 9 | \t N E Q J I I X H S K B L K O H S &#39;, b&#39; 10 | \t V K M I U V U O K S K T Y E I T &#39;, b&#39; 11 | \t I M N F G V S O Z O S H R T T E &#39;, b&#39; 12 | \t H F Y K F S Q S Z J I I Z T J R &#39;, b&#39; 13 | \t H U X E T R Y N R Z J M Z S U S &#39;, b&#39; 14 | \t F R B D P Z K P K U N G A Q Y O &#39;, b&#39; 15 | \t M S O T B F R P F R R P M M Z T &#39;] &gt;&gt;&gt; &gt;&gt;&gt; # Trailing lines &gt;&gt;&gt; io.recvlines(2) [b&#39; ---&#39;, b&#39; Y &#39;] Translating the grid into a 2D-array is fairly trivial. All we have to do is split each line on whitespace to get a list of all characters, and then skip the first two characters that contain the Y coordinate and | separator. The following code does this for us: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 # Process grid lines for _ in range(16): # Decode the input from a bytestring into a normal string # ^─────────────────────────┐ # Split the string on whitespace, returning a list of each # ^ character in the string # └─────────────────────────│───────────────┐ # Skip the first two characters in the new list # ^─────────────────────────│───────────────│──────┐ grid.append( io.recvline().decode(&#39;utf-8&#39;).split()[2:] ) # Test grid print(grid) # Output &quot;&quot;&quot; [[&#39;L&#39;, &#39;P&#39;, &#39;U&#39;, &#39;C&#39;, &#39;E&#39;, &#39;U&#39;, &#39;N&#39;, &#39;K&#39;, &#39;F&#39;, &#39;C&#39;, &#39;A&#39;, &#39;Q&#39;, &#39;T&#39;, &#39;Q&#39;, &#39;S&#39;, &#39;H&#39;], [&#39;Q&#39;, &#39;L&#39;, &#39;Q&#39;, &#39;Q&#39;, &#39;K&#39;, &#39;E&#39;, &#39;S&#39;, &#39;P&#39;, &#39;U&#39;, &#39;V&#39;, &#39;A&#39;, &#39;W&#39;, &#39;X&#39;, &#39;T&#39;, &#39;M&#39;, &#39;E&#39;], [&#39;E&#39;, &#39;G&#39;, &#39;O&#39;, &#39;U&#39;, &#39;H&#39;, &#39;O&#39;, &#39;U&#39;, &#39;A&#39;, &#39;Q&#39;, &#39;D&#39;, &#39;S&#39;, &#39;K&#39;, &#39;Z&#39;, &#39;M&#39;, &#39;T&#39;, &#39;Y&#39;], [&#39;L&#39;, &#39;Z&#39;, &#39;S&#39;, &#39;I&#39;, &#39;F&#39;, &#39;O&#39;, &#39;S&#39;, &#39;U&#39;, &#39;J&#39;, &#39;S&#39;, &#39;S&#39;, &#39;E&#39;, &#39;N&#39;, &#39;A&#39;, &#39;O&#39;, &#39;V&#39;], [&#39;I&#39;, &#39;S&#39;, &#39;M&#39;, &#39;V&#39;, &#39;D&#39;, &#39;Y&#39;, &#39;B&#39;, &#39;B&#39;, &#39;U&#39;, &#39;G&#39;, &#39;U&#39;, &#39;O&#39;, &#39;N&#39;, &#39;J&#39;, &#39;D&#39;, &#39;J&#39;], [&#39;S&#39;, &#39;J&#39;, &#39;Q&#39;, &#39;E&#39;, &#39;T&#39;, &#39;N&#39;, &#39;L&#39;, &#39;A&#39;, &#39;V&#39;, &#39;K&#39;, &#39;R&#39;, &#39;K&#39;, &#39;Z&#39;, &#39;W&#39;, &#39;S&#39;, &#39;I&#39;], [&#39;C&#39;, &#39;P&#39;, &#39;C&#39;, &#39;R&#39;, &#39;Y&#39;, &#39;S&#39;, &#39;E&#39;, &#39;L&#39;, &#39;K&#39;, &#39;D&#39;, &#39;E&#39;, &#39;P&#39;, &#39;S&#39;, &#39;X&#39;, &#39;A&#39;, &#39;L&#39;], [&#39;Q&#39;, &#39;Q&#39;, &#39;T&#39;, &#39;E&#39;, &#39;W&#39;, &#39;F&#39;, &#39;Z&#39;, &#39;L&#39;, &#39;I&#39;, &#39;M&#39;, &#39;D&#39;, &#39;E&#39;, &#39;U&#39;, &#39;S&#39;, &#39;C&#39;, &#39;O&#39;], [&#39;T&#39;, &#39;G&#39;, &#39;L&#39;, &#39;D&#39;, &#39;N&#39;, &#39;N&#39;, &#39;T&#39;, &#39;Y&#39;, &#39;J&#39;, &#39;K&#39;, &#39;I&#39;, &#39;S&#39;, &#39;Y&#39;, &#39;L&#39;, &#39;S&#39;, &#39;B&#39;], [&#39;N&#39;, &#39;E&#39;, &#39;Q&#39;, &#39;J&#39;, &#39;I&#39;, &#39;I&#39;, &#39;X&#39;, &#39;H&#39;, &#39;S&#39;, &#39;K&#39;, &#39;B&#39;, &#39;L&#39;, &#39;K&#39;, &#39;O&#39;, &#39;H&#39;, &#39;S&#39;], [&#39;V&#39;, &#39;K&#39;, &#39;M&#39;, &#39;I&#39;, &#39;U&#39;, &#39;V&#39;, &#39;U&#39;, &#39;O&#39;, &#39;K&#39;, &#39;S&#39;, &#39;K&#39;, &#39;T&#39;, &#39;Y&#39;, &#39;E&#39;, &#39;I&#39;, &#39;T&#39;], [&#39;I&#39;, &#39;M&#39;, &#39;N&#39;, &#39;F&#39;, &#39;G&#39;, &#39;V&#39;, &#39;S&#39;, &#39;O&#39;, &#39;Z&#39;, &#39;O&#39;, &#39;S&#39;, &#39;H&#39;, &#39;R&#39;, &#39;T&#39;, &#39;T&#39;, &#39;E&#39;], [&#39;H&#39;, &#39;F&#39;, &#39;Y&#39;, &#39;K&#39;, &#39;F&#39;, &#39;S&#39;, &#39;Q&#39;, &#39;S&#39;, &#39;Z&#39;, &#39;J&#39;, &#39;I&#39;, &#39;I&#39;, &#39;Z&#39;, &#39;T&#39;, &#39;J&#39;, &#39;R&#39;], [&#39;H&#39;, &#39;U&#39;, &#39;X&#39;, &#39;E&#39;, &#39;T&#39;, &#39;R&#39;, &#39;Y&#39;, &#39;N&#39;, &#39;R&#39;, &#39;Z&#39;, &#39;J&#39;, &#39;M&#39;, &#39;Z&#39;, &#39;S&#39;, &#39;U&#39;, &#39;S&#39;], [&#39;F&#39;, &#39;R&#39;, &#39;B&#39;, &#39;D&#39;, &#39;P&#39;, &#39;Z&#39;, &#39;K&#39;, &#39;P&#39;, &#39;K&#39;, &#39;U&#39;, &#39;N&#39;, &#39;G&#39;, &#39;A&#39;, &#39;Q&#39;, &#39;Y&#39;, &#39;O&#39;], [&#39;M&#39;, &#39;S&#39;, &#39;O&#39;, &#39;T&#39;, &#39;B&#39;, &#39;F&#39;, &#39;R&#39;, &#39;P&#39;, &#39;F&#39;, &#39;R&#39;, &#39;R&#39;, &#39;P&#39;, &#39;M&#39;, &#39;M&#39;, &#39;Z&#39;, &#39;T&#39;]] &quot;&quot;&quot; The next step is to determine how to receive the words we need to search for. After we receive the grid lines, the questions are sent to us in the following format: LIEU: &gt; . All we need to do here is extract the word, which is very easy to do using split() again. 1 2 3 4 # Receive input until we hit the &#39;&gt;&#39; character question = io.recvuntil(&#39;&gt;&#39;).decode(&#39;utf-8&#39;) # Split the line on the &#39;:&#39; character and take everything before the &#39;:&#39; word = question.split(&#39;:&#39;)[0].strip() Now that we have our grid and words in a format we can process, it’s time to create the searching functions. While I’m sure there are super fast algorithms specifically designed to solve this problem, we’re going to stick with the naïve solution: go through every coordinate that matches the first letter of the word and search out from all eight directions to see if the rest of it matches. Here we have two components to design, the function to search through the entire grid, and the function to search out from a position to determine if the word matches. I’ve implemented them both in python3, as seen below: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 # Search from a given (x,y) position out a given direction # and return the positions of matching characters. # Returns an empty list `[]` if the match fails. def direction_search(word, grid, x, y, x_delta, y_delta): tiles = [] for c in word: # If this tile doesn&#39;t match the current character, # return an empty list. # The position also wraps around the edges of the grid. if grid[y % len(grid)][x % len(grid)] != c: return [] else: # If we&#39;re still matching, add this position as an # (x, y) tuple to the position list. tiles.append( (x, y) ) # Move in the given direction y += y_delta x += x_delta return tiles # Search each tile in the grid and determine if the word is found # in any 8 directions from each tile. # Returns list of positions if the word is found, empty list `[]`, # if not. def word_search(word, grid): for (y, row) in enumerate(grid): for (x, tile) in enumerate(row): # If this tile matches the first letter of the word, then # check if the rest of the word is found in any of the # 8 directions from this position. if tile == word[0]: for x_delta in [-1, 0, 1]: for y_delta in [-1, 0, 1]: search = direction_search(word, x, y, grid, x_delta, y_delta) if len(search) &gt; 0: return search return [] Finally, we can combine all of these elements in the final script and run it to solve the challenge to receive the flag: flag{ac670e1f34da9eb748b3f241eb03f51b}. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 #!/usr/bin/python3 from pwn import * import sys def direction_search(word, grid, x, y, x_delta, y_delta): tiles = [] for c in word: if grid[y % len(grid)][x % len(grid)] != c: return [] else: tiles.append( (x, y) ) y += y_delta x += x_delta return tiles def word_search(word, grid): for (y, row) in enumerate(grid): for (x, tile) in enumerate(row): if tile == word[0]: for x_delta in [-1, 0, 1]: for y_delta in [-1, 0, 1]: search = direction_search(word, grid, x, y, x_delta, y_delta) if len(search) &gt; 0: return search return [] def main(): # Connect to the challenge server port = int(sys.argv[1]) io = remote(&#39;challenge.ctf.games&#39;, port) # Start a game io.recvuntil(&#39;&gt;&#39;) io.send(&#39;play&#39;) for _ in range(30): # Skip header lines print(io.recvline().decode(&#39;utf-8&#39;).strip()) io.recvlines(2) # Process grid grid = [] for _ in range(16): grid.append( io.recvline().decode(&#39;utf-8&#39;).split()[2:] ) # Skip trailing lines io.recvlines(2) # Answer questions for _ in range(5): question = io.recvuntil(&#39;&gt;&#39;).decode(&#39;utf-8&#39;) word = question.split(&#39;:&#39;)[0].strip() answer = word_search(word, grid) io.sendline( str(answer).encode(&#39;utf-8&#39;) ) # Skip post-game lines io.recvlines(3) # Print the final output print(io.recvrepeat(5).decode(&#39;utf-8&#39;)) if __name__ == &quot;__main__&quot;: main() OTP Smasher (283 points) This is a pretty interesting challenge because it requires us to do some optical character recognition (OCR). We’re presented with a simple webpage displaying a picture of numbers, an submission field, and a counter in the upper-left. Chrome DevTools also shows that the page also attempts to display the image static/flag.png. Based on the challenge’s name, the number picture might be intended to act as a one-time password (OTP). Submitting the OTP increments the upper-left counter by one and waiting too long to submit another OTP resets it to zero. While this challenge was up, the creator eventually decided to increase the length of time allowed until a reset to help make the challenge a bit easier. So right now, we could technically manually submit 45 passwords to get the flag. But of course, that is no fun learning-wise and no fun because it’s super tedious. Using Chrome DevTools, we were able to figure out the format of the submission: a POST request to the main page with the password in a field called otp_entry. Using this information, we are now able to automate OTP submissions. 1 2 3 4 5 6 7 8 import requests from bs4 import BeautifulSoup as bs # Send the current `otp` to the server post = requests.post(f&quot;http://challenge.ctf.games:{port}/&quot;, data={&quot;otp_entry&quot;:otp}) # Print out the current counter value print( bs(post.text, &#39;html.parser&#39;).p ) The remaining problem is how to know what numbers to send? To accomplish this, we will make use of a software called Tesseract and its companion Python module, pytesseract. Combining this with the requests module to download the image and the PIL module to store the image, we can now automate OCR on the images to determine the OTP’s numbers. 1 2 3 4 5 6 7 8 9 10 11 12 13 import requests import pytesseract from PIL import Image from io import BytesIO # Retrieve the current OTP image get = requests.get(f&quot;http://challenge.ctf.games:{port}/static/otp.png&quot;) # Save the image into a PIL Image object image = Image.open(BytesIO(get.content)) # OCR the image to determine the OTP otp = pytesseract.image_to_string(image).strip() This gives us an 80% solution to the challenge. I say 80% because while it works most of the time, it fails enough that we have to manually step in every once in awhile. There’s probably a way to train tesseract to better recognize the OTP numbers, but we won’t dive into that realm for this challenge. For now, we’ll just check if the string from tesseract is a number. If it isn’t, then have the user type in the OTP manually. 1 2 3 4 5 6 # See if we get an error when converting the OTP to a number try: int(otp) except: # If the OTP isn&#39;t a number, make the user type it in manually otp = input(&quot;&gt;&quot;) Now that all of our components are created, we can combine them into the final script that’ll automatically send the OTPs to the server until it sees the flag: flag{f994cd9c756675b743b10c44b32e36b6}. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 import requests import pytesseract import sys from PIL import Image from io import BytesIO from bs4 import BeautifulSoup as bs port = int(sys.argv[1]) while True: # Retrieve the current OTP image get = requests.get(f&quot;http://challenge.ctf.games:{port}/static/otp.png&quot;) # Save the image into a PIL Image object image = Image.open(BytesIO(get.content)) # OCR the image to determine the OTP otp = pytesseract.image_to_string(image).strip() print(f&quot;OTP - {otp}&quot;) # See if we get an error when converting the OTP to a number try: int(otp) except: # If the OTP isn&#39;t a number, make the user type it in manually otp = input(&quot;&gt;&quot;) # Send the current `otp` to the server post = requests.post(f&quot;http://challenge.ctf.games:{port}/&quot;, data={&quot;otp_entry&quot;:otp}) # Print out the current counter value print( bs(post.text, &#39;html.parser&#39;).p ) # Check if the flag image is available yet flag = requests.get(f&quot;http://challenge.ctf.games:{port}/static/flag.png&quot;) if flag.status_code != 404: # If we find the flag, save it and end the script print(&quot;Flag found&quot;) with open(&quot;flag.png&quot;, &quot;wb&quot;) as f: f.write(flag.content) exit()" />
<link rel="canonical" href="https://bernardsmith0892.github.io/posts/Hacktivity2021/" />
<meta property="og:url" content="https://bernardsmith0892.github.io/posts/Hacktivity2021/" />
<meta property="og:site_name" content="Bernard Smith" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-09-19T00:18:01-10:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="H@CktivityCon 2021 CTF Writeups" />
<meta name="twitter:site" content="@BernardSmith892" />
<meta name="google-site-verification" content="google_meta_tag_verification" />
<script type="application/ld+json">
{"description":"Warmups Six Four Over Two (50 points) We are provided with a short text file containing the string: EBTGYYLHPNQTINLEGRSTOMDCMZRTIMBXGY2DKMJYGVSGIOJRGE2GMOLDGBSWM7IK. Based on the name of the challenge, this could potentially be a Base32-encoded string. (Because \\(\\frac{64}{2} = 32\\)) We test our theory using CyberChef and immediately get the flag: flag{a45d4e70bfc407645185dd9114f9c0ef} Bass64 (50 points) We are provided with another text file, this time containing what appears to be a garbled mess of lines. However, simply disabling word wrap in Notepad allows us to see that it’s just ASCII word art for the string IGZsYWd7MzVhNWQxM2RhNmEyYWZhMGM2MmJmY2JkZDYzMDFhMGF9. Because it’s a relatively short string and I don’t know of anything that can convert from ASCII art back to text, we just manually parse and copy the text. 1 2 3 4 5 6 ___ ____ _____ __ ____ __ _ _____ __ __ __ ___ _ _ __ _____ __ __ ____ ____ _ _ _ _____ __ ____ ________ __ __ ____ __ __ ____ __ __ _ __ ______ _ _ ____ _______ __ __ __ ____ _____ _ __ __ ____ _____ ___ |_ _/ ___|__ /__\\ \\ / /\\ \\ / /_| |___ | \\/ |___\\ \\ / / |__ | \\ | |\\ \\ / / _ \\ __ _| \\/ |___ \\| _ \\| |__ | \\ | |_ __ ___ | ____| _ \\ \\ / /\\ \\ / /__ / |__ | \\/ |/ ___| \\/ |___ \\| \\/ |_ __ ___ | | _ __ __\\ \\ / /___ \\ | | | __|__ /| _ \\ \\ / /__| \\/ | _ \\| ___| |__ | \\/ |/ ___| ___/ _ \\ | | | _ / // __\\ V / \\ \\ /\\ / / _` | / /| |\\/| |_ /\\ \\ / /| &#39;_ \\| \\| | \\ \\ /\\ / / | | |\\ \\/ / |\\/| | __) | |_) | &#39;_ \\| \\| | &#39;_ ` _ \\| _|| | | | \\ V / \\ \\ /\\ / / / /| &#39;_ \\| |\\/| | | _| |\\/| | __) | |\\/| | &#39;_ ` _ \\ _ | || &#39;_ ` _ \\ V / __) | | | |/ / / / | | | \\ V /_ / |\\/| | | | | |_ | &#39;_ \\ | |\\/| | | _| |_ | (_) | | | |_| |/ /_\\__ \\| | \\ V V / (_| | / / | | | |/ / \\ V / | | | | |\\ | \\ V V /| |_| | &gt; &lt;| | | |/ __/| _ &lt;| | | | |\\ | | | | | | |__| |_| | | | \\ V V / / /_| | | | | | | |_| | | | |/ __/| | | | | | | | | |_| || | | | | | | / __/ |_| | &lt; / /_ | |_| || | / /| | | | |_| | _| | | | || | | | |_| | _| \\__, | |___\\____/____|___/|_| \\_/\\_/ \\__,_|/_/ |_| |_/___| \\_/ |_| |_|_| \\_| \\_/\\_/ \\__\\_\\/_/\\_\\_| |_|_____|_| \\_\\_| |_|_| \\_|_| |_| |_|_____\\__, | |_| \\_/\\_/ /____|_| |_|_| |_|\\____|_| |_|_____|_| |_|_| |_| |_|\\___/ |_| |_| |_|_| |_____\\___/|_|\\_\\/____ |____/ |_|/___|_| |_|____/|_| |_| |_||_| |_|\\____|_| /_/ |___/ Based on both the challenge name and the format of the string, we can assume that this is a Base64-encoded string. Putting this into CyberChef gives us the flag: flag{35a5d13da6a2afa0c62bfcbdd6301a0a} Pimple (50 points) This one is pretty simple. Using file on attachment shows that it’s a GIMP file. Then after opening the file in GIMP and looking through the content, we find the flag printed on one of the inner layers: flag{9a64bc4a390cb0ce31452820ee562c3f} 1 2 $ file pimple pimple: GIMP XCF image data, version 011, 1024 x 1024, RGB Color Tsunami (50 points) Using file again, we discover that this is a .wav file. 1 2 $ file tsunami tsunami: RIFF (little-endian) data, WAVE audio, Microsoft PCM, 16 bit, stereo 44100 Hz The end of the audio is a series of tones that makes me think it’s spectrogram steganography. After finding a website that let’s us view the spectrogram of an audio file(Academo), we see that those series of tones make up the flag value: flag{f8fbb2c761821d3af23859f721cc140b}. If it’s hard to make out the flag yourself, just remember that all of the letters are lowercase so they can’t be confused with a number. Butter Overflow (50 points) This time we’re provided with three files. An executable file: butter_overflow The source code of the executable: source.c A Makefile we can use to compile the source code ourselves After examining the source code, we discover the following information about the program’s behavior: Line 43 - Creates a buffer array that can store up to 512 bytes Line 51 - Directly saves user input into this buffer, without size checks Lines 48 &amp; 10 - Runs the give_flag() function if there’s a segmentation fault So the solution is simple, if we provide enough input to the program to cause a buffer overflow, it’ll trigger a segmentation fault and give us the flag. Sure enough, sending 600 A’s to the challenge server prints out the flag: flag{72d8784a5da3a8f56d2106c12dbab989} Oddball (103 points) Funnily enough, this warmup challenge ended up being worth more than some of the “real” challenges. Here, we are given an oddball file containing several lines of numbers. 1 2 3 4 5 6 7 8 0000000 067531 020165 067165 067543 062566 062562 020144 064164 0000020 020145 062563 071143 072145 066440 071545 060563 062547 0000040 035440 005051 072516 061155 071145 020163 067151 071040 0000060 067141 062547 030040 033455 020077 066510 066555 020041 0000100 067510 020167 062157 005041 063012 060554 075547 060462 0000120 031065 061462 033062 034143 060467 031546 034461 061062 0000140 031064 031543 063064 031544 033062 034063 061065 005175 0000160 After analyzing the file for a bit, we realize that there are no numbers greater than 7, so the file must be a list of octal numbers. As it turns out, the famous xxd tool has a lesser known uncle called od. But rather than hexdumps, this program creates octal dumps of files in the exact same format as the oddball file. Unfortunately, od doesn’t appear to have a reversal function like xxd does, so we have to make one ourselves. After taking out the first column of numbers, we can use the following python3 script to decode oddball. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from pwn import * oct = &quot;&quot;&quot;067531 020165 067165 067543 062566 062562 020144 064164 020145 062563 071143 072145 066440 071545 060563 062547 035440 005051 072516 061155 071145 020163 067151 071040 067141 062547 030040 033455 020077 066510 066555 020041 067510 020167 062157 005041 063012 060554 075547 060462 031065 061462 033062 034143 060467 031546 034461 061062 031064 031543 063064 031544 033062 034063 061065 005175&quot;&quot;&quot;.split() for num in oct: # Decodes the octal string into its byte form # ^──────────────┐ # Reverses the endianess of the byte so it prints correctly # ^────┐ | # Decodes the byte into a printable string # ^────|─────────|───────┐ # V V V print(p16(int(num, 8)).decode(&#39;utf-8&#39;), end=&#39;&#39;) Running this script provides us with the following output containing the flag: 1 2 3 4 You uncovered the secret message ;) Numbers in range 0-7? Hmmm! How od! flag{2a522c26c87af3192b42c34fd326385b} Web Confidentiality (50 points) This challenge involves a simple command injection vulnerability. We’re provided with a web application that gives us the ability to check the access control settings for any given file on the server. To start, we test it out with a known file, /etc/passwd. These results seem eerily similar to what ls -l does. It appears that the application is simply taking our input and appending it to an ls -l command. So if we wanted to see the files in our current directory, we could provide it with a period (.). Of course, we would normally just run ls -l on its own for the same effect, but the application rejects an empty input. This is the exact output we would expect from an ls -l . command. So our goal now is to output the contents of the flag.txt file within this directory. To verify our command injection capabilities, we can use the ; character to append a second command to this line. By sending a request for ; whoami, we predict that the server will run the command ls -l ; whoami, showing us the current directory and username. Success! This shows us that we have the ability to execute commands on the server. Now we just need to send a ; cat flag.txt request to output the flag, which ends up being: flag{e56abbce7b83d62dac05e59fb1e81c68} Bonus: If we wanted to, we can also see the source code for the application itself. A ; cat main.py request outputs the contents of main.py and shows how the application operates. And exactly how we predicted, the application is simply appending our input to the end of an ls -l command, without any verification or sanitization. Titanic (50 points) This challenge involves leveraging a server-side request forgery (SSRF) to access sensitive, internal information. The website contains two main features that we will use: an admin login page and a URL capturer service. The admin login is fairly normal. Since we obviously don’t have any admin credentials, we cannot make real use of this section right now. However, one thing of note about this page is the unique way it sends login attempts. Normally, logins would be sent as a POST request, with the username and password in the body. But here, the login attempt is made as a GET request, with the username and password in the URL. A username and password of test:test is performed with the URL http://challenge.ctf.games:31971/admin.php?uname=test&amp;psw=test. While this behavior isn’t particularly useful to us right now, it will become very important later on. Moving on to the URL capturer service. This service simply takes the URL we provide, makes a request to that URL on our behalf, and gives back a screenshot of the webpage. This service can allow us to perform an SSRF to disclose sensitive, local information on the server. It’s actually difficult to really call it an SSRF vulnerability because it’s clearly intended behavior. But to first validate that we can use it for SSRF, we will make a request to http://localhost and verify that we receive the same webpage. The request is successful! We receive back the loading circle for the website, showing that it is successfully making a request to http://localhost. As far as how to use it though, the robots.txt file for the website points to the /server-status page as an option. When we make a request to that page ourselves, it gives back a 403 Forbidden error. However, if we ask the server to request it locally at http://localhost/server-status, we get back the full status page for this webserver. Remember how login attempts are made as a GET request? Because of that, now we can clearly see a username and password for a previously successful login attempt: root:EYNDR4NhadwX9rtef. Using these credentials, we can access the admin page and retrieve the flag: flag{88269d5ef52a5ee961ea6449e1b610a9}. Cryptography N1TP (50 Points) This challenge is deceptively simple. When we first connect to the server, “Nina” provides us with the ciphertext of the flag. We should also note that the ciphertext changes between connections. After this, they give us the option to provide our own plaintext to see the resulting ciphertext. While providing the ciphertext, Nina also confirms that we’re dealing with a one-time pad (OTP). Nina is correct in saying that OTPs are unbreakable. However, this is with the giant caveat that the OTP is used correctly. If you were to ever reuse a OTP’s key, like what Nina is doing here, it gives an attacker an opportunity to break the encryption. Even worse, if you reuse the key on plaintext that the attacker already knows, that OTP is completely broken. The reason for this is that a OTP uses the exclusive OR (XOR) operation to perform its encryption and decryption. Normal use of an XOR (\\(\\oplus\\)) cipher goes like this: [\\textbf{Encryption: } \\text{Plaintext} \\oplus \\text{Key} = \\text{Ciphertext}] [\\textbf{Decryption: } \\text{Ciphertext} \\oplus \\text{Key} = \\text{Plaintext}] However, we if know the plaintext and ciphertext of a message, we can also compute the key using the properties of the XOR operation. [\\text{Plaintext} \\oplus \\text{Ciphertext} = \\text{Key}] So using this principle, we can perform a known-plaintext attack on Nina’s OTP to derive the key. Our first step is to encrypt a plaintext value the same length of the flag. For this, we will choose 00000000000000000000000000000000000000. After receiving back the ciphertext for this message, we can XOR the plaintext and ciphertext together to determine the OTP key using CyberChef. Finally, we can XOR the flag’s ciphertext and the key together to reveal the flag in plaintext: flag{9276cdb76a3dd6b1f523209cd9c0a11b}. Miscellanious Bad Words (50 points) This challenge generously gives us a bash shell on the server at the jump. The catch is that we’re placed into an extremely restrictive jailshell. If we attempt to use many of our common commands, such as ls, id, and whoami, the shell yells at us for using a “bad word”. Thankfully after testing several options, we finally have success with the command /bin/sh -i. This breaks us out of the jailshell and drops us into a non-restricted sh shell. A few ls commands reveals the path to the flag file in ~/just/out/of/reach/flag.txt, which we can cat to retrieve the flag: flag{2d43e30a358d3f30fe65cc47a9cbbe98}. If you want to know how the jailshell works, its code is contained within the .bashrc file. It defines a bad_words() function that compares each argument in a user’s commands against a list of “bad words”. Then using the trap &#39;bad_words&#39; DEBUG command, it forces this function to run before any command is executed by the user. If one of the arguments matches one of the bad words, it stops the user’s command from running. However, we are able to get past it because it only checks for bad words starting from the beginning of the argument. This is because of the regex they’re using for matching (^$i.*). The ^ character anchors the match to only from the beginning of the string. So although sh is a bad word, /bin/sh goes undetected because the preceding /bin/ breaks the match. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 shopt -s extdebug function bad_words() { declare -a arr=(&quot;alert&quot; &quot;egrep&quot; &quot;fgrep&quot; &quot;grep&quot; &quot;l&quot; &quot;la&quot; &quot;ll&quot; &quot;ls&quot; [...snip...] &quot;less&quot; &quot;lessecho&quot; &quot;flag&quot; &quot;root&quot;) for i in &quot;${arr[@]}&quot; do if [[ &quot;$BASH_COMMAND&quot; =~ ^$i.* ]]; then echo &quot;You said a bad word, \\&quot;$i\\&quot;!!&quot; return 1; fi; done return; } trap &#39;bad_words&#39; DEBUG OSINT Jed Sheeran (50 points) This challenge asks us to look for an aspiring music artist named Jed Sheeran. The actual discovery process is simple because a Google search for “Jed Sheeran” puts his SoundCloud as the first result. Jed’s profile has one song that contains a mess of beeps and squeaks. This sound is actually a Slow-Scan Television (SSTV) signal, a method to transmit images as an analog signal. SSTV is popular within the amateur radio community particularly because it’s a way to send and receive images using very little bandwidth. It’s also common to see this in augmented reality games (ARG) or easter eggs as a way to hide pictures, like here in Portal 2. So to retrieve the flag from this audio file, all we need to do is decode the SSTV signal it’s playing. One way to do it is to download an SSTV decoder app like Robot36 and hold your phone’s microphone up to your computer speakers. But you need to keep in mind that SSTV is an analog signal. So any noise in the signal will cause us to receive a degraded image. The more noise, the worse the image looks. However, we could use a something called a virtual audio cable, such as VB-CABLE, to connect our browser’s audio directly to an SSTV decoder program, like RX-SSTV. This will theoretically send the SSTV signal directly from SoundCloud to our decoder without any noise. Well… the flag is clearly there, but it’s extremely hard to decipher. A lot of things could be happening here. SoundCloud could be compressing the SSTV audio before it’s stored, causing additional distortion in our image. It could also be that the flag’s text is too small for this SSTV mode. SSTV isn’t exactly known for sending extremely clear images, even in a perfect world. So people normally use bigger text in an image to compensate for that or switch to a more “robust” SSTV mode. The Jed Sheeran signal appears to be using the Robot 36 mode and is about 36 seconds long. Compare this to the following SSTV image I picked up from the International Space Station that uses PD120 and is about 120 seconds long. It has text about the same size as the Jed Sheeran signal, but this time it’s actually intelligible. Keep in mind that I received this signal from space, as well. So where do we go from here? We could try really hard to determine what each character is. But, it seems that the challenge creator recognized how hard this was and decided to just put the flag in the song’s description: flag{59e56590445321ccefb4d91bba61f16c}. Scripting Words Church (407 points) It appears that people either don’t like scripting or just don’t know how to script because these challenges ended up being worth a lot of points. The description tells us we’ll have to solve 30 word searches, so let’s connect to the server and see what we’re dealing with. It looks fairly simple. We’re provided with a \\(15 \\times 15\\) grid of characters and five words to find. The biggest challenge is really going to be how to parse everything. pwntools makes the sending and receiving part of the challenge easy, so all we have to worry about is how to process the information. The following python3 script let’s use receive the grid used for the game: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from pwn import * io = remote(&#39;challenge.ctf.games&#39;, 32497) io.recvuntil(&#39;&gt;&#39;) io.send(&#39;play&#39;) # Header lines io.recvlines(3) # Grid lines io.recvlines(16) # Trailing lines io.recvlines(2) After putting this into the python3 interpreter, we verify that we’re correctly aligned to process the grid. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 Python 3.9.2 (default, Feb 28 2021, 17:03:44) [GCC 10.2.1 20210110] on linux Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information. &gt;&gt;&gt; from pwn import * &gt;&gt;&gt; io = remote(&#39;challenge.ctf.games&#39;, 32497) (&#39;&gt;&#39;) io.send(&#39;play&#39;)[x] Opening connection to challenge.ctf.games on port 32497 [x] Opening connection to challenge.ctf.games on port 32497: Trying 34.122.187.139 [+] Opening connection to challenge.ctf.games on port 32497: Done &gt;&gt;&gt; io.recvuntil(&#39;&gt;&#39;) b&quot;Words Church v1.0\\n\\n Let&#39;s play a game of wordsearch! We will display the grid\\n and offer you words to find. Please submit the locations of\\n each word in the format [(X,Y), (X,Y), (X,Y), ...] for each letter.\\n\\n Please enter &#39;example&#39; if you would like to see an \\n example, or &#39;play&#39; if you would like to get started.\\n &gt;&quot; &gt;&gt;&gt; io.send(&#39;play&#39;) &gt;&gt;&gt; &gt;&gt;&gt; # Headers &gt;&gt;&gt; io.recvlines(3) [b&#39; Wordsearch # 1/30:&#39;, b&#39;\\t 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 : X&#39;, b&#39;\\t--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---&#39;] &gt;&gt;&gt; &gt;&gt;&gt; # Grid lines &gt;&gt;&gt; io.recvlines(16) [b&#39; 0 | \\t L P U C E U N K F C A Q T Q S H &#39;, b&#39; 1 | \\t Q L Q Q K E S P U V A W X T M E &#39;, b&#39; 2 | \\t E G O U H O U A Q D S K Z M T Y &#39;, b&#39; 3 | \\t L Z S I F O S U J S S E N A O V &#39;, b&#39; 4 | \\t I S M V D Y B B U G U O N J D J &#39;, b&#39; 5 | \\t S J Q E T N L A V K R K Z W S I &#39;, b&#39; 6 | \\t C P C R Y S E L K D E P S X A L &#39;, b&#39; 7 | \\t Q Q T E W F Z L I M D E U S C O &#39;, b&#39; 8 | \\t T G L D N N T Y J K I S Y L S B &#39;, b&#39; 9 | \\t N E Q J I I X H S K B L K O H S &#39;, b&#39; 10 | \\t V K M I U V U O K S K T Y E I T &#39;, b&#39; 11 | \\t I M N F G V S O Z O S H R T T E &#39;, b&#39; 12 | \\t H F Y K F S Q S Z J I I Z T J R &#39;, b&#39; 13 | \\t H U X E T R Y N R Z J M Z S U S &#39;, b&#39; 14 | \\t F R B D P Z K P K U N G A Q Y O &#39;, b&#39; 15 | \\t M S O T B F R P F R R P M M Z T &#39;] &gt;&gt;&gt; &gt;&gt;&gt; # Trailing lines &gt;&gt;&gt; io.recvlines(2) [b&#39; ---&#39;, b&#39; Y &#39;] Translating the grid into a 2D-array is fairly trivial. All we have to do is split each line on whitespace to get a list of all characters, and then skip the first two characters that contain the Y coordinate and | separator. The following code does this for us: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 # Process grid lines for _ in range(16): # Decode the input from a bytestring into a normal string # ^─────────────────────────┐ # Split the string on whitespace, returning a list of each # ^ character in the string # └─────────────────────────│───────────────┐ # Skip the first two characters in the new list # ^─────────────────────────│───────────────│──────┐ grid.append( io.recvline().decode(&#39;utf-8&#39;).split()[2:] ) # Test grid print(grid) # Output &quot;&quot;&quot; [[&#39;L&#39;, &#39;P&#39;, &#39;U&#39;, &#39;C&#39;, &#39;E&#39;, &#39;U&#39;, &#39;N&#39;, &#39;K&#39;, &#39;F&#39;, &#39;C&#39;, &#39;A&#39;, &#39;Q&#39;, &#39;T&#39;, &#39;Q&#39;, &#39;S&#39;, &#39;H&#39;], [&#39;Q&#39;, &#39;L&#39;, &#39;Q&#39;, &#39;Q&#39;, &#39;K&#39;, &#39;E&#39;, &#39;S&#39;, &#39;P&#39;, &#39;U&#39;, &#39;V&#39;, &#39;A&#39;, &#39;W&#39;, &#39;X&#39;, &#39;T&#39;, &#39;M&#39;, &#39;E&#39;], [&#39;E&#39;, &#39;G&#39;, &#39;O&#39;, &#39;U&#39;, &#39;H&#39;, &#39;O&#39;, &#39;U&#39;, &#39;A&#39;, &#39;Q&#39;, &#39;D&#39;, &#39;S&#39;, &#39;K&#39;, &#39;Z&#39;, &#39;M&#39;, &#39;T&#39;, &#39;Y&#39;], [&#39;L&#39;, &#39;Z&#39;, &#39;S&#39;, &#39;I&#39;, &#39;F&#39;, &#39;O&#39;, &#39;S&#39;, &#39;U&#39;, &#39;J&#39;, &#39;S&#39;, &#39;S&#39;, &#39;E&#39;, &#39;N&#39;, &#39;A&#39;, &#39;O&#39;, &#39;V&#39;], [&#39;I&#39;, &#39;S&#39;, &#39;M&#39;, &#39;V&#39;, &#39;D&#39;, &#39;Y&#39;, &#39;B&#39;, &#39;B&#39;, &#39;U&#39;, &#39;G&#39;, &#39;U&#39;, &#39;O&#39;, &#39;N&#39;, &#39;J&#39;, &#39;D&#39;, &#39;J&#39;], [&#39;S&#39;, &#39;J&#39;, &#39;Q&#39;, &#39;E&#39;, &#39;T&#39;, &#39;N&#39;, &#39;L&#39;, &#39;A&#39;, &#39;V&#39;, &#39;K&#39;, &#39;R&#39;, &#39;K&#39;, &#39;Z&#39;, &#39;W&#39;, &#39;S&#39;, &#39;I&#39;], [&#39;C&#39;, &#39;P&#39;, &#39;C&#39;, &#39;R&#39;, &#39;Y&#39;, &#39;S&#39;, &#39;E&#39;, &#39;L&#39;, &#39;K&#39;, &#39;D&#39;, &#39;E&#39;, &#39;P&#39;, &#39;S&#39;, &#39;X&#39;, &#39;A&#39;, &#39;L&#39;], [&#39;Q&#39;, &#39;Q&#39;, &#39;T&#39;, &#39;E&#39;, &#39;W&#39;, &#39;F&#39;, &#39;Z&#39;, &#39;L&#39;, &#39;I&#39;, &#39;M&#39;, &#39;D&#39;, &#39;E&#39;, &#39;U&#39;, &#39;S&#39;, &#39;C&#39;, &#39;O&#39;], [&#39;T&#39;, &#39;G&#39;, &#39;L&#39;, &#39;D&#39;, &#39;N&#39;, &#39;N&#39;, &#39;T&#39;, &#39;Y&#39;, &#39;J&#39;, &#39;K&#39;, &#39;I&#39;, &#39;S&#39;, &#39;Y&#39;, &#39;L&#39;, &#39;S&#39;, &#39;B&#39;], [&#39;N&#39;, &#39;E&#39;, &#39;Q&#39;, &#39;J&#39;, &#39;I&#39;, &#39;I&#39;, &#39;X&#39;, &#39;H&#39;, &#39;S&#39;, &#39;K&#39;, &#39;B&#39;, &#39;L&#39;, &#39;K&#39;, &#39;O&#39;, &#39;H&#39;, &#39;S&#39;], [&#39;V&#39;, &#39;K&#39;, &#39;M&#39;, &#39;I&#39;, &#39;U&#39;, &#39;V&#39;, &#39;U&#39;, &#39;O&#39;, &#39;K&#39;, &#39;S&#39;, &#39;K&#39;, &#39;T&#39;, &#39;Y&#39;, &#39;E&#39;, &#39;I&#39;, &#39;T&#39;], [&#39;I&#39;, &#39;M&#39;, &#39;N&#39;, &#39;F&#39;, &#39;G&#39;, &#39;V&#39;, &#39;S&#39;, &#39;O&#39;, &#39;Z&#39;, &#39;O&#39;, &#39;S&#39;, &#39;H&#39;, &#39;R&#39;, &#39;T&#39;, &#39;T&#39;, &#39;E&#39;], [&#39;H&#39;, &#39;F&#39;, &#39;Y&#39;, &#39;K&#39;, &#39;F&#39;, &#39;S&#39;, &#39;Q&#39;, &#39;S&#39;, &#39;Z&#39;, &#39;J&#39;, &#39;I&#39;, &#39;I&#39;, &#39;Z&#39;, &#39;T&#39;, &#39;J&#39;, &#39;R&#39;], [&#39;H&#39;, &#39;U&#39;, &#39;X&#39;, &#39;E&#39;, &#39;T&#39;, &#39;R&#39;, &#39;Y&#39;, &#39;N&#39;, &#39;R&#39;, &#39;Z&#39;, &#39;J&#39;, &#39;M&#39;, &#39;Z&#39;, &#39;S&#39;, &#39;U&#39;, &#39;S&#39;], [&#39;F&#39;, &#39;R&#39;, &#39;B&#39;, &#39;D&#39;, &#39;P&#39;, &#39;Z&#39;, &#39;K&#39;, &#39;P&#39;, &#39;K&#39;, &#39;U&#39;, &#39;N&#39;, &#39;G&#39;, &#39;A&#39;, &#39;Q&#39;, &#39;Y&#39;, &#39;O&#39;], [&#39;M&#39;, &#39;S&#39;, &#39;O&#39;, &#39;T&#39;, &#39;B&#39;, &#39;F&#39;, &#39;R&#39;, &#39;P&#39;, &#39;F&#39;, &#39;R&#39;, &#39;R&#39;, &#39;P&#39;, &#39;M&#39;, &#39;M&#39;, &#39;Z&#39;, &#39;T&#39;]] &quot;&quot;&quot; The next step is to determine how to receive the words we need to search for. After we receive the grid lines, the questions are sent to us in the following format: LIEU: &gt; . All we need to do here is extract the word, which is very easy to do using split() again. 1 2 3 4 # Receive input until we hit the &#39;&gt;&#39; character question = io.recvuntil(&#39;&gt;&#39;).decode(&#39;utf-8&#39;) # Split the line on the &#39;:&#39; character and take everything before the &#39;:&#39; word = question.split(&#39;:&#39;)[0].strip() Now that we have our grid and words in a format we can process, it’s time to create the searching functions. While I’m sure there are super fast algorithms specifically designed to solve this problem, we’re going to stick with the naïve solution: go through every coordinate that matches the first letter of the word and search out from all eight directions to see if the rest of it matches. Here we have two components to design, the function to search through the entire grid, and the function to search out from a position to determine if the word matches. I’ve implemented them both in python3, as seen below: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 # Search from a given (x,y) position out a given direction # and return the positions of matching characters. # Returns an empty list `[]` if the match fails. def direction_search(word, grid, x, y, x_delta, y_delta): tiles = [] for c in word: # If this tile doesn&#39;t match the current character, # return an empty list. # The position also wraps around the edges of the grid. if grid[y % len(grid)][x % len(grid)] != c: return [] else: # If we&#39;re still matching, add this position as an # (x, y) tuple to the position list. tiles.append( (x, y) ) # Move in the given direction y += y_delta x += x_delta return tiles # Search each tile in the grid and determine if the word is found # in any 8 directions from each tile. # Returns list of positions if the word is found, empty list `[]`, # if not. def word_search(word, grid): for (y, row) in enumerate(grid): for (x, tile) in enumerate(row): # If this tile matches the first letter of the word, then # check if the rest of the word is found in any of the # 8 directions from this position. if tile == word[0]: for x_delta in [-1, 0, 1]: for y_delta in [-1, 0, 1]: search = direction_search(word, x, y, grid, x_delta, y_delta) if len(search) &gt; 0: return search return [] Finally, we can combine all of these elements in the final script and run it to solve the challenge to receive the flag: flag{ac670e1f34da9eb748b3f241eb03f51b}. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 #!/usr/bin/python3 from pwn import * import sys def direction_search(word, grid, x, y, x_delta, y_delta): tiles = [] for c in word: if grid[y % len(grid)][x % len(grid)] != c: return [] else: tiles.append( (x, y) ) y += y_delta x += x_delta return tiles def word_search(word, grid): for (y, row) in enumerate(grid): for (x, tile) in enumerate(row): if tile == word[0]: for x_delta in [-1, 0, 1]: for y_delta in [-1, 0, 1]: search = direction_search(word, grid, x, y, x_delta, y_delta) if len(search) &gt; 0: return search return [] def main(): # Connect to the challenge server port = int(sys.argv[1]) io = remote(&#39;challenge.ctf.games&#39;, port) # Start a game io.recvuntil(&#39;&gt;&#39;) io.send(&#39;play&#39;) for _ in range(30): # Skip header lines print(io.recvline().decode(&#39;utf-8&#39;).strip()) io.recvlines(2) # Process grid grid = [] for _ in range(16): grid.append( io.recvline().decode(&#39;utf-8&#39;).split()[2:] ) # Skip trailing lines io.recvlines(2) # Answer questions for _ in range(5): question = io.recvuntil(&#39;&gt;&#39;).decode(&#39;utf-8&#39;) word = question.split(&#39;:&#39;)[0].strip() answer = word_search(word, grid) io.sendline( str(answer).encode(&#39;utf-8&#39;) ) # Skip post-game lines io.recvlines(3) # Print the final output print(io.recvrepeat(5).decode(&#39;utf-8&#39;)) if __name__ == &quot;__main__&quot;: main() OTP Smasher (283 points) This is a pretty interesting challenge because it requires us to do some optical character recognition (OCR). We’re presented with a simple webpage displaying a picture of numbers, an submission field, and a counter in the upper-left. Chrome DevTools also shows that the page also attempts to display the image static/flag.png. Based on the challenge’s name, the number picture might be intended to act as a one-time password (OTP). Submitting the OTP increments the upper-left counter by one and waiting too long to submit another OTP resets it to zero. While this challenge was up, the creator eventually decided to increase the length of time allowed until a reset to help make the challenge a bit easier. So right now, we could technically manually submit 45 passwords to get the flag. But of course, that is no fun learning-wise and no fun because it’s super tedious. Using Chrome DevTools, we were able to figure out the format of the submission: a POST request to the main page with the password in a field called otp_entry. Using this information, we are now able to automate OTP submissions. 1 2 3 4 5 6 7 8 import requests from bs4 import BeautifulSoup as bs # Send the current `otp` to the server post = requests.post(f&quot;http://challenge.ctf.games:{port}/&quot;, data={&quot;otp_entry&quot;:otp}) # Print out the current counter value print( bs(post.text, &#39;html.parser&#39;).p ) The remaining problem is how to know what numbers to send? To accomplish this, we will make use of a software called Tesseract and its companion Python module, pytesseract. Combining this with the requests module to download the image and the PIL module to store the image, we can now automate OCR on the images to determine the OTP’s numbers. 1 2 3 4 5 6 7 8 9 10 11 12 13 import requests import pytesseract from PIL import Image from io import BytesIO # Retrieve the current OTP image get = requests.get(f&quot;http://challenge.ctf.games:{port}/static/otp.png&quot;) # Save the image into a PIL Image object image = Image.open(BytesIO(get.content)) # OCR the image to determine the OTP otp = pytesseract.image_to_string(image).strip() This gives us an 80% solution to the challenge. I say 80% because while it works most of the time, it fails enough that we have to manually step in every once in awhile. There’s probably a way to train tesseract to better recognize the OTP numbers, but we won’t dive into that realm for this challenge. For now, we’ll just check if the string from tesseract is a number. If it isn’t, then have the user type in the OTP manually. 1 2 3 4 5 6 # See if we get an error when converting the OTP to a number try: int(otp) except: # If the OTP isn&#39;t a number, make the user type it in manually otp = input(&quot;&gt;&quot;) Now that all of our components are created, we can combine them into the final script that’ll automatically send the OTPs to the server until it sees the flag: flag{f994cd9c756675b743b10c44b32e36b6}. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 import requests import pytesseract import sys from PIL import Image from io import BytesIO from bs4 import BeautifulSoup as bs port = int(sys.argv[1]) while True: # Retrieve the current OTP image get = requests.get(f&quot;http://challenge.ctf.games:{port}/static/otp.png&quot;) # Save the image into a PIL Image object image = Image.open(BytesIO(get.content)) # OCR the image to determine the OTP otp = pytesseract.image_to_string(image).strip() print(f&quot;OTP - {otp}&quot;) # See if we get an error when converting the OTP to a number try: int(otp) except: # If the OTP isn&#39;t a number, make the user type it in manually otp = input(&quot;&gt;&quot;) # Send the current `otp` to the server post = requests.post(f&quot;http://challenge.ctf.games:{port}/&quot;, data={&quot;otp_entry&quot;:otp}) # Print out the current counter value print( bs(post.text, &#39;html.parser&#39;).p ) # Check if the flag image is available yet flag = requests.get(f&quot;http://challenge.ctf.games:{port}/static/flag.png&quot;) if flag.status_code != 404: # If we find the flag, save it and end the script print(&quot;Flag found&quot;) with open(&quot;flag.png&quot;, &quot;wb&quot;) as f: f.write(flag.content) exit()","@type":"BlogPosting","headline":"H@CktivityCon 2021 CTF Writeups","dateModified":"2021-09-19T00:18:01-10:00","datePublished":"2021-09-19T00:18:01-10:00","url":"https://bernardsmith0892.github.io/posts/Hacktivity2021/","mainEntityOfPage":{"@type":"WebPage","@id":"https://bernardsmith0892.github.io/posts/Hacktivity2021/"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->


  <title>H@CktivityCon 2021 CTF Writeups | Bernard Smith
  </title>

  <!--
  The Favicons for Web, Android, Microsoft, and iOS (iPhone and iPad) Apps
  Generated by: https://realfavicongenerator.net/
-->



<link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png">
<link rel="manifest" href="/assets/img/favicons/site.webmanifest">
<link rel="shortcut icon" href="/assets/img/favicons/favicon.ico">
<meta name="apple-mobile-web-app-title" content="Bernard Smith">
<meta name="application-name" content="Bernard Smith">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml">
<meta name="theme-color" content="#ffffff">


  <!-- Google Fonts -->
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous">
  <link rel="dns-prefetch" href="https://fonts.gstatic.com">

  <!-- GA -->
  

  <!-- jsDelivr CDN -->
  <link rel="preconnect" href="https://cdn.jsdelivr.net">
  <link rel="dns-prefetch" href="https://cdn.jsdelivr.net">

  <!-- Bootstrap -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css">

  <!-- Font Awesome -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css">

  <!--
  CSS selector for site.
-->

<link rel="stylesheet" href="/assets/css/style.css">


  <link rel="stylesheet"
    href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css">



  <!-- Manific Popup -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css">



  <!-- JavaScripts -->

  <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>

  <script defer
    src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script>

  <!--
  JS selector for site.
-->


  



  <!-- image lazy-loading & popup -->
  <script async
    src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js"></script>





<script defer src="/assets/js/dist/post.min.js"></script>






</head>


  <body data-spy="scroll" data-target="#toc">

    <!--
  The Side Bar
-->

<div id="sidebar" class="d-flex flex-column align-items-end">

  <div class="profile-wrapper text-center">
    <div id="avatar">
      <a href="/" alt="avatar" class="mx-auto">
        
        <img src="/assets/imgs/avatar.jpg" alt="avatar" onerror="this.style.display='none'">
      </a>
    </div>

    <div class="site-title mt-3">
      <a href="/">Bernard Smith</a>
    </div>

    <div class="site-subtitle font-italic">Security and commo-related posts</div>

  </div><!-- .profile-wrapper -->

  <ul class="w-100">
    <!-- home -->
    <li class="nav-item">
      <a href="/" class="nav-link">
        <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i>
        <span>HOME</span>
      </a>
    </li>
    <!-- the real tabs -->
    
    <li class="nav-item">
      <a href="/categories/" class="nav-link">
        <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i>
        <span>CATEGORIES</span>
      </a>
    </li> <!-- .nav-item -->
    
    <li class="nav-item">
      <a href="/archives/" class="nav-link">
        <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i>
        <span>ARCHIVES</span>
      </a>
    </li> <!-- .nav-item -->
    
    <li class="nav-item">
      <a href="/tags/" class="nav-link">
        <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i>
        <span>TAGS</span>
      </a>
    </li> <!-- .nav-item -->
    
    <li class="nav-item">
      <a href="/about/" class="nav-link">
        <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i>
        <span>ABOUT</span>
      </a>
    </li> <!-- .nav-item -->
    
    <li class="nav-item">
      <a href="/projects/" class="nav-link">
        <i class="fa-fw fas fa-code ml-xl-3 mr-xl-3 unloaded"></i>
        <span>PROJECTS</span>
      </a>
    </li> <!-- .nav-item -->
    

  </ul> <!-- ul.nav.flex-column -->

  <div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center">

    
      

      
      <a href="https://github.com/bernardsmith0892" aria-label="github"
        
        target="_blank" rel="noopener">
        <i class="fab fa-github-alt"></i>
      </a>
      

    
      

      
      <a href="https://twitter.com/BernardSmith892" aria-label="twitter"
        
        target="_blank" rel="noopener">
        <i class="fab fa-twitter"></i>
      </a>
      

    
      

      
      <a href="https://linkedin.com/in/bernard-smith-27324257/" aria-label="linkedin"
        
        target="_blank" rel="noopener">
        <i class="fab fa-linkedin"></i>
      </a>
      

    
      

      
      <a href="
          javascript:location.href = 'mailto:' + ['mail','brndjsmith.net'].join('@')" aria-label="email"
        
        target="_blank" rel="noopener">
        <i class="fas fa-envelope"></i>
      </a>
      

    

    

  </div> <!-- .sidebar-bottom -->

</div><!-- #sidebar -->


    <!--
  The Top Bar
-->

<div id="topbar-wrapper" class="row justify-content-center topbar-down">
  <div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between">
    <span id="breadcrumb">

    

    

      

        
          

        

      

        
        <span>
          
          
          <a href="/">
            Posts
          </a>
        </span>

        

      

        
          <span>H@CktivityCon 2021 CTF Writeups</span>

        

      

    

    </span><!-- endof #breadcrumb -->

    <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i>

    <div id="topbar-title">
      Post
    </div>

    <i id="search-trigger" class="fas fa-search fa-fw"></i>
    <span id="search-wrapper" class="align-items-center">
      <i class="fas fa-search fa-fw"></i>
      <input class="form-control" id="search-input" type="search"
        aria-label="search" autocomplete="off" placeholder="Search...">
      <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i>
    </span>
    <span id="search-cancel" >Cancel</span>
  </div>

</div>


    <div id="main-wrapper">
      <div id="main">

        <!--
  Refactor the HTML structure.
-->



<!--
  In order to allow a wide table to scroll horizontally,
  we suround the markdown table with `<div class="table-wrapper">` and `</div>`
-->


<!--
  Fixed kramdown code highlight rendering:
  https://github.com/penibelst/jekyll-compress-html/issues/101
  https://github.com/penibelst/jekyll-compress-html/issues/71#issuecomment-188144901
-->


<!-- Add attribute 'hide-bullet' to the checkbox list -->




  

  

  <!-- lazy-load images <https://github.com/ApoorvSaxena/lozad.js#usage> -->
  

  

  



<!-- return -->
<div class="row">

  <div id="post-wrapper" class="col-12 col-lg-11 col-xl-8">

    <div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4">

      <h1 data-toc-skip>H@CktivityCon 2021 CTF Writeups</h1>

      <div class="post-meta text-muted d-flex flex-column">
        <!-- Published date and author -->
        <div>
          <span class="semi-bold">
            Bernard Smith
          </span>
          <!--
  Date format snippet
  See: /assets/js/_utils/timeage.js
-->





<span class="timeago "
  
    data-toggle="tooltip"
    data-placement="bottom"
    title="Sun, 19 Sep 2021, 00:18 HST"
  

  
  prep="on" >

  
  

  
    19 Sep
  

  <i class="unloaded">2021-09-19T00:18:01-10:00</i>

</span>

        </div>

        <div>
          <!-- lastmod -->
          

          <!-- read time -->
          <!--
  Calculate the post's reading time, and display the word count in tooltip
 -->


<!-- words per minute  -->







<!-- return element -->
<span class="readtime" data-toggle="tooltip" data-placement="bottom" title="5480 words">30 min</span>


          <!-- page views -->
          

        </div>

      </div> <!-- .post-meta -->

      <div class="post-content">

        

        <h1 id="warmups">Warmups</h1>

<h2 id="six-four-over-two-50-points">Six Four Over Two (50 points)</h2>
<p>We are provided with a short text file containing the string: <code class="language-plaintext highlighter-rouge">EBTGYYLHPNQTINLEGRSTOMDCMZRTIMBXGY2DKMJYGVSGIOJRGE2GMOLDGBSWM7IK</code>. Based on the name of the challenge, this could potentially be a <em>Base32-encoded</em> string. (Because \(\frac{64}{2} = 32\)) We test our theory using <a href="https://gchq.github.io/CyberChef/#recipe=From_Base32('A-Z2-7%3D',true)&amp;input=RUJUR1lZTEhQTlFUSU5MRUdSU1RPTURDTVpSVElNQlhHWTJES01KWUdWU0dJT0pSR0UyR01PTERHQlNXTTdJSw">CyberChef</a> and immediately get the flag: <code class="language-plaintext highlighter-rouge">flag{a45d4e70bfc407645185dd9114f9c0ef}</code></p>

<h2 id="bass64-50-points">Bass64 (50 points)</h2>
<p>We are provided with another text file, this time containing what appears to be a garbled mess of lines. However, simply disabling <em>word wrap</em> in Notepad allows us to see that it’s just ASCII word art for the string <code class="language-plaintext highlighter-rouge">IGZsYWd7MzVhNWQxM2RhNmEyYWZhMGM2MmJmY2JkZDYzMDFhMGF9</code>. Because it’s a relatively short string and I don’t know of anything that can convert from ASCII art back to text, we just manually parse and copy the text.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre> ___ ____ _____  __   ____        __  _ _____ __  __    __     ___     _   _ __        _____        __  __ ____  ____  _     _   _           _____      __   ____        ________     __  __  ____ __  __ ____  __  __               _         __   ______     _ _     ____ _______   __   __  __ ____  _____ _      __  __  ____ _____ ___  
|_ _/ ___|__  /__\ \ / /\ \      / /_| |___  |  \/  |___\ \   / / |__ | \ | |\ \      / / _ \ __  _|  \/  |___ \|  _ \| |__ | \ | |_ __ ___ | ____|   _ \ \ / /\ \      / /__  / |__ |  \/  |/ ___|  \/  |___ \|  \/  |_ __ ___     | | _ __ __\ \ / /___ \   | | | __|__  /|  _ \ \ / /__|  \/  |  _ \|  ___| |__  |  \/  |/ ___|  ___/ _ \ 
 | | |  _  / // __\ V /  \ \ /\ / / _` |  / /| |\/| |_  /\ \ / /| '_ \|  \| | \ \ /\ / / | | |\ \/ / |\/| | __) | |_) | '_ \|  \| | '_ ` _ \|  _|| | | | \ V /  \ \ /\ / /  / /| '_ \| |\/| | |  _| |\/| | __) | |\/| | '_ ` _ \ _  | || '_ ` _ \ V /  __) |  | | |/ /  / / | | | \ V /_  / |\/| | | | | |_  | '_ \ | |\/| | |  _| |_ | (_) |
 | | |_| |/ /_\__ \| |    \ V  V / (_| | / / | |  | |/ /  \ V / | | | | |\  |  \ V  V /| |_| | &gt;  &lt;| |  | |/ __/|  _ &lt;| | | | |\  | | | | | | |__| |_| |  | |    \ V  V /  / /_| | | | |  | | |_| | |  | |/ __/| |  | | | | | | | |_| || | | | | | |  / __/ |_| |   &lt;  / /_ | |_| || | / /| |  | | |_| |  _| | | | || |  | | |_| |  _| \__, |
|___\____/____|___/|_|     \_/\_/ \__,_|/_/  |_|  |_/___|  \_/  |_| |_|_| \_|   \_/\_/  \__\_\/_/\_\_|  |_|_____|_| \_\_| |_|_| \_|_| |_| |_|_____\__, |  |_|     \_/\_/  /____|_| |_|_|  |_|\____|_|  |_|_____|_|  |_|_| |_| |_|\___/ |_| |_| |_|_| |_____\___/|_|\_\/____ |____/ |_|/___|_|  |_|____/|_|   |_| |_||_|  |_|\____|_|     /_/ 
                                                                                                                                                  |___/                                                                                                                                                                                      
</pre></td></tr></tbody></table></code></div></div>

<p>Based on both the challenge name and the format of the string, we can assume that this is a <em>Base64-encoded</em> string. Putting this into <a href="https://gchq.github.io/CyberChef/#recipe=From_Base64('A-Za-z0-9%2B/%3D',true)&amp;input=SUdac1lXZDdNelZoTldReE0yUmhObUV5WVdaaE1HTTJNbUptWTJKa1pEWXpNREZoTUdGOQ">CyberChef</a> gives us the flag: <code class="language-plaintext highlighter-rouge">flag{35a5d13da6a2afa0c62bfcbdd6301a0a}</code></p>

<h2 id="pimple-50-points">Pimple (50 points)</h2>
<p>This one is pretty simple. Using <code class="language-plaintext highlighter-rouge">file</code> on attachment shows that it’s a <em>GIMP</em> file. Then after opening the file in <em>GIMP</em> and looking through the content, we find the flag printed on one of the inner layers: <code class="language-plaintext highlighter-rouge">flag{9a64bc4a390cb0ce31452820ee562c3f}</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre>$ file pimple
pimple: GIMP XCF image data, version 011, 1024 x 1024, RGB Color
</pre></td></tr></tbody></table></code></div></div>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/imgs/hacktivity2021/pimple.png" alt="File opened in GIMP" title="Opened in GIMP" /></p>

<h2 id="tsunami-50-points">Tsunami (50 points)</h2>
<p>Using <code class="language-plaintext highlighter-rouge">file</code> again, we discover that this is a <code class="language-plaintext highlighter-rouge">.wav</code> file.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre>$ file tsunami
tsunami: RIFF (little-endian) data, WAVE audio, Microsoft PCM, 16 bit, stereo 44100 Hz
</pre></td></tr></tbody></table></code></div></div>

<p>The end of the audio is a series of tones that makes me think it’s <em>spectrogram steganography</em>. After finding a website that let’s us view the spectrogram of an audio file(<a href="https://academo.org/demos/spectrum-analyzer/">Academo</a>), we see that those series of tones make up the flag value: <code class="language-plaintext highlighter-rouge">flag{f8fbb2c761821d3af23859f721cc140b}</code>. If it’s hard to make out the flag yourself, just remember that all of the letters are lowercase so they can’t be confused with a number.</p>

<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/imgs/hacktivity2021/tsunami.png" alt="tsunami.wav Spectrogram" title="tsunami.wav Spectrogram" /></p>

<h2 id="butter-overflow-50-points">Butter Overflow (50 points)</h2>
<p>This time we’re provided with three files.</p>

<ul>
  <li>An executable file: <code class="language-plaintext highlighter-rouge">butter_overflow</code></li>
  <li>The source code of the executable: <code class="language-plaintext highlighter-rouge">source.c</code></li>
  <li>A <code class="language-plaintext highlighter-rouge">Makefile</code> we can use to compile the source code ourselves</li>
</ul>

<p>After examining the source code, we discover the following information about the program’s behavior:</p>

<ol>
  <li>Line 43 - Creates a buffer array that can store up to 512 bytes</li>
  <li>Line 51 - Directly saves user input into this buffer, without size checks</li>
  <li>Lines 48 &amp; 10 - Runs the <code class="language-plaintext highlighter-rouge">give_flag()</code> function if there’s a <em>segmentation fault</em></li>
</ol>

<p>So the solution is simple, if we provide enough input to the program to cause a <em>buffer overflow</em>, it’ll trigger a segmentation fault and give us the flag. Sure enough, sending <em>600 A’s</em> to the challenge server prints out the flag: <code class="language-plaintext highlighter-rouge">flag{72d8784a5da3a8f56d2106c12dbab989}</code></p>

<script id="asciicast-1jvQPqbLREpu1hOBmBH0AaVpV" src="https://asciinema.org/a/1jvQPqbLREpu1hOBmBH0AaVpV.js" async=""></script>

<h2 id="oddball-103-points">Oddball (103 points)</h2>
<p>Funnily enough, this warmup challenge ended up being worth more than some of the “real” challenges. Here, we are given an <code class="language-plaintext highlighter-rouge">oddball</code> file containing several lines of numbers.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre>0000000 067531 020165 067165 067543 062566 062562 020144 064164
0000020 020145 062563 071143 072145 066440 071545 060563 062547
0000040 035440 005051 072516 061155 071145 020163 067151 071040
0000060 067141 062547 030040 033455 020077 066510 066555 020041
0000100 067510 020167 062157 005041 063012 060554 075547 060462
0000120 031065 061462 033062 034143 060467 031546 034461 061062
0000140 031064 031543 063064 031544 033062 034063 061065 005175
0000160
</pre></td></tr></tbody></table></code></div></div>

<p>After analyzing the file for a bit, we realize that there are no numbers greater than <code class="language-plaintext highlighter-rouge">7</code>, so the file must be a list of <em>octal</em> numbers. As it turns out, the famous <code class="language-plaintext highlighter-rouge">xxd</code> tool has a lesser known uncle called <code class="language-plaintext highlighter-rouge">od</code>. But rather than hexdumps, this program creates <em>octal dumps</em> of files in the exact same format as the <code class="language-plaintext highlighter-rouge">oddball</code> file. Unfortunately, <code class="language-plaintext highlighter-rouge">od</code> doesn’t appear to have a reversal function like <code class="language-plaintext highlighter-rouge">xxd</code> does, so we have to make one ourselves. After taking out the first column of numbers, we can use the following <code class="language-plaintext highlighter-rouge">python3</code> script to decode <code class="language-plaintext highlighter-rouge">oddball</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="rouge-code"><pre><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>
<span class="nb">oct</span> <span class="o">=</span> <span class="s">"""067531 020165 067165 067543 062566 062562 020144 064164 020145 062563 071143 072145
066440 071545 060563 062547 035440 005051 072516 061155 071145 020163 067151 071040 067141
062547 030040 033455 020077 066510 066555 020041 067510 020167 062157 005041 063012 060554
075547 060462 031065 061462 033062 034143 060467 031546 034461 061062 031064 031543 063064
031544 033062 034063 061065 005175"""</span><span class="p">.</span><span class="n">split</span><span class="p">()</span>
<span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="nb">oct</span><span class="p">:</span>
    <span class="c1"># Decodes the octal string into its byte form
</span>    <span class="c1"># ^──────────────┐
</span>    <span class="c1"># Reverses the endianess of the byte so it prints correctly
</span>    <span class="c1"># ^────┐         |
</span>    <span class="c1"># Decodes the byte into a printable string
</span>    <span class="c1"># ^────|─────────|───────┐
</span>    <span class="c1">#      V         V       V
</span>    <span class="k">print</span><span class="p">(</span><span class="n">p16</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="mi">8</span><span class="p">)).</span><span class="n">decode</span><span class="p">(</span><span class="s">'utf-8'</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s">''</span><span class="p">)</span> 
</pre></td></tr></tbody></table></code></div></div>

<p>Running this script provides us with the following output containing the flag:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre>You uncovered the secret message ;)
Numbers in range 0-7? Hmmm! How od!

flag{2a522c26c87af3192b42c34fd326385b}
</pre></td></tr></tbody></table></code></div></div>

<h1 id="web">Web</h1>

<h2 id="confidentiality-50-points">Confidentiality (50 points)</h2>
<p>This challenge involves a simple command injection vulnerability. We’re provided with a web application that gives us the ability to check the access control settings for any given file on the server. To start, we test it out with a known file, <code class="language-plaintext highlighter-rouge">/etc/passwd</code>.</p>

<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/imgs/hacktivity2021/confidentiality_1.png" alt="Testing /etc/passwd" title="Testing with /etc/passwd" /></p>

<p>These results seem eerily similar to what <code class="language-plaintext highlighter-rouge">ls -l</code> does. It appears that the application is simply taking our input and appending it to an <code class="language-plaintext highlighter-rouge">ls -l</code> command. So if we wanted to see the files in our current directory, we could provide it with a period (<code class="language-plaintext highlighter-rouge">.</code>). Of course, we would normally just run <code class="language-plaintext highlighter-rouge">ls -l</code> on its own for the same effect, but the application rejects an empty input.</p>

<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/imgs/hacktivity2021/confidentiality_2.png" alt="Testing ." title="Testing with ." /></p>

<p>This is the exact output we would expect from an <code class="language-plaintext highlighter-rouge">ls -l .</code> command. So our goal now is to output the contents of the <code class="language-plaintext highlighter-rouge">flag.txt</code> file within this directory. To verify our command injection capabilities, we can use the <code class="language-plaintext highlighter-rouge">;</code> character to append a second command to this line. By sending a request for <code class="language-plaintext highlighter-rouge">; whoami</code>, we predict that the server will run the command <code class="language-plaintext highlighter-rouge">ls -l ; whoami</code>, showing us the current directory and username.</p>

<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/imgs/hacktivity2021/confidentiality_3.png" alt="Testing whoami" title="Testing with whoami" /></p>

<p>Success! This shows us that we have the ability to execute commands on the server. Now we just need to send a <code class="language-plaintext highlighter-rouge">; cat flag.txt</code> request to output the flag, which ends up being: <code class="language-plaintext highlighter-rouge">flag{e56abbce7b83d62dac05e59fb1e81c68}</code></p>

<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/imgs/hacktivity2021/confidentiality_flag.png" alt="Retrieving flag.txt" title="Retrieving the flag" /></p>

<p><strong>Bonus</strong>: If we wanted to, we can also see the source code for the application itself. A <code class="language-plaintext highlighter-rouge">; cat main.py</code> request outputs the contents of <code class="language-plaintext highlighter-rouge">main.py</code> and shows how the application operates. And exactly how we predicted, the application is simply appending our input to the end of an <code class="language-plaintext highlighter-rouge">ls -l</code> command, without any verification or sanitization.</p>

<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/imgs/hacktivity2021/confidentiality_mainpy.png" alt="Server source code" title="Retrieving the server's source code" /></p>

<h2 id="titanic-50-points">Titanic (50 points)</h2>
<p>This challenge involves leveraging a <em>server-side request forgery (SSRF)</em> to access sensitive, internal information. The website contains two main features that we will use: an admin login page and a URL capturer service.</p>

<p>The admin login is fairly normal. Since we obviously don’t have any admin credentials, we cannot make real use of this section right now. However, one thing of note about this page is the unique way it sends login attempts. Normally, logins would be sent as a <code class="language-plaintext highlighter-rouge">POST</code> request, with the username and password in the body. But here, the login attempt is made as a <code class="language-plaintext highlighter-rouge">GET</code> request, with the username and password in the URL. A username and password of <code class="language-plaintext highlighter-rouge">test:test</code> is performed with the URL <code class="language-plaintext highlighter-rouge">http://challenge.ctf.games:31971/admin.php?uname=test&amp;psw=test</code>. While this behavior isn’t particularly useful to us right now, it will become very important later on.</p>

<p>Moving on to the URL capturer service. This service simply takes the URL we provide, makes a request to that URL on our behalf, and gives back a screenshot of the webpage. This service can allow us to perform an <em>SSRF</em> to disclose sensitive, local information on the server. It’s actually difficult to really call it an <em>SSRF</em> vulnerability because it’s clearly intended behavior. But to first validate that we <strong>can</strong> use it for <em>SSRF</em>, we will make a request to <code class="language-plaintext highlighter-rouge">http://localhost</code> and verify that we receive the same webpage.</p>

<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/imgs/hacktivity2021/titanic_1.png" alt="Requesting localhost" title="SSRF request to localhost" /></p>

<p>The request is successful! We receive back the loading circle for the website, showing that it is successfully making a request to <code class="language-plaintext highlighter-rouge">http://localhost</code>. As far as how to use it though, the <code class="language-plaintext highlighter-rouge">robots.txt</code> file for the website points to the <code class="language-plaintext highlighter-rouge">/server-status</code> page as an option. When we make a request to that page ourselves, it gives back a <em>403 Forbidden</em> error. However, if we ask the server to request it locally at <code class="language-plaintext highlighter-rouge">http://localhost/server-status</code>, we get back the full status page for this webserver.</p>

<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/imgs/hacktivity2021/titanic_2.png" alt="Server-status" title="Server-status page" /></p>

<p>Remember how login attempts are made as a <code class="language-plaintext highlighter-rouge">GET</code> request? Because of that, now we can clearly see a username and password for a previously successful login attempt: <code class="language-plaintext highlighter-rouge">root:EYNDR4NhadwX9rtef</code>. Using these credentials, we can access the admin page and retrieve the flag: <code class="language-plaintext highlighter-rouge">flag{88269d5ef52a5ee961ea6449e1b610a9}</code>.</p>

<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/imgs/hacktivity2021/titanic_3.png" alt="Admin page" title="Admin page" /></p>

<h1 id="cryptography">Cryptography</h1>

<h2 id="n1tp-50-points">N1TP (50 Points)</h2>
<p>This challenge is deceptively simple. When we first connect to the server, <em>“Nina”</em> provides us with the ciphertext of the flag. We should also note that the ciphertext changes between connections. After this, they give us the option to provide our own plaintext to see the resulting ciphertext. While providing the ciphertext, Nina also confirms that we’re dealing with a <em>one-time pad (OTP)</em>.</p>

<p>Nina is correct in saying that <em>OTPs</em> are unbreakable. However, this is with the giant caveat that the <em>OTP</em> is used correctly. If you were to ever <em>reuse</em> a OTP’s key, like what Nina is doing here, it gives an attacker an opportunity to break the encryption. Even worse, if you reuse the key on plaintext that the attacker <em>already knows</em>, that OTP is completely broken.</p>

<p>The reason for this is that a OTP uses the <em>exclusive OR (XOR)</em> operation to perform its encryption and decryption. Normal use of an XOR (\(\oplus\)) cipher goes like this:</p>

\[\textbf{Encryption: } \text{Plaintext} \oplus \text{Key} = \text{Ciphertext}\]

\[\textbf{Decryption: } \text{Ciphertext} \oplus \text{Key} = \text{Plaintext}\]

<p>However, we if know the plaintext <strong>and</strong> ciphertext of a message, we can also compute the <em>key</em> using the properties of the XOR operation.</p>

\[\text{Plaintext} \oplus \text{Ciphertext} = \text{Key}\]

<p>So using this principle, we can perform a <em>known-plaintext attack</em> on Nina’s OTP to derive the key. Our first step is to encrypt a plaintext value the same length of the flag. For this, we will choose <code class="language-plaintext highlighter-rouge">00000000000000000000000000000000000000</code>.</p>

<script id="asciicast-NlpJ9KNEGz41BSF4oR4FSfbAb" src="https://asciinema.org/a/NlpJ9KNEGz41BSF4oR4FSfbAb.js" async=""></script>

<p>After receiving back the ciphertext for this message, we can <a href="https://gchq.github.io/CyberChef/#recipe=XOR(%7B'option':'Hex','string':'a83b924150fb13d960690a8163c38c2b9047b75642d7ad16ddcb47c15ad1f1704977d1edbddb%20%20%20%20'%7D,'Standard',false)To_Hex('None',0)&amp;input=MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA">XOR the plaintext and ciphertext together</a> to determine the OTP key using CyberChef. Finally, we can <a href="https://gchq.github.io/CyberChef/#recipe=From_Hex('None')XOR(%7B'option':'Hex','string':'980ba27160cb23e950593ab153f3bc1ba077876672e79d26edfb77f16ae1c1407947e1dd8deb'%7D,'Standard',false)&amp;input=ZmU2N2MzMTYxYmYyMTFkZTY2M2E1ZWQzNjRjNWRkMjhjNDEzYjEwNDQzODFhODE0ZGVjOTQ3YzgwOTg1ZjgyMzQ5MjZkMGVjZWY5Ng">XOR the flag’s ciphertext and the key together</a> to reveal the flag in plaintext: <code class="language-plaintext highlighter-rouge">flag{9276cdb76a3dd6b1f523209cd9c0a11b}</code>.</p>

<h1 id="miscellanious">Miscellanious</h1>

<h2 id="bad-words-50-points">Bad Words (50 points)</h2>
<p>This challenge generously gives us a <code class="language-plaintext highlighter-rouge">bash</code> shell on the server at the jump. The catch is that we’re placed into an extremely restrictive <em>jailshell</em>. If we attempt to use many of our common commands, such as <code class="language-plaintext highlighter-rouge">ls</code>, <code class="language-plaintext highlighter-rouge">id</code>, and <code class="language-plaintext highlighter-rouge">whoami</code>, the shell yells at us for using a <em>“bad word”</em>. Thankfully after testing several options, we finally have success with the command <code class="language-plaintext highlighter-rouge">/bin/sh -i</code>. This breaks us out of the jailshell and drops us into a non-restricted <code class="language-plaintext highlighter-rouge">sh</code> shell. A few <code class="language-plaintext highlighter-rouge">ls</code> commands reveals the path to the flag file in <code class="language-plaintext highlighter-rouge">~/just/out/of/reach/flag.txt</code>, which we can <code class="language-plaintext highlighter-rouge">cat</code> to retrieve the flag: <code class="language-plaintext highlighter-rouge">flag{2d43e30a358d3f30fe65cc47a9cbbe98}</code>.</p>

<script id="asciicast-sWZbiP6eNtBDOr0cDSGhfDY7Z" src="https://asciinema.org/a/sWZbiP6eNtBDOr0cDSGhfDY7Z.js" async=""></script>

<p>If you want to know how the jailshell works, its code is contained within the <code class="language-plaintext highlighter-rouge">.bashrc</code> file. It defines a <code class="language-plaintext highlighter-rouge">bad_words()</code> function that compares each argument in a user’s commands against a list of <em>“bad words”</em>. Then using the <code class="language-plaintext highlighter-rouge">trap 'bad_words' DEBUG</code> command, it forces this function to run before any command is executed by the user. If one of the arguments matches one of the bad words, it stops the user’s command from running. However, we are able to get past it because it only checks for bad words starting from the <em>beginning</em> of the argument. This is because of the regex they’re using for matching (<code class="language-plaintext highlighter-rouge">^$i.*</code>). The <code class="language-plaintext highlighter-rouge">^</code> character anchors the match to only from the beginning of the string. So although <code class="language-plaintext highlighter-rouge">sh</code> <strong>is</strong> a bad word, <code class="language-plaintext highlighter-rouge">/bin/sh</code> goes undetected because the preceding <code class="language-plaintext highlighter-rouge">/bin/</code> breaks the match.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="rouge-code"><pre><span class="nb">shopt</span> <span class="nt">-s</span> extdebug
<span class="k">function </span>bad_words<span class="o">()</span> <span class="o">{</span>
    <span class="nb">declare</span> <span class="nt">-a</span> <span class="nv">arr</span><span class="o">=(</span><span class="s2">"alert"</span> <span class="s2">"egrep"</span> <span class="s2">"fgrep"</span> <span class="s2">"grep"</span> <span class="s2">"l"</span> <span class="s2">"la"</span> <span class="s2">"ll"</span> <span class="s2">"ls"</span> <span class="o">[</span>...snip...] <span class="s2">"less"</span> <span class="s2">"lessecho"</span> <span class="s2">"flag"</span> <span class="s2">"root"</span><span class="o">)</span>

    <span class="k">for </span>i <span class="k">in</span> <span class="s2">"</span><span class="k">${</span><span class="nv">arr</span><span class="p">[@]</span><span class="k">}</span><span class="s2">"</span>
    <span class="k">do
        if</span> <span class="o">[[</span> <span class="s2">"</span><span class="nv">$BASH_COMMAND</span><span class="s2">"</span> <span class="o">=</span>~ ^<span class="nv">$i</span>.<span class="k">*</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then
            </span><span class="nb">echo</span> <span class="s2">"You said a bad word, </span><span class="se">\"</span><span class="nv">$i</span><span class="se">\"</span><span class="s2">!!"</span>
            <span class="k">return </span>1<span class="p">;</span>
        <span class="k">fi</span><span class="p">;</span>
    <span class="k">done
    return</span><span class="p">;</span>
<span class="o">}</span>

<span class="nb">trap</span> <span class="s1">'bad_words'</span> DEBUG
</pre></td></tr></tbody></table></code></div></div>

<h1 id="osint">OSINT</h1>

<h2 id="jed-sheeran-50-points">Jed Sheeran (50 points)</h2>
<p>This challenge asks us to look for an aspiring music artist named <em>Jed Sheeran</em>. The actual discovery process is simple because a Google search for “Jed Sheeran” puts his <em>SoundCloud</em> as the first result. Jed’s profile has one song that contains a mess of beeps and squeaks.</p>

<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/imgs/hacktivity2021/jed_1.png" alt="Jed's SoundCloud" title="Jed's SoundCloud" /></p>

<p>This sound is actually a <a href="https://www.sigidwiki.com/wiki/Slow-Scan_Television_(SSTV)"><em>Slow-Scan Television (SSTV)</em></a> signal, a method to transmit images as an analog signal. SSTV is popular within the amateur radio community particularly because it’s a way to send and receive images using very little bandwidth. It’s also common to see this in <em>augmented reality games (ARG)</em> or easter eggs as a way to hide pictures, like here in <a href="https://www.youtube.com/watch?v=GZvb6Hswu1o">Portal 2.</a> So to retrieve the flag from this audio file, all we need to do is decode the SSTV signal it’s playing.</p>

<p>One way to do it is to download an SSTV decoder app like <a href="https://play.google.com/store/apps/details?id=xdsopl.robot36&amp;hl=en_US&amp;gl=US">Robot36</a> and hold your phone’s microphone up to your computer speakers. But you need to keep in mind that SSTV is an <em>analog</em> signal. So any noise in the signal will cause us to receive a degraded image. The more noise, the worse the image looks. However, we could use a something called a <em>virtual audio cable</em>, such as <a href="https://vb-audio.com/Cable/">VB-CABLE</a>, to connect our browser’s audio directly to an SSTV decoder program, like <a href="https://www.qsl.net/on6mu/rxsstv.htm">RX-SSTV</a>. This will theoretically send the SSTV signal directly from SoundCloud to our decoder without <em>any</em> noise.</p>

<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/imgs/hacktivity2021/jed_2.png" alt="Connecting VB-CABLE" title="Connecting the VB-CABLE" /></p>

<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/imgs/hacktivity2021/jed_3.png" alt="Decoding SSTV" title="Decoding SSTV" /></p>

<p>Well… the flag is clearly there, but it’s extremely hard to decipher. A lot of things could be happening here. SoundCloud could be compressing the SSTV audio before it’s stored, causing additional distortion in our image. It could also be that the flag’s text is too small for this SSTV mode. SSTV isn’t exactly known for sending extremely clear images, even in a perfect world. So people normally use bigger text in an image to compensate for that or switch to a more “robust” SSTV mode. The Jed Sheeran signal appears to be using the <em>Robot 36</em> mode and is about 36 seconds long. Compare this to the following SSTV image I picked up from the <em>International Space Station</em> that uses <em>PD120</em> and is about 120 seconds long. It has text about the same size as the Jed Sheeran signal, but this time it’s actually intelligible. Keep in mind that I received this signal <em>from space</em>, as well.</p>

<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/imgs/hacktivity2021/jed_iss_example.jpg" alt="ISS SSTV Image" title="ISS SSTV Image" /></p>

<p>So where do we go from here? We could try <em>really hard</em> to determine what each character is. But, it seems that the challenge creator recognized how hard this was and decided to just put the flag in the song’s description: <code class="language-plaintext highlighter-rouge">flag{59e56590445321ccefb4d91bba61f16c}</code>.</p>

<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/imgs/hacktivity2021/jed_flag.png" alt="Jed Sheeran Flag" title="Jed Sheeran Flag" /></p>

<h1 id="scripting">Scripting</h1>

<h2 id="words-church-407-points">Words Church (407 points)</h2>
<p>It appears that people either don’t like scripting or just don’t know how to script because these challenges ended up being worth <em>a lot</em> of points. The description tells us we’ll have to solve 30 word searches, so let’s connect to the server and see what we’re dealing with.</p>

<script id="asciicast-O6lzg08iqC82LAaBW2sdvATk4" src="https://asciinema.org/a/O6lzg08iqC82LAaBW2sdvATk4.js" async=""></script>

<p>It looks fairly simple. We’re provided with a \(15 \times 15\) grid of characters and five words to find. The biggest challenge is really going to be how to parse everything. <a href="https://docs.pwntools.com/en/latest/"><code class="language-plaintext highlighter-rouge">pwntools</code></a> makes the sending and receiving part of the challenge easy, so all we have to worry about is how to process the information. The following <code class="language-plaintext highlighter-rouge">python3</code> script let’s use receive the grid used for the game:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="rouge-code"><pre><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">io</span> <span class="o">=</span> <span class="n">remote</span><span class="p">(</span><span class="s">'challenge.ctf.games'</span><span class="p">,</span> <span class="mi">32497</span><span class="p">)</span>
<span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">'&gt;'</span><span class="p">)</span>
<span class="n">io</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="s">'play'</span><span class="p">)</span>

<span class="c1"># Header lines
</span><span class="n">io</span><span class="p">.</span><span class="n">recvlines</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

<span class="c1"># Grid lines 
</span><span class="n">io</span><span class="p">.</span><span class="n">recvlines</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>

<span class="c1"># Trailing lines
</span><span class="n">io</span><span class="p">.</span><span class="n">recvlines</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></div></div>

<p>After putting this into the <code class="language-plaintext highlighter-rouge">python3</code> interpreter, we verify that we’re correctly aligned to process the grid.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
</pre></td><td class="rouge-code"><pre>Python 3.9.2 (default, Feb 28 2021, 17:03:44)
[GCC 10.2.1 20210110] on linux
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; from pwn import *
&gt;&gt;&gt; io = remote('challenge.ctf.games', 32497)
('&gt;')
io.send('play')[x] Opening connection to challenge.ctf.games on port 32497
[x] Opening connection to challenge.ctf.games on port 32497: Trying 34.122.187.139
[+] Opening connection to challenge.ctf.games on port 32497: Done
&gt;&gt;&gt; io.recvuntil('&gt;')
b"Words Church v1.0\n\n
Let's play a game of wordsearch! We will display the grid\n
and offer you words to find. Please submit the locations of\n
each word in the format [(X,Y), (X,Y), (X,Y), ...] for each letter.\n\n
Please enter 'example' if you would like to see an \n
example, or 'play' if you would like to get started.\n
&gt;"
&gt;&gt;&gt; io.send('play')
&gt;&gt;&gt;
&gt;&gt;&gt; # Headers
&gt;&gt;&gt; io.recvlines(3)
[b' Wordsearch # 1/30:',
 b'\t 0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15 : X',
 b'\t--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---']
&gt;&gt;&gt;
&gt;&gt;&gt; # Grid lines
&gt;&gt;&gt; io.recvlines(16)
[b' 0  | \t L   P   U   C   E   U   N   K   F   C   A   Q   T   Q   S   H ',
 b' 1  | \t Q   L   Q   Q   K   E   S   P   U   V   A   W   X   T   M   E ',
 b' 2  | \t E   G   O   U   H   O   U   A   Q   D   S   K   Z   M   T   Y ',
 b' 3  | \t L   Z   S   I   F   O   S   U   J   S   S   E   N   A   O   V ',
 b' 4  | \t I   S   M   V   D   Y   B   B   U   G   U   O   N   J   D   J ',
 b' 5  | \t S   J   Q   E   T   N   L   A   V   K   R   K   Z   W   S   I ',
 b' 6  | \t C   P   C   R   Y   S   E   L   K   D   E   P   S   X   A   L ',
 b' 7  | \t Q   Q   T   E   W   F   Z   L   I   M   D   E   U   S   C   O ',
 b' 8  | \t T   G   L   D   N   N   T   Y   J   K   I   S   Y   L   S   B ',
 b' 9  | \t N   E   Q   J   I   I   X   H   S   K   B   L   K   O   H   S ',
 b' 10 | \t V   K   M   I   U   V   U   O   K   S   K   T   Y   E   I   T ',
 b' 11 | \t I   M   N   F   G   V   S   O   Z   O   S   H   R   T   T   E ',
 b' 12 | \t H   F   Y   K   F   S   Q   S   Z   J   I   I   Z   T   J   R ',
 b' 13 | \t H   U   X   E   T   R   Y   N   R   Z   J   M   Z   S   U   S ',
 b' 14 | \t F   R   B   D   P   Z   K   P   K   U   N   G   A   Q   Y   O ',
 b' 15 | \t M   S   O   T   B   F   R   P   F   R   R   P   M   M   Z   T ']
&gt;&gt;&gt;
&gt;&gt;&gt; # Trailing lines
&gt;&gt;&gt; io.recvlines(2)
[b' ---',
 b'  Y ']
</pre></td></tr></tbody></table></code></div></div>

<p>Translating the grid into a 2D-array is fairly trivial. All we have to do is split each line on whitespace to get a list of all characters, and then skip the first two characters that contain the <code class="language-plaintext highlighter-rouge">Y</code> coordinate and <code class="language-plaintext highlighter-rouge">|</code> separator. The following code does this for us:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre></td><td class="rouge-code"><pre><span class="c1"># Process grid lines
</span><span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">):</span>
  <span class="c1"># Decode the input from a bytestring into a normal string
</span>  <span class="c1"># ^─────────────────────────┐
</span>  <span class="c1"># Split the string on whitespace, returning a list of each
</span>  <span class="c1"># ^    character in the string
</span>  <span class="c1"># └─────────────────────────│───────────────┐
</span>  <span class="c1"># Skip the first two characters in the new list
</span>  <span class="c1"># ^─────────────────────────│───────────────│──────┐
</span>  <span class="n">grid</span><span class="p">.</span><span class="n">append</span><span class="p">(</span> <span class="n">io</span><span class="p">.</span><span class="n">recvline</span><span class="p">().</span><span class="n">decode</span><span class="p">(</span><span class="s">'utf-8'</span><span class="p">).</span><span class="n">split</span><span class="p">()[</span><span class="mi">2</span><span class="p">:]</span> <span class="p">)</span>

<span class="c1"># Test grid
</span><span class="k">print</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>

<span class="c1"># Output
</span><span class="s">"""
[['L', 'P', 'U', 'C', 'E', 'U', 'N', 'K', 'F', 'C', 'A', 'Q', 'T', 'Q', 'S', 'H'],
 ['Q', 'L', 'Q', 'Q', 'K', 'E', 'S', 'P', 'U', 'V', 'A', 'W', 'X', 'T', 'M', 'E'],
 ['E', 'G', 'O', 'U', 'H', 'O', 'U', 'A', 'Q', 'D', 'S', 'K', 'Z', 'M', 'T', 'Y'],
 ['L', 'Z', 'S', 'I', 'F', 'O', 'S', 'U', 'J', 'S', 'S', 'E', 'N', 'A', 'O', 'V'],
 ['I', 'S', 'M', 'V', 'D', 'Y', 'B', 'B', 'U', 'G', 'U', 'O', 'N', 'J', 'D', 'J'],
 ['S', 'J', 'Q', 'E', 'T', 'N', 'L', 'A', 'V', 'K', 'R', 'K', 'Z', 'W', 'S', 'I'],
 ['C', 'P', 'C', 'R', 'Y', 'S', 'E', 'L', 'K', 'D', 'E', 'P', 'S', 'X', 'A', 'L'],
 ['Q', 'Q', 'T', 'E', 'W', 'F', 'Z', 'L', 'I', 'M', 'D', 'E', 'U', 'S', 'C', 'O'],
 ['T', 'G', 'L', 'D', 'N', 'N', 'T', 'Y', 'J', 'K', 'I', 'S', 'Y', 'L', 'S', 'B'],
 ['N', 'E', 'Q', 'J', 'I', 'I', 'X', 'H', 'S', 'K', 'B', 'L', 'K', 'O', 'H', 'S'],
 ['V', 'K', 'M', 'I', 'U', 'V', 'U', 'O', 'K', 'S', 'K', 'T', 'Y', 'E', 'I', 'T'],
 ['I', 'M', 'N', 'F', 'G', 'V', 'S', 'O', 'Z', 'O', 'S', 'H', 'R', 'T', 'T', 'E'],
 ['H', 'F', 'Y', 'K', 'F', 'S', 'Q', 'S', 'Z', 'J', 'I', 'I', 'Z', 'T', 'J', 'R'],
 ['H', 'U', 'X', 'E', 'T', 'R', 'Y', 'N', 'R', 'Z', 'J', 'M', 'Z', 'S', 'U', 'S'],
 ['F', 'R', 'B', 'D', 'P', 'Z', 'K', 'P', 'K', 'U', 'N', 'G', 'A', 'Q', 'Y', 'O'],
 ['M', 'S', 'O', 'T', 'B', 'F', 'R', 'P', 'F', 'R', 'R', 'P', 'M', 'M', 'Z', 'T']]
"""</span>
</pre></td></tr></tbody></table></code></div></div>

<p>The next step is to determine how to receive the words we need to search for. After we receive the grid lines, the questions are sent to us in the following format: <code class="language-plaintext highlighter-rouge">LIEU: &gt; </code>. All we need to do here is extract the word, which is very easy to do using <code class="language-plaintext highlighter-rouge">split()</code> again.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="c1"># Receive input until we hit the '&gt;' character
</span><span class="n">question</span> <span class="o">=</span> <span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">'&gt;'</span><span class="p">).</span><span class="n">decode</span><span class="p">(</span><span class="s">'utf-8'</span><span class="p">)</span>
<span class="c1"># Split the line on the ':' character and take everything before the ':'
</span><span class="n">word</span> <span class="o">=</span> <span class="n">question</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">':'</span><span class="p">)[</span><span class="mi">0</span><span class="p">].</span><span class="n">strip</span><span class="p">()</span>
</pre></td></tr></tbody></table></code></div></div>

<p>Now that we have our grid and words in a format we can process, it’s time to create the searching functions. While I’m sure there are super fast algorithms specifically designed to solve this problem, we’re going to stick with the naïve solution: go through every coordinate that matches the first letter of the word and search out from all eight directions to see if the rest of it matches. Here we have two components to design, the function to search through the entire grid, and the function to search out from a position to determine if the word matches. I’ve implemented them both in <code class="language-plaintext highlighter-rouge">python3</code>, as seen below:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre></td><td class="rouge-code"><pre><span class="c1"># Search from a given (x,y) position out a given direction
#   and return the positions of matching characters.
#   Returns an empty list `[]` if the match fails.
</span><span class="k">def</span> <span class="nf">direction_search</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">x_delta</span><span class="p">,</span> <span class="n">y_delta</span><span class="p">):</span>
    <span class="n">tiles</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">word</span><span class="p">:</span>
        <span class="c1"># If this tile doesn't match the current character,
</span>        <span class="c1">#   return an empty list. 
</span>        <span class="c1"># The position also wraps around the edges of the grid.
</span>        <span class="k">if</span> <span class="n">grid</span><span class="p">[</span><span class="n">y</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">)][</span><span class="n">x</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">)]</span> <span class="o">!=</span> <span class="n">c</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If we're still matching, add this position as an
</span>            <span class="c1">#   (x, y) tuple to the position list.
</span>            <span class="n">tiles</span><span class="p">.</span><span class="n">append</span><span class="p">(</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="p">)</span>
        <span class="c1"># Move in the given direction
</span>        <span class="n">y</span> <span class="o">+=</span> <span class="n">y_delta</span>
        <span class="n">x</span> <span class="o">+=</span> <span class="n">x_delta</span>
    <span class="k">return</span> <span class="n">tiles</span>

<span class="c1"># Search each tile in the grid and determine if the word is found
#   in any 8 directions from each tile.
# Returns list of positions if the word is found, empty list `[]`,
#   if not.
</span><span class="k">def</span> <span class="nf">word_search</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="n">grid</span><span class="p">):</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">row</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">grid</span><span class="p">):</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">tile</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
            <span class="c1"># If this tile matches the first letter of the word, then
</span>            <span class="c1">#   check if the rest of the word is found in any of the 
</span>            <span class="c1">#   8 directions from this position.
</span>            <span class="k">if</span> <span class="n">tile</span> <span class="o">==</span> <span class="n">word</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">x_delta</span> <span class="ow">in</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
                    <span class="k">for</span> <span class="n">y_delta</span> <span class="ow">in</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
                        <span class="n">search</span> <span class="o">=</span> <span class="n">direction_search</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">x_delta</span><span class="p">,</span> <span class="n">y_delta</span><span class="p">)</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">search</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="k">return</span> <span class="n">search</span>
    <span class="k">return</span> <span class="p">[]</span>
</pre></td></tr></tbody></table></code></div></div>

<p>Finally, we can combine all of these elements in the final script and run it to solve the challenge to receive the flag: <code class="language-plaintext highlighter-rouge">flag{ac670e1f34da9eb748b3f241eb03f51b}</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
</pre></td><td class="rouge-code"><pre><span class="c1">#!/usr/bin/python3
</span>
<span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="k">def</span> <span class="nf">direction_search</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">x_delta</span><span class="p">,</span> <span class="n">y_delta</span><span class="p">):</span>
    <span class="n">tiles</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">word</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">grid</span><span class="p">[</span><span class="n">y</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">)][</span><span class="n">x</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">)]</span> <span class="o">!=</span> <span class="n">c</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tiles</span><span class="p">.</span><span class="n">append</span><span class="p">(</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="p">)</span>
        <span class="n">y</span> <span class="o">+=</span> <span class="n">y_delta</span>
        <span class="n">x</span> <span class="o">+=</span> <span class="n">x_delta</span>
    <span class="k">return</span> <span class="n">tiles</span>

<span class="k">def</span> <span class="nf">word_search</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="n">grid</span><span class="p">):</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">row</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">grid</span><span class="p">):</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">tile</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">tile</span> <span class="o">==</span> <span class="n">word</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">x_delta</span> <span class="ow">in</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
                    <span class="k">for</span> <span class="n">y_delta</span> <span class="ow">in</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
                        <span class="n">search</span> <span class="o">=</span> <span class="n">direction_search</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">x_delta</span><span class="p">,</span> <span class="n">y_delta</span><span class="p">)</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">search</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="k">return</span> <span class="n">search</span>
    <span class="k">return</span> <span class="p">[]</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="c1"># Connect to the challenge server
</span>    <span class="n">port</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">io</span> <span class="o">=</span> <span class="n">remote</span><span class="p">(</span><span class="s">'challenge.ctf.games'</span><span class="p">,</span> <span class="n">port</span><span class="p">)</span>
    
    <span class="c1"># Start a game
</span>    <span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">'&gt;'</span><span class="p">)</span>
    <span class="n">io</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="s">'play'</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">30</span><span class="p">):</span>
        <span class="c1"># Skip header lines
</span>        <span class="k">print</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">recvline</span><span class="p">().</span><span class="n">decode</span><span class="p">(</span><span class="s">'utf-8'</span><span class="p">).</span><span class="n">strip</span><span class="p">())</span>
        <span class="n">io</span><span class="p">.</span><span class="n">recvlines</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Process grid
</span>        <span class="n">grid</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">):</span>
            <span class="n">grid</span><span class="p">.</span><span class="n">append</span><span class="p">(</span> <span class="n">io</span><span class="p">.</span><span class="n">recvline</span><span class="p">().</span><span class="n">decode</span><span class="p">(</span><span class="s">'utf-8'</span><span class="p">).</span><span class="n">split</span><span class="p">()[</span><span class="mi">2</span><span class="p">:]</span> <span class="p">)</span>

        <span class="c1"># Skip trailing lines
</span>        <span class="n">io</span><span class="p">.</span><span class="n">recvlines</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Answer questions
</span>        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
            <span class="n">question</span> <span class="o">=</span> <span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">'&gt;'</span><span class="p">).</span><span class="n">decode</span><span class="p">(</span><span class="s">'utf-8'</span><span class="p">)</span>
            <span class="n">word</span> <span class="o">=</span> <span class="n">question</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">':'</span><span class="p">)[</span><span class="mi">0</span><span class="p">].</span><span class="n">strip</span><span class="p">()</span>
            <span class="n">answer</span> <span class="o">=</span> <span class="n">word_search</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="n">grid</span><span class="p">)</span>
            <span class="n">io</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span> <span class="nb">str</span><span class="p">(</span><span class="n">answer</span><span class="p">).</span><span class="n">encode</span><span class="p">(</span><span class="s">'utf-8'</span><span class="p">)</span> <span class="p">)</span>
        
        <span class="c1"># Skip post-game lines
</span>        <span class="n">io</span><span class="p">.</span><span class="n">recvlines</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

    <span class="c1"># Print the final output
</span>    <span class="k">print</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">recvrepeat</span><span class="p">(</span><span class="mi">5</span><span class="p">).</span><span class="n">decode</span><span class="p">(</span><span class="s">'utf-8'</span><span class="p">))</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></td></tr></tbody></table></code></div></div>
<script id="asciicast-orEe52FXgh8rILEeCu7o6GXZF" src="https://asciinema.org/a/orEe52FXgh8rILEeCu7o6GXZF.js" async=""></script>

<h2 id="otp-smasher-283-points">OTP Smasher (283 points)</h2>
<p>This is a pretty interesting challenge because it requires us to do some <em>optical character recognition (OCR)</em>. We’re presented with a simple webpage displaying a picture of numbers, an submission field, and a counter in the upper-left. <em>Chrome DevTools</em> also shows that the page also attempts to display the image <code class="language-plaintext highlighter-rouge">static/flag.png</code>. Based on the challenge’s name, the number picture might be intended to act as a <em>one-time password (OTP)</em>. Submitting the OTP increments the upper-left counter by one and waiting too long to submit another OTP resets it to zero.</p>

<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/imgs/hacktivity2021/smasher_1.png" alt="OTP Smasher Page" title="OTP Smasher Page" /></p>

<p>While this challenge was up, the creator eventually decided to increase the length of time allowed until a reset to help make the challenge a bit easier. So right now, we could technically manually submit 45 passwords to get the flag. But of course, that is no fun learning-wise and no fun because it’s super tedious. Using <em>Chrome DevTools</em>, we were able to figure out the format of the submission: a <code class="language-plaintext highlighter-rouge">POST</code> request to the main page with the password in a field called <code class="language-plaintext highlighter-rouge">otp_entry</code>. Using this information, we are now able to automate OTP submissions.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">requests</span>
<span class="kn">from</span> <span class="nn">bs4</span> <span class="kn">import</span> <span class="n">BeautifulSoup</span> <span class="k">as</span> <span class="n">bs</span>

<span class="c1"># Send the current `otp` to the server
</span><span class="n">post</span> <span class="o">=</span> <span class="n">requests</span><span class="p">.</span><span class="n">post</span><span class="p">(</span><span class="sa">f</span><span class="s">"http://challenge.ctf.games:</span><span class="si">{</span><span class="n">port</span><span class="si">}</span><span class="s">/"</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="p">{</span><span class="s">"otp_entry"</span><span class="p">:</span><span class="n">otp</span><span class="p">})</span> 

<span class="c1"># Print out the current counter value
</span><span class="k">print</span><span class="p">(</span> <span class="n">bs</span><span class="p">(</span><span class="n">post</span><span class="p">.</span><span class="n">text</span><span class="p">,</span> <span class="s">'html.parser'</span><span class="p">).</span><span class="n">p</span> <span class="p">)</span>
</pre></td></tr></tbody></table></code></div></div>

<p>The remaining problem is how to know what numbers to send? To accomplish this, we will make use of a software called <a href="https://tesseract-ocr.github.io/">Tesseract</a> and its companion Python module, <a href="https://pypi.org/project/pytesseract/"><code class="language-plaintext highlighter-rouge">pytesseract</code></a>. Combining this with the <code class="language-plaintext highlighter-rouge">requests</code> module to download the image and the <code class="language-plaintext highlighter-rouge">PIL</code> module to store the image, we can now automate OCR on the images to determine the OTP’s numbers.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">requests</span>
<span class="kn">import</span> <span class="nn">pytesseract</span>
<span class="kn">from</span> <span class="nn">PIL</span> <span class="kn">import</span> <span class="n">Image</span>
<span class="kn">from</span> <span class="nn">io</span> <span class="kn">import</span> <span class="n">BytesIO</span>

<span class="c1"># Retrieve the current OTP image
</span><span class="n">get</span> <span class="o">=</span> <span class="n">requests</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="sa">f</span><span class="s">"http://challenge.ctf.games:</span><span class="si">{</span><span class="n">port</span><span class="si">}</span><span class="s">/static/otp.png"</span><span class="p">)</span>

<span class="c1"># Save the image into a PIL Image object
</span><span class="n">image</span> <span class="o">=</span> <span class="n">Image</span><span class="p">.</span><span class="nb">open</span><span class="p">(</span><span class="n">BytesIO</span><span class="p">(</span><span class="n">get</span><span class="p">.</span><span class="n">content</span><span class="p">))</span>

<span class="c1"># OCR the image to determine the OTP
</span><span class="n">otp</span> <span class="o">=</span> <span class="n">pytesseract</span><span class="p">.</span><span class="n">image_to_string</span><span class="p">(</span><span class="n">image</span><span class="p">).</span><span class="n">strip</span><span class="p">()</span>
</pre></td></tr></tbody></table></code></div></div>

<p>This gives us an 80% solution to the challenge. I say 80% because while it works <em>most</em> of the time, it fails enough that we have to manually step in every once in awhile. There’s probably a way to train <em>tesseract</em> to better recognize the OTP numbers, but we won’t dive into that realm for this challenge. For now, we’ll just check if the string from <em>tesseract</em> is a number. If it isn’t, then have the user type in the OTP manually.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre><span class="c1"># See if we get an error when converting the OTP to a number
</span><span class="k">try</span><span class="p">:</span>
  <span class="nb">int</span><span class="p">(</span><span class="n">otp</span><span class="p">)</span>
<span class="k">except</span><span class="p">:</span>
  <span class="c1"># If the OTP isn't a number, make the user type it in manually
</span>  <span class="n">otp</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s">"&gt;"</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></div></div>

<p>Now that all of our components are created, we can combine them into the final script that’ll automatically send the OTPs to the server until it sees the flag: <code class="language-plaintext highlighter-rouge">flag{f994cd9c756675b743b10c44b32e36b6}</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">requests</span>
<span class="kn">import</span> <span class="nn">pytesseract</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">PIL</span> <span class="kn">import</span> <span class="n">Image</span>
<span class="kn">from</span> <span class="nn">io</span> <span class="kn">import</span> <span class="n">BytesIO</span>
<span class="kn">from</span> <span class="nn">bs4</span> <span class="kn">import</span> <span class="n">BeautifulSoup</span> <span class="k">as</span> <span class="n">bs</span>

<span class="n">port</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="c1"># Retrieve the current OTP image
</span>    <span class="n">get</span> <span class="o">=</span> <span class="n">requests</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="sa">f</span><span class="s">"http://challenge.ctf.games:</span><span class="si">{</span><span class="n">port</span><span class="si">}</span><span class="s">/static/otp.png"</span><span class="p">)</span>

    <span class="c1"># Save the image into a PIL Image object
</span>    <span class="n">image</span> <span class="o">=</span> <span class="n">Image</span><span class="p">.</span><span class="nb">open</span><span class="p">(</span><span class="n">BytesIO</span><span class="p">(</span><span class="n">get</span><span class="p">.</span><span class="n">content</span><span class="p">))</span>

    <span class="c1"># OCR the image to determine the OTP
</span>    <span class="n">otp</span> <span class="o">=</span> <span class="n">pytesseract</span><span class="p">.</span><span class="n">image_to_string</span><span class="p">(</span><span class="n">image</span><span class="p">).</span><span class="n">strip</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"OTP - </span><span class="si">{</span><span class="n">otp</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
    <span class="c1"># See if we get an error when converting the OTP to a number
</span>    <span class="k">try</span><span class="p">:</span>
        <span class="nb">int</span><span class="p">(</span><span class="n">otp</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="c1"># If the OTP isn't a number, make the user type it in manually
</span>        <span class="n">otp</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s">"&gt;"</span><span class="p">)</span>

    <span class="c1"># Send the current `otp` to the server
</span>    <span class="n">post</span> <span class="o">=</span> <span class="n">requests</span><span class="p">.</span><span class="n">post</span><span class="p">(</span><span class="sa">f</span><span class="s">"http://challenge.ctf.games:</span><span class="si">{</span><span class="n">port</span><span class="si">}</span><span class="s">/"</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="p">{</span><span class="s">"otp_entry"</span><span class="p">:</span><span class="n">otp</span><span class="p">})</span> 

    <span class="c1"># Print out the current counter value
</span>    <span class="k">print</span><span class="p">(</span> <span class="n">bs</span><span class="p">(</span><span class="n">post</span><span class="p">.</span><span class="n">text</span><span class="p">,</span> <span class="s">'html.parser'</span><span class="p">).</span><span class="n">p</span> <span class="p">)</span>
    
    <span class="c1"># Check if the flag image is available yet
</span>    <span class="n">flag</span> <span class="o">=</span> <span class="n">requests</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="sa">f</span><span class="s">"http://challenge.ctf.games:</span><span class="si">{</span><span class="n">port</span><span class="si">}</span><span class="s">/static/flag.png"</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">flag</span><span class="p">.</span><span class="n">status_code</span> <span class="o">!=</span> <span class="mi">404</span><span class="p">:</span>
        <span class="c1"># If we find the flag, save it and end the script
</span>        <span class="k">print</span><span class="p">(</span><span class="s">"Flag found"</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">"flag.png"</span><span class="p">,</span> <span class="s">"wb"</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">f</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">flag</span><span class="p">.</span><span class="n">content</span><span class="p">)</span>
            <span class="nb">exit</span><span class="p">()</span>

</pre></td></tr></tbody></table></code></div></div>

<script id="asciicast-da02LwqVd2u5WkZ9V7amQRRZG" src="https://asciinema.org/a/da02LwqVd2u5WkZ9V7amQRRZG.js" async=""></script>

<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/imgs/hacktivity2021/smasher_flag.png" alt="OTP Smasher Flag" title="OTP Smasher Page" /></p>

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: [
      "MathMenu.js",
      "MathZoom.js",
      "AssistiveMML.js",
      "a11y/accessibility-menu.js"
    ],
    jax: ["input/TeX", "output/CommonHTML"],
    TeX: {
      extensions: [
        "AMSmath.js",
        "AMSsymbols.js",
        "noErrors.js",
        "noUndefined.js",
      ]
    }
  });
</script>

<script type="text/javascript" async="" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>



      </div>

      <div class="post-tail-wrapper text-muted">

        <!-- categories -->
        
        <div class="post-meta mb-3">
          <i class="far fa-folder-open fa-fw mr-1"></i>
          
            <a href='/categories/ctf/'>CTF</a>,
            <a href='/categories/h-cktivity2021/'>H@cktivity2021</a>
        </div>
        

        <!-- tags -->
        
        <div class="post-tags">
          <i class="fa fa-tags fa-fw mr-1"></i>
          
          <a href="/tags/cryptography/"
            class="post-tag no-text-decoration" >cryptography</a>
          
          <a href="/tags/web-security/"
            class="post-tag no-text-decoration" >web_security</a>
          
          <a href="/tags/programming/"
            class="post-tag no-text-decoration" >programming</a>
          
          </div>
        

        <div class="post-tail-bottom
          d-flex justify-content-between align-items-center mt-3 pt-5 pb-2">
          
          <div class="license-wrapper">
            This post is licensed under
            <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a>
            by the author.
          </div>
          

          <!--
 Post sharing snippet
-->

<div class="share-wrapper">
  <span class="share-label text-muted mr-1">Share</span>
  <span class="share-icons">
    
    

    
      
        <a href="https://twitter.com/intent/tweet?text=H@CktivityCon 2021 CTF Writeups - Bernard Smith&url=https://bernardsmith0892.github.io/posts/Hacktivity2021/" data-toggle="tooltip" data-placement="top"
          title="Twitter" target="_blank" rel="noopener" aria-label="Twitter">
          <i class="fa-fw fab fa-twitter"></i>
        </a>
    
      
        <a href="https://www.facebook.com/sharer/sharer.php?title=H@CktivityCon 2021 CTF Writeups - Bernard Smith&u=https://bernardsmith0892.github.io/posts/Hacktivity2021/" data-toggle="tooltip" data-placement="top"
          title="Facebook" target="_blank" rel="noopener" aria-label="Facebook">
          <i class="fa-fw fab fa-facebook-square"></i>
        </a>
    
      
        <a href="https://www.linkedin.com/sharing/share-offsite/?url=https://bernardsmith0892.github.io/posts/Hacktivity2021/" data-toggle="tooltip" data-placement="top"
          title="Linkedin" target="_blank" rel="noopener" aria-label="Linkedin">
          <i class="fa-fw fab fa-linkedin"></i>
        </a>
    

    <i class="fa-fw fas fa-link small" onclick="copyLink()"
        data-toggle="tooltip" data-placement="top" title="Copy link"></i>

  </span>
</div>


        </div><!-- .post-tail-bottom -->

      </div><!-- div.post-tail -->

    </div> <!-- .post -->


  </div> <!-- #post-wrapper -->

  

  

  <!--
  The Pannel on right side (Desktop views)
-->

<div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down">

  <div class="access">

  














  

  















  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
      
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
      
    
  
    
    
    
    
      
    
  
    
    
    
    
      
        
        



  
    <div id="access-tags">
      <span>Trending Tags</span>
      <div class="d-flex flex-wrap mt-3 mb-1 mr-3">

      
        
        <a class="post-tag" href="/tags/cryptography/">cryptography</a>
      
        
        <a class="post-tag" href="/tags/programming/">programming</a>
      
        
        <a class="post-tag" href="/tags/reverse-engineering/">reverse_engineering</a>
      
        
        <a class="post-tag" href="/tags/web-security/">web_security</a>
      

      </div>
    </div>
  
  </div> <!-- .access -->

  
    <!-- BS-toc.js will be loaded at medium priority -->
    <script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script>
    <div id="toc-wrapper" class="pl-0 pr-4 mb-5">
      <span class="pl-3 pt-2 mb-2">Contents</span>
      <nav id="toc" data-toggle="toc"></nav>
    </div>
  

</div> <!-- #panel-wrapper -->


</div> <!-- .row -->

<div class="row">
  <div class="col-12 col-lg-11 col-xl-8">
    <div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4">

    <!--
 Recommend the other 3 posts according to the tags and categories of the current post,
 if the number is not enough, use the other latest posts to supplement.
-->

<!-- The total size of related posts  -->


<!-- An random integer that bigger than 0  -->


<!-- Equals to TAG_SCORE / {max_categories_hierarchy}  -->








  

  
    
  

  

  

  

  

  


  

  

  

  

  

  


  

  

  

  

  

  


  

  

  

  

  

  


  

  

  

  

  

  


  

  

  

  

  

  








<!-- Fill with the other newlest posts  -->






  <div id="related-posts" class="mt-5 mb-2 mb-sm-4">
    <h3 class="pt-2 mt-1 mb-4 ml-1"
      data-toc-skip>Further Reading</h3>
    <div class="card-deck mb-4">
    
      
      
      <div class="card">
        <a href="/posts/acictf4-rotateme/">
          <div class="card-body">
            <!--
  Date format snippet
  See: /assets/js/_utils/timeage.js
-->





<span class="timeago small"
  

  
   >

  
  

  
    13 May 2020
  

  <i class="unloaded">2020-05-13T00:00:00-10:00</i>

</span>

            <h3 class="pt-0 mt-1 mb-3" data-toc-skip>All-Army CyberStakes 4 - Cryptography (Rotate Me)</h3>
            <div class="text-muted small">
              <p>
                





                Rotate Me (5 Points)

This one is a very simple problem, especially considering it’s only worth 5 points. We start with a text file that contains enciphered text, which already seems to be in the e...
              </p>
            </div>
          </div>
        </a>
      </div>
    
      
      
      <div class="card">
        <a href="/posts/acictf4-rsa/">
          <div class="card-body">
            <!--
  Date format snippet
  See: /assets/js/_utils/timeage.js
-->





<span class="timeago small"
  

  
   >

  
  

  
    14 May 2020
  

  <i class="unloaded">2020-05-14T01:00:00-10:00</i>

</span>

            <h3 class="pt-0 mt-1 mb-3" data-toc-skip>All-Army CyberStakes 4 - Cryptography (Really Senseless Admins)</h3>
            <div class="text-muted small">
              <p>
                





                Really Senseless Admins (35 Points)

Here, we are provided with two files: flag.enc, containing a very large decimal number, and params.txt, containing three decimal numbers, p, q, and e. Based on ...
              </p>
            </div>
          </div>
        </a>
      </div>
    
      
      
      <div class="card">
        <a href="/posts/acictf4-otp/">
          <div class="card-body">
            <!--
  Date format snippet
  See: /assets/js/_utils/timeage.js
-->





<span class="timeago small"
  

  
   >

  
  

  
    15 May 2020
  

  <i class="unloaded">2020-05-15T02:00:00-10:00</i>

</span>

            <h3 class="pt-0 mt-1 mb-3" data-toc-skip>All-Army CyberStakes 4 - Cryptography (Over Time: Paid)</h3>
            <div class="text-muted small">
              <p>
                





                Over Time: Paid (50 Points)

This is where the challenges start getting more difficult. This problem starts with two files again: document.encrypted, which contains 15 lines of hex, and source.py, ...
              </p>
            </div>
          </div>
        </a>
      </div>
    
    </div> <!-- .card-deck -->
  </div> <!-- #related-posts -->



    <!--
  Navigation buttons at the bottom of the post.
-->

<div class="post-navigation d-flex justify-content-between">
  
  <a href="/posts/hackasat2-forest/" class="btn btn-outline-primary"
    prompt="Older">
    <p>Hack-A-Sat 2: tree in the forest</p>
  </a>
  

  
  <span class="btn btn-outline-primary disabled"
    prompt="Newer">
    <p>-</p>
  </span>
  

</div>


    

    </div> <!-- #post-extend-wrapper -->

  </div> <!-- .col-* -->

</div> <!-- .row -->



        <!--
  The Footer
-->

<footer class="d-flex w-100 justify-content-center">
  <div class="d-flex justify-content-between align-items-center">
    <div class="footer-left">
      <p class="mb-0">
        © 2021
        <a href="https://twitter.com/BernardSmith892">Bernard Smith</a>.
        
        <span data-toggle="tooltip" data-placement="top"
          title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span>
        
      </p>
    </div>

    <div class="footer-right">
      <p class="mb-0">
        Powered by
        <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a>
        with
        <a href="https://github.com/cotes2020/jekyll-theme-chirpy"
          target="_blank" rel="noopener">Chirpy</a>
        theme.
      </p>
    </div>

  </div> <!-- div.d-flex -->
</footer>


      </div>

      <!--
  The Search results
-->
<div id="search-result-wrapper" class="d-flex justify-content-center unloaded">
  <div class="col-12 col-sm-11 post-content">
    <div id="search-hints">
      <h4 class="text-muted mb-4">Trending Tags</h4>

      















  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
      
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
      
    
  
    
    
    
    
      
    
  
    
    
    
    
      
        
        



      
        
        <a class="post-tag" href="/tags/cryptography/">cryptography</a>
      
        
        <a class="post-tag" href="/tags/programming/">programming</a>
      
        
        <a class="post-tag" href="/tags/reverse-engineering/">reverse_engineering</a>
      
        
        <a class="post-tag" href="/tags/web-security/">web_security</a>
      

    </div>
    <div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div>
  </div>
</div>


    </div> <!-- #main-wrapper -->

    

    <div id="mask"></div>

    <a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button">
      <i class="fas fa-angle-up"></i>
    </a>

    <!--
  Jekyll Simple Search loader
  See: <https://github.com/christian-fei/Simple-Jekyll-Search>
-->





<script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script>

<script>
SimpleJekyllSearch({
  searchInput: document.getElementById('search-input'),
  resultsContainer: document.getElementById('search-results'),
  json: '/assets/js/data/search.json',
  searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0">  <a href="https://bernardsmith0892.github.io{url}">{title}</a>  <div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1">    {categories}    {tags}  </div>  <p>{snippet}</p></div>',
  noResultsText: '<p class="mt-5">Oops! No result founds.</p>',
  templateMiddleware: function(prop, value, template) {
    if (prop === 'categories') {
      if (value === '') {
        return `${value}`;
      } else {
        return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`;
      }
    }

    if (prop === 'tags') {
      if (value === '') {
        return `${value}`;
      } else {
        return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`;
      }
    }
  }
});
</script>


  </body>

</html>

