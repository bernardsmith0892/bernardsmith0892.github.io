[
  
  {
    "title": "H@cktivityCon 2021 CTF Writeups",
    "url": "/posts/Hacktivity2021/",
    "categories": "CTF, H@cktivity2021",
    "tags": "cryptography, web_security, programming",
    "date": "2021-09-19 18:01:00 -1000",
    





    "snippet": "Had a lot of fun with this CTF and it’s always nice to see my amateur radio and infosec hobbies mixing together. Actually got around to doing a writeup this year too! I sometimes wonder if I should ever try joining a team for one of these, instead of always competing as a “solo” team. Maybe I’d do better than hovering around top 10% every time.WarmupsSix Four Over Two (50 points)We are provided with a short text file containing the string: EBTGYYLHPNQTINLEGRSTOMDCMZRTIMBXGY2DKMJYGVSGIOJRGE2GMOLDGBSWM7IK. Based on the name of the challenge, this could potentially be a Base32-encoded string. (Because \\(\\frac{64}{2} = 32\\)) We test our theory using CyberChef and immediately get the flag: flag{a45d4e70bfc407645185dd9114f9c0ef}Bass64 (50 points)We are provided with another text file, this time containing what appears to be a garbled mess of lines. However, simply disabling word wrap in Notepad allows us to see that it’s just ASCII word art for the string IGZsYWd7MzVhNWQxM2RhNmEyYWZhMGM2MmJmY2JkZDYzMDFhMGF9. Because it’s a relatively short string and I don’t know of anything that can convert from ASCII art back to text, we just manually parse and copy the text. ___ ____ _____  __   ____        __  _ _____ __  __    __     ___     _   _ __        _____        __  __ ____  ____  _     _   _           _____      __   ____        ________     __  __  ____ __  __ ____  __  __               _         __   ______     _ _     ____ _______   __   __  __ ____  _____ _      __  __  ____ _____ ___  |_ _/ ___|__  /__\\ \\ / /\\ \\      / /_| |___  |  \\/  |___\\ \\   / / |__ | \\ | |\\ \\      / / _ \\ __  _|  \\/  |___ \\|  _ \\| |__ | \\ | |_ __ ___ | ____|   _ \\ \\ / /\\ \\      / /__  / |__ |  \\/  |/ ___|  \\/  |___ \\|  \\/  |_ __ ___     | | _ __ __\\ \\ / /___ \\   | | | __|__  /|  _ \\ \\ / /__|  \\/  |  _ \\|  ___| |__  |  \\/  |/ ___|  ___/ _ \\  | | |  _  / // __\\ V /  \\ \\ /\\ / / _` |  / /| |\\/| |_  /\\ \\ / /| &#39;_ \\|  \\| | \\ \\ /\\ / / | | |\\ \\/ / |\\/| | __) | |_) | &#39;_ \\|  \\| | &#39;_ ` _ \\|  _|| | | | \\ V /  \\ \\ /\\ / /  / /| &#39;_ \\| |\\/| | |  _| |\\/| | __) | |\\/| | &#39;_ ` _ \\ _  | || &#39;_ ` _ \\ V /  __) |  | | |/ /  / / | | | \\ V /_  / |\\/| | | | | |_  | &#39;_ \\ | |\\/| | |  _| |_ | (_) | | | |_| |/ /_\\__ \\| |    \\ V  V / (_| | / / | |  | |/ /  \\ V / | | | | |\\  |  \\ V  V /| |_| | &amp;gt;  &amp;lt;| |  | |/ __/|  _ &amp;lt;| | | | |\\  | | | | | | |__| |_| |  | |    \\ V  V /  / /_| | | | |  | | |_| | |  | |/ __/| |  | | | | | | | |_| || | | | | | |  / __/ |_| |   &amp;lt;  / /_ | |_| || | / /| |  | | |_| |  _| | | | || |  | | |_| |  _| \\__, ||___\\____/____|___/|_|     \\_/\\_/ \\__,_|/_/  |_|  |_/___|  \\_/  |_| |_|_| \\_|   \\_/\\_/  \\__\\_\\/_/\\_\\_|  |_|_____|_| \\_\\_| |_|_| \\_|_| |_| |_|_____\\__, |  |_|     \\_/\\_/  /____|_| |_|_|  |_|\\____|_|  |_|_____|_|  |_|_| |_| |_|\\___/ |_| |_| |_|_| |_____\\___/|_|\\_\\/____ |____/ |_|/___|_|  |_|____/|_|   |_| |_||_|  |_|\\____|_|     /_/                                                                                                                                                   |___/                                                                                                                                                                                      Based on both the challenge name and the format of the string, we can assume that this is a Base64-encoded string. Putting this into CyberChef gives us the flag: flag{35a5d13da6a2afa0c62bfcbdd6301a0a}Pimple (50 points)This one is pretty simple. Using file on attachment shows that it’s a GIMP file. Then after opening the file in GIMP and looking through the content, we find the flag printed on one of the inner layers: flag{9a64bc4a390cb0ce31452820ee562c3f}$ file pimplepimple: GIMP XCF image data, version 011, 1024 x 1024, RGB ColorTsunami (50 points)Using file again, we discover that this is a .wav file.$ file tsunamitsunami: RIFF (little-endian) data, WAVE audio, Microsoft PCM, 16 bit, stereo 44100 HzThe end of the audio is a series of tones that makes me think it’s spectrogram steganography. After finding a website that let’s us view the spectrogram of an audio file(Academo), we see that those series of tones make up the flag value: flag{f8fbb2c761821d3af23859f721cc140b}. If it’s hard to make out the flag yourself, just remember that all of the letters are lowercase so they can’t be confused with a number.Butter Overflow (50 points)This time we’re provided with three files.  An executable file: butter_overflow  The source code of the executable: source.c  A Makefile we can use to compile the source code ourselvesAfter examining the source code, we discover the following information about the program’s behavior:  Line 43 - Creates a buffer array that can store up to 512 bytes  Line 51 - Directly saves user input into this buffer, without size checks  Lines 48 &amp;amp; 10 - Runs the give_flag() function if there’s a segmentation faultSo the solution is simple, if we provide enough input to the program to cause a buffer overflow, it’ll trigger a segmentation fault and give us the flag. Sure enough, sending 600 A’s to the challenge server prints out the flag: flag{72d8784a5da3a8f56d2106c12dbab989}Oddball (103 points)Funnily enough, this warmup challenge ended up being worth more than some of the “real” challenges. Here, we are given an oddball file containing several lines of numbers.0000000 067531 020165 067165 067543 062566 062562 020144 0641640000020 020145 062563 071143 072145 066440 071545 060563 0625470000040 035440 005051 072516 061155 071145 020163 067151 0710400000060 067141 062547 030040 033455 020077 066510 066555 0200410000100 067510 020167 062157 005041 063012 060554 075547 0604620000120 031065 061462 033062 034143 060467 031546 034461 0610620000140 031064 031543 063064 031544 033062 034063 061065 0051750000160After analyzing the file for a bit, we realize that there are no numbers greater than 7, so the file must be a list of octal numbers. As it turns out, the famous xxd tool has a lesser known uncle called od. But rather than hexdumps, this program creates octal dumps of files in the exact same format as the oddball file. Unfortunately, od doesn’t appear to have a reversal function like xxd does, so we have to make one ourselves. After taking out the first column of numbers, we can use the following python3 script to decode oddball.from pwn import *oct = &quot;&quot;&quot;067531 020165 067165 067543 062566 062562 020144 064164 020145 062563 071143 072145066440 071545 060563 062547 035440 005051 072516 061155 071145 020163 067151 071040 067141062547 030040 033455 020077 066510 066555 020041 067510 020167 062157 005041 063012 060554075547 060462 031065 061462 033062 034143 060467 031546 034461 061062 031064 031543 063064031544 033062 034063 061065 005175&quot;&quot;&quot;.split()for num in oct:    # Decodes the octal string into its byte form    # ^──────────────┐    # Reverses the endianess of the byte so it prints correctly    # ^────┐         |    # Decodes the byte into a printable string    # ^────|─────────|───────┐    #      V         V       V    print(p16(int(num, 8)).decode(&#39;utf-8&#39;), end=&#39;&#39;) Running this script provides us with the following output containing the flag:You uncovered the secret message ;)Numbers in range 0-7? Hmmm! How od!flag{2a522c26c87af3192b42c34fd326385b}WebConfidentiality (50 points)This challenge involves a simple command injection vulnerability. We’re provided with a web application that gives us the ability to check the access control settings for any given file on the server. To start, we test it out with a known file, /etc/passwd.These results seem eerily similar to what ls -l does. It appears that the application is simply taking our input and appending it to an ls -l command. So if we wanted to see the files in our current directory, we could provide it with a period (.). Of course, we would normally just run ls -l on its own for the same effect, but the application rejects an empty input.This is the exact output we would expect from an ls -l . command. So our goal now is to output the contents of the flag.txt file within this directory. To verify our command injection capabilities, we can use the ; character to append a second command to this line. By sending a request for ; whoami, we predict that the server will run the command ls -l ; whoami, showing us the current directory and username.Success! This shows us that we have the ability to execute commands on the server. Now we just need to send a ; cat flag.txt request to output the flag, which ends up being: flag{e56abbce7b83d62dac05e59fb1e81c68}Bonus: If we wanted to, we can also see the source code for the application itself. A ; cat main.py request outputs the contents of main.py and shows how the application operates. And exactly how we predicted, the application is simply appending our input to the end of an ls -l command, without any verification or sanitization.Titanic (50 points)This challenge involves leveraging a server-side request forgery (SSRF) to access sensitive, internal information. The website contains two main features that we will use: an admin login page and a URL capturer service.The admin login is fairly normal. Since we obviously don’t have any admin credentials, we cannot make real use of this section right now. However, one thing of note about this page is the unique way it sends login attempts. Normally, logins would be sent as a POST request, with the username and password in the body. But here, the login attempt is made as a GET request, with the username and password in the URL. A username and password of test:test is performed with the URL http://challenge.ctf.games:31971/admin.php?uname=test&amp;amp;psw=test. While this behavior isn’t particularly useful to us right now, it will become very important later on.Moving on to the URL capturer service. This service simply takes the URL we provide, makes a request to that URL on our behalf, and gives back a screenshot of the webpage. This service can allow us to perform an SSRF to disclose sensitive, local information on the server. It’s actually difficult to really call it an SSRF vulnerability because it’s clearly intended behavior. But to first validate that we can use it for SSRF, we will make a request to http://localhost and verify that we receive the same webpage.The request is successful! We receive back the loading circle for the website, showing that it is successfully making a request to http://localhost. As far as how to use it though, the robots.txt file for the website points to the /server-status page as an option. When we make a request to that page ourselves, it gives back a 403 Forbidden error. However, if we ask the server to request it locally at http://localhost/server-status, we get back the full status page for this webserver.Remember how login attempts are made as a GET request? Because of that, now we can clearly see a username and password for a previously successful login attempt: root:EYNDR4NhadwX9rtef. Using these credentials, we can access the admin page and retrieve the flag: flag{88269d5ef52a5ee961ea6449e1b610a9}.CryptographyN1TP (50 Points)This challenge is deceptively simple. When we first connect to the server, “Nina” provides us with the ciphertext of the flag. We should also note that the ciphertext changes between connections. After this, they give us the option to provide our own plaintext to see the resulting ciphertext. While providing the ciphertext, Nina also confirms that we’re dealing with a one-time pad (OTP).Nina is correct in saying that OTPs are unbreakable. However, this is with the giant caveat that the OTP is used correctly. If you were to ever reuse a OTP’s key, like what Nina is doing here, it gives an attacker an opportunity to break the encryption. Even worse, if you reuse the key on plaintext that the attacker already knows, that OTP is completely broken.The reason for this is that a OTP uses the exclusive OR (XOR) operation to perform its encryption and decryption. Normal use of an XOR (\\(\\oplus\\)) cipher goes like this:\\[\\textbf{Encryption: } \\text{Plaintext} \\oplus \\text{Key} = \\text{Ciphertext}\\]\\[\\textbf{Decryption: } \\text{Ciphertext} \\oplus \\text{Key} = \\text{Plaintext}\\]However, we if know the plaintext and ciphertext of a message, we can also compute the key using the properties of the XOR operation.\\[\\text{Plaintext} \\oplus \\text{Ciphertext} = \\text{Key}\\]So using this principle, we can perform a known-plaintext attack on Nina’s OTP to derive the key. Our first step is to encrypt a plaintext value the same length of the flag. For this, we will choose 00000000000000000000000000000000000000.After receiving back the ciphertext for this message, we can XOR the plaintext and ciphertext together to determine the OTP key using CyberChef. Finally, we can XOR the flag’s ciphertext and the key together to reveal the flag in plaintext: flag{9276cdb76a3dd6b1f523209cd9c0a11b}.MiscellaniousBad Words (50 points)This challenge generously gives us a bash shell on the server at the jump. The catch is that we’re placed into an extremely restrictive jailshell. If we attempt to use many of our common commands, such as ls, id, and whoami, the shell yells at us for using a “bad word”. Thankfully after testing several options, we finally have success with the command /bin/sh -i. This breaks us out of the jailshell and drops us into a non-restricted sh shell. A few ls commands reveals the path to the flag file in ~/just/out/of/reach/flag.txt, which we can cat to retrieve the flag: flag{2d43e30a358d3f30fe65cc47a9cbbe98}.If you want to know how the jailshell works, its code is contained within the .bashrc file. It defines a bad_words() function that compares each argument in a user’s commands against a list of “bad words”. Then using the trap &#39;bad_words&#39; DEBUG command, it forces this function to run before any command is executed by the user. If one of the arguments matches one of the bad words, it stops the user’s command from running. However, we are able to get past it because it only checks for bad words starting from the beginning of the argument. This is because of the regex they’re using for matching (^$i.*). The ^ character anchors the match to only from the beginning of the string. So although sh is a bad word, /bin/sh goes undetected because the preceding /bin/ breaks the match.shopt -s extdebugfunction bad_words() {    declare -a arr=(&quot;alert&quot; &quot;egrep&quot; &quot;fgrep&quot; &quot;grep&quot; &quot;l&quot; &quot;la&quot; &quot;ll&quot; &quot;ls&quot; [...snip...] &quot;less&quot; &quot;lessecho&quot; &quot;flag&quot; &quot;root&quot;)    for i in &quot;${arr[@]}&quot;    do        if [[ &quot;$BASH_COMMAND&quot; =~ ^$i.* ]]; then            echo &quot;You said a bad word, \\&quot;$i\\&quot;!!&quot;            return 1;        fi;    done    return;}trap &#39;bad_words&#39; DEBUGOSINTJed Sheeran (50 points)This challenge asks us to look for an aspiring music artist named Jed Sheeran. The actual discovery process is simple because a Google search for “Jed Sheeran” puts his SoundCloud as the first result. Jed’s profile has one song that contains a mess of beeps and squeaks.This sound is actually a Slow-Scan Television (SSTV) signal, a method to transmit images as an analog signal. SSTV is popular within the amateur radio community particularly because it’s a way to send and receive images using very little bandwidth. It’s also common to see this in augmented reality games (ARG) or easter eggs as a way to hide pictures, like here in Portal 2. So to retrieve the flag from this audio file, all we need to do is decode the SSTV signal it’s playing.One way to do it is to download an SSTV decoder app like Robot36 and hold your phone’s microphone up to your computer speakers. But you need to keep in mind that SSTV is an analog signal. So any noise in the signal will cause us to receive a degraded image. The more noise, the worse the image looks. However, we could use a something called a virtual audio cable, such as VB-CABLE, to connect our browser’s audio directly to an SSTV decoder program, like RX-SSTV. This will theoretically send the SSTV signal directly from SoundCloud to our decoder without any noise.Well… the flag is clearly there, but it’s extremely hard to decipher. A lot of things could be happening here. SoundCloud could be compressing the SSTV audio before it’s stored, causing additional distortion in our image. It could also be that the flag’s text is too small for this SSTV mode. SSTV isn’t exactly known for sending extremely clear images, even in a perfect world. So people normally use bigger text in an image to compensate for that or switch to a more “robust” SSTV mode. The Jed Sheeran signal appears to be using the Robot 36 mode and is about 36 seconds long. Compare this to the following SSTV image I picked up from the International Space Station that uses PD120 and is about 120 seconds long. It has text about the same size as the Jed Sheeran signal, but this time it’s actually intelligible. Keep in mind that I received this signal from space, as well.So where do we go from here? We could try really hard to determine what each character is. But, it seems that the challenge creator recognized how hard this was and decided to just put the flag in the song’s description: flag{59e56590445321ccefb4d91bba61f16c}.ScriptingWords Church (407 points)It appears that people either don’t like scripting or just don’t know how to script because these challenges ended up being worth a lot of points. The description tells us we’ll have to solve 30 word searches, so let’s connect to the server and see what we’re dealing with.It looks fairly simple. We’re provided with a \\(15 \\times 15\\) grid of characters and five words to find. The biggest challenge is really going to be how to parse everything. pwntools makes the sending and receiving part of the challenge easy, so all we have to worry about is how to process the information. The following python3 script let’s use receive the grid used for the game:from pwn import *io = remote(&#39;challenge.ctf.games&#39;, 32497)io.recvuntil(&#39;&amp;gt;&#39;)io.send(&#39;play&#39;)# Header linesio.recvlines(3)# Grid lines io.recvlines(16)# Trailing linesio.recvlines(2)After putting this into the python3 interpreter, we verify that we’re correctly aligned to process the grid.Python 3.9.2 (default, Feb 28 2021, 17:03:44)[GCC 10.2.1 20210110] on linuxType &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&amp;gt;&amp;gt;&amp;gt; from pwn import *&amp;gt;&amp;gt;&amp;gt; io = remote(&#39;challenge.ctf.games&#39;, 32497)(&#39;&amp;gt;&#39;)io.send(&#39;play&#39;)[x] Opening connection to challenge.ctf.games on port 32497[x] Opening connection to challenge.ctf.games on port 32497: Trying 34.122.187.139[+] Opening connection to challenge.ctf.games on port 32497: Done&amp;gt;&amp;gt;&amp;gt; io.recvuntil(&#39;&amp;gt;&#39;)b&quot;Words Church v1.0\\n\\nLet&#39;s play a game of wordsearch! We will display the grid\\nand offer you words to find. Please submit the locations of\\neach word in the format [(X,Y), (X,Y), (X,Y), ...] for each letter.\\n\\nPlease enter &#39;example&#39; if you would like to see an \\nexample, or &#39;play&#39; if you would like to get started.\\n&amp;gt;&quot;&amp;gt;&amp;gt;&amp;gt; io.send(&#39;play&#39;)&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; # Headers&amp;gt;&amp;gt;&amp;gt; io.recvlines(3)[b&#39; Wordsearch # 1/30:&#39;, b&#39;\\t 0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15 : X&#39;, b&#39;\\t--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---&#39;]&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; # Grid lines&amp;gt;&amp;gt;&amp;gt; io.recvlines(16)[b&#39; 0  | \\t L   P   U   C   E   U   N   K   F   C   A   Q   T   Q   S   H &#39;, b&#39; 1  | \\t Q   L   Q   Q   K   E   S   P   U   V   A   W   X   T   M   E &#39;, b&#39; 2  | \\t E   G   O   U   H   O   U   A   Q   D   S   K   Z   M   T   Y &#39;, b&#39; 3  | \\t L   Z   S   I   F   O   S   U   J   S   S   E   N   A   O   V &#39;, b&#39; 4  | \\t I   S   M   V   D   Y   B   B   U   G   U   O   N   J   D   J &#39;, b&#39; 5  | \\t S   J   Q   E   T   N   L   A   V   K   R   K   Z   W   S   I &#39;, b&#39; 6  | \\t C   P   C   R   Y   S   E   L   K   D   E   P   S   X   A   L &#39;, b&#39; 7  | \\t Q   Q   T   E   W   F   Z   L   I   M   D   E   U   S   C   O &#39;, b&#39; 8  | \\t T   G   L   D   N   N   T   Y   J   K   I   S   Y   L   S   B &#39;, b&#39; 9  | \\t N   E   Q   J   I   I   X   H   S   K   B   L   K   O   H   S &#39;, b&#39; 10 | \\t V   K   M   I   U   V   U   O   K   S   K   T   Y   E   I   T &#39;, b&#39; 11 | \\t I   M   N   F   G   V   S   O   Z   O   S   H   R   T   T   E &#39;, b&#39; 12 | \\t H   F   Y   K   F   S   Q   S   Z   J   I   I   Z   T   J   R &#39;, b&#39; 13 | \\t H   U   X   E   T   R   Y   N   R   Z   J   M   Z   S   U   S &#39;, b&#39; 14 | \\t F   R   B   D   P   Z   K   P   K   U   N   G   A   Q   Y   O &#39;, b&#39; 15 | \\t M   S   O   T   B   F   R   P   F   R   R   P   M   M   Z   T &#39;]&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; # Trailing lines&amp;gt;&amp;gt;&amp;gt; io.recvlines(2)[b&#39; ---&#39;, b&#39;  Y &#39;]Translating the grid into a 2D-array is fairly trivial. All we have to do is split each line on whitespace to get a list of all characters, and then skip the first two characters that contain the Y coordinate and | separator. The following code does this for us:# Process grid linesfor _ in range(16):  # Decode the input from a bytestring into a normal string  # ^─────────────────────────┐  # Split the string on whitespace, returning a list of each  # ^    character in the string  # └─────────────────────────│───────────────┐  # Skip the first two characters in the new list  # ^─────────────────────────│───────────────│──────┐  grid.append( io.recvline().decode(&#39;utf-8&#39;).split()[2:] )# Test gridprint(grid)# Output&quot;&quot;&quot;[[&#39;L&#39;, &#39;P&#39;, &#39;U&#39;, &#39;C&#39;, &#39;E&#39;, &#39;U&#39;, &#39;N&#39;, &#39;K&#39;, &#39;F&#39;, &#39;C&#39;, &#39;A&#39;, &#39;Q&#39;, &#39;T&#39;, &#39;Q&#39;, &#39;S&#39;, &#39;H&#39;], [&#39;Q&#39;, &#39;L&#39;, &#39;Q&#39;, &#39;Q&#39;, &#39;K&#39;, &#39;E&#39;, &#39;S&#39;, &#39;P&#39;, &#39;U&#39;, &#39;V&#39;, &#39;A&#39;, &#39;W&#39;, &#39;X&#39;, &#39;T&#39;, &#39;M&#39;, &#39;E&#39;], [&#39;E&#39;, &#39;G&#39;, &#39;O&#39;, &#39;U&#39;, &#39;H&#39;, &#39;O&#39;, &#39;U&#39;, &#39;A&#39;, &#39;Q&#39;, &#39;D&#39;, &#39;S&#39;, &#39;K&#39;, &#39;Z&#39;, &#39;M&#39;, &#39;T&#39;, &#39;Y&#39;], [&#39;L&#39;, &#39;Z&#39;, &#39;S&#39;, &#39;I&#39;, &#39;F&#39;, &#39;O&#39;, &#39;S&#39;, &#39;U&#39;, &#39;J&#39;, &#39;S&#39;, &#39;S&#39;, &#39;E&#39;, &#39;N&#39;, &#39;A&#39;, &#39;O&#39;, &#39;V&#39;], [&#39;I&#39;, &#39;S&#39;, &#39;M&#39;, &#39;V&#39;, &#39;D&#39;, &#39;Y&#39;, &#39;B&#39;, &#39;B&#39;, &#39;U&#39;, &#39;G&#39;, &#39;U&#39;, &#39;O&#39;, &#39;N&#39;, &#39;J&#39;, &#39;D&#39;, &#39;J&#39;], [&#39;S&#39;, &#39;J&#39;, &#39;Q&#39;, &#39;E&#39;, &#39;T&#39;, &#39;N&#39;, &#39;L&#39;, &#39;A&#39;, &#39;V&#39;, &#39;K&#39;, &#39;R&#39;, &#39;K&#39;, &#39;Z&#39;, &#39;W&#39;, &#39;S&#39;, &#39;I&#39;], [&#39;C&#39;, &#39;P&#39;, &#39;C&#39;, &#39;R&#39;, &#39;Y&#39;, &#39;S&#39;, &#39;E&#39;, &#39;L&#39;, &#39;K&#39;, &#39;D&#39;, &#39;E&#39;, &#39;P&#39;, &#39;S&#39;, &#39;X&#39;, &#39;A&#39;, &#39;L&#39;], [&#39;Q&#39;, &#39;Q&#39;, &#39;T&#39;, &#39;E&#39;, &#39;W&#39;, &#39;F&#39;, &#39;Z&#39;, &#39;L&#39;, &#39;I&#39;, &#39;M&#39;, &#39;D&#39;, &#39;E&#39;, &#39;U&#39;, &#39;S&#39;, &#39;C&#39;, &#39;O&#39;], [&#39;T&#39;, &#39;G&#39;, &#39;L&#39;, &#39;D&#39;, &#39;N&#39;, &#39;N&#39;, &#39;T&#39;, &#39;Y&#39;, &#39;J&#39;, &#39;K&#39;, &#39;I&#39;, &#39;S&#39;, &#39;Y&#39;, &#39;L&#39;, &#39;S&#39;, &#39;B&#39;], [&#39;N&#39;, &#39;E&#39;, &#39;Q&#39;, &#39;J&#39;, &#39;I&#39;, &#39;I&#39;, &#39;X&#39;, &#39;H&#39;, &#39;S&#39;, &#39;K&#39;, &#39;B&#39;, &#39;L&#39;, &#39;K&#39;, &#39;O&#39;, &#39;H&#39;, &#39;S&#39;], [&#39;V&#39;, &#39;K&#39;, &#39;M&#39;, &#39;I&#39;, &#39;U&#39;, &#39;V&#39;, &#39;U&#39;, &#39;O&#39;, &#39;K&#39;, &#39;S&#39;, &#39;K&#39;, &#39;T&#39;, &#39;Y&#39;, &#39;E&#39;, &#39;I&#39;, &#39;T&#39;], [&#39;I&#39;, &#39;M&#39;, &#39;N&#39;, &#39;F&#39;, &#39;G&#39;, &#39;V&#39;, &#39;S&#39;, &#39;O&#39;, &#39;Z&#39;, &#39;O&#39;, &#39;S&#39;, &#39;H&#39;, &#39;R&#39;, &#39;T&#39;, &#39;T&#39;, &#39;E&#39;], [&#39;H&#39;, &#39;F&#39;, &#39;Y&#39;, &#39;K&#39;, &#39;F&#39;, &#39;S&#39;, &#39;Q&#39;, &#39;S&#39;, &#39;Z&#39;, &#39;J&#39;, &#39;I&#39;, &#39;I&#39;, &#39;Z&#39;, &#39;T&#39;, &#39;J&#39;, &#39;R&#39;], [&#39;H&#39;, &#39;U&#39;, &#39;X&#39;, &#39;E&#39;, &#39;T&#39;, &#39;R&#39;, &#39;Y&#39;, &#39;N&#39;, &#39;R&#39;, &#39;Z&#39;, &#39;J&#39;, &#39;M&#39;, &#39;Z&#39;, &#39;S&#39;, &#39;U&#39;, &#39;S&#39;], [&#39;F&#39;, &#39;R&#39;, &#39;B&#39;, &#39;D&#39;, &#39;P&#39;, &#39;Z&#39;, &#39;K&#39;, &#39;P&#39;, &#39;K&#39;, &#39;U&#39;, &#39;N&#39;, &#39;G&#39;, &#39;A&#39;, &#39;Q&#39;, &#39;Y&#39;, &#39;O&#39;], [&#39;M&#39;, &#39;S&#39;, &#39;O&#39;, &#39;T&#39;, &#39;B&#39;, &#39;F&#39;, &#39;R&#39;, &#39;P&#39;, &#39;F&#39;, &#39;R&#39;, &#39;R&#39;, &#39;P&#39;, &#39;M&#39;, &#39;M&#39;, &#39;Z&#39;, &#39;T&#39;]]&quot;&quot;&quot;The next step is to determine how to receive the words we need to search for. After we receive the grid lines, the questions are sent to us in the following format: LIEU: &amp;gt; . All we need to do here is extract the word, which is very easy to do using split() again.# Receive input until we hit the &#39;&amp;gt;&#39; characterquestion = io.recvuntil(&#39;&amp;gt;&#39;).decode(&#39;utf-8&#39;)# Split the line on the &#39;:&#39; character and take everything before the &#39;:&#39;word = question.split(&#39;:&#39;)[0].strip()Now that we have our grid and words in a format we can process, it’s time to create the searching functions. While I’m sure there are super fast algorithms specifically designed to solve this problem, we’re going to stick with the naïve solution: go through every coordinate that matches the first letter of the word and search out from all eight directions to see if the rest of it matches. Here we have two components to design, the function to search through the entire grid, and the function to search out from a position to determine if the word matches. I’ve implemented them both in python3, as seen below:# Search from a given (x,y) position out a given direction#   and return the positions of matching characters.#   Returns an empty list `[]` if the match fails.def direction_search(word, grid, x, y, x_delta, y_delta):    tiles = []    for c in word:        # If this tile doesn&#39;t match the current character,        #   return an empty list.         # The position also wraps around the edges of the grid.        if grid[y % len(grid)][x % len(grid)] != c:            return []        else:            # If we&#39;re still matching, add this position as an            #   (x, y) tuple to the position list.            tiles.append( (x, y) )        # Move in the given direction        y += y_delta        x += x_delta    return tiles# Search each tile in the grid and determine if the word is found#   in any 8 directions from each tile.# Returns list of positions if the word is found, empty list `[]`,#   if not.def word_search(word, grid):    for (y, row) in enumerate(grid):        for (x, tile) in enumerate(row):            # If this tile matches the first letter of the word, then            #   check if the rest of the word is found in any of the             #   8 directions from this position.            if tile == word[0]:                for x_delta in [-1, 0, 1]:                    for y_delta in [-1, 0, 1]:                        search = direction_search(word, x, y, grid, x_delta, y_delta)                        if len(search) &amp;gt; 0:                            return search    return []Finally, we can combine all of these elements in the final script and run it to solve the challenge to receive the flag: flag{ac670e1f34da9eb748b3f241eb03f51b}.#!/usr/bin/python3from pwn import *import sysdef direction_search(word, grid, x, y, x_delta, y_delta):    tiles = []    for c in word:        if grid[y % len(grid)][x % len(grid)] != c:            return []        else:            tiles.append( (x, y) )        y += y_delta        x += x_delta    return tilesdef word_search(word, grid):    for (y, row) in enumerate(grid):        for (x, tile) in enumerate(row):            if tile == word[0]:                for x_delta in [-1, 0, 1]:                    for y_delta in [-1, 0, 1]:                        search = direction_search(word, grid, x, y, x_delta, y_delta)                        if len(search) &amp;gt; 0:                            return search    return []def main():    # Connect to the challenge server    port = int(sys.argv[1])    io = remote(&#39;challenge.ctf.games&#39;, port)        # Start a game    io.recvuntil(&#39;&amp;gt;&#39;)    io.send(&#39;play&#39;)    for _ in range(30):        # Skip header lines        print(io.recvline().decode(&#39;utf-8&#39;).strip())        io.recvlines(2)        # Process grid        grid = []        for _ in range(16):            grid.append( io.recvline().decode(&#39;utf-8&#39;).split()[2:] )        # Skip trailing lines        io.recvlines(2)        # Answer questions        for _ in range(5):            question = io.recvuntil(&#39;&amp;gt;&#39;).decode(&#39;utf-8&#39;)            word = question.split(&#39;:&#39;)[0].strip()            answer = word_search(word, grid)            io.sendline( str(answer).encode(&#39;utf-8&#39;) )                # Skip post-game lines        io.recvlines(3)    # Print the final output    print(io.recvrepeat(5).decode(&#39;utf-8&#39;))if __name__ == &quot;__main__&quot;:    main()OTP Smasher (283 points)This is a pretty interesting challenge because it requires us to do some optical character recognition (OCR). We’re presented with a simple webpage displaying a picture of numbers, an submission field, and a counter in the upper-left. Chrome DevTools also shows that the page also attempts to display the image static/flag.png. Based on the challenge’s name, the number picture might be intended to act as a one-time password (OTP). Submitting the OTP increments the upper-left counter by one and waiting too long to submit another OTP resets it to zero.While this challenge was up, the creator eventually decided to increase the length of time allowed until a reset to help make the challenge a bit easier. So right now, we could technically manually submit 45 passwords to get the flag. But of course, that is no fun learning-wise and no fun because it’s super tedious. Using Chrome DevTools, we were able to figure out the format of the submission: a POST request to the main page with the password in a field called otp_entry. Using this information, we are now able to automate OTP submissions.import requestsfrom bs4 import BeautifulSoup as bs# Send the current `otp` to the serverpost = requests.post(f&quot;http://challenge.ctf.games:{port}/&quot;, data={&quot;otp_entry&quot;:otp}) # Print out the current counter valueprint( bs(post.text, &#39;html.parser&#39;).p )The remaining problem is how to know what numbers to send? To accomplish this, we will make use of a software called Tesseract and its companion Python module, pytesseract. Combining this with the requests module to download the image and the PIL module to store the image, we can now automate OCR on the images to determine the OTP’s numbers.import requestsimport pytesseractfrom PIL import Imagefrom io import BytesIO# Retrieve the current OTP imageget = requests.get(f&quot;http://challenge.ctf.games:{port}/static/otp.png&quot;)# Save the image into a PIL Image objectimage = Image.open(BytesIO(get.content))# OCR the image to determine the OTPotp = pytesseract.image_to_string(image).strip()This gives us an 80% solution to the challenge. I say 80% because while it works most of the time, it fails enough that we have to manually step in every once in awhile. There’s probably a way to train tesseract to better recognize the OTP numbers, but we won’t dive into that realm for this challenge. For now, we’ll just check if the string from tesseract is a number. If it isn’t, then have the user type in the OTP manually.# See if we get an error when converting the OTP to a numbertry:  int(otp)except:  # If the OTP isn&#39;t a number, make the user type it in manually  otp = input(&quot;&amp;gt;&quot;)Now that all of our components are created, we can combine them into the final script that’ll automatically send the OTPs to the server until it sees the flag: flag{f994cd9c756675b743b10c44b32e36b6}.import requestsimport pytesseractimport sysfrom PIL import Imagefrom io import BytesIOfrom bs4 import BeautifulSoup as bsport = int(sys.argv[1])while True:    # Retrieve the current OTP image    get = requests.get(f&quot;http://challenge.ctf.games:{port}/static/otp.png&quot;)    # Save the image into a PIL Image object    image = Image.open(BytesIO(get.content))    # OCR the image to determine the OTP    otp = pytesseract.image_to_string(image).strip()    print(f&quot;OTP - {otp}&quot;)    # See if we get an error when converting the OTP to a number    try:        int(otp)    except:        # If the OTP isn&#39;t a number, make the user type it in manually        otp = input(&quot;&amp;gt;&quot;)    # Send the current `otp` to the server    post = requests.post(f&quot;http://challenge.ctf.games:{port}/&quot;, data={&quot;otp_entry&quot;:otp})     # Print out the current counter value    print( bs(post.text, &#39;html.parser&#39;).p )        # Check if the flag image is available yet    flag = requests.get(f&quot;http://challenge.ctf.games:{port}/static/flag.png&quot;)    if flag.status_code != 404:        # If we find the flag, save it and end the script        print(&quot;Flag found&quot;)        with open(&quot;flag.png&quot;, &quot;wb&quot;) as f:            f.write(flag.content)            exit()"
  },
  
  {
    "title": "Hack-A-Sat 2: tree in the forest",
    "url": "/posts/hackasat2-forest/",
    "categories": "CTF, HackASat2",
    "tags": "reverse_engineering",
    "date": "2021-06-29 22:00:00 -1000",
    





    "snippet": "tree in the forest (Rapid Unplanned Disassembly)Upon connecting to the challenge and providing our ticket, we’re presented with a simple message.Starting up Service on udp:18.222.149.188:12752We can connect to this server using nc -u 18.222.149.188 12752 and see what the challenge looks like. After experimenting with a bit of random input, we can quickly see that the server is expecting 8 bytes of input.$ nc -u 18.222.149.188 12752555555Invalid length of command header, expected 8 but got 75555555Command header acknowledge: version:13621 type:13621 id:171259189Invalid id:17125918955555555Command header acknowledge: version:13621 type:13621 id:892679477Invalid id:892679477The challenge page provides us with the source code (parser.c) for this server, which easily illuminates what’s going on. The server is expecting us to provide a command_header struct composed of three values:  A 16-bit integer for the version of the command. Not used within the program.  A 16-bit integer for the type of the command.  Not used within the program.  A 32-bit integer for the ID of the command. This is the only value used by the program. Valid IDs are defined within the command_id_type enum.Looking through the possible IDs, the most interesting one is COMMAND_GETKEYS with an ID of 9. This command is what will order the server to print out the flag. However, the server has locked down this functionality on startup using a variable lock_state initialized to LOCKED - a value of 1. Until we can set this variable to 0, the server will refuse to print out the flag.After analyzing the source code for this server, we discover the vulnerable portion of this code on line 134, which is:// Log the message in the command logcommand_log[header-&amp;gt;id]++;Under normal operations, this array is simply used to track how many times a certain command ID has been received. For instance, to see how many times COMMAND_GETKEYS has been issued, we would access command_log[9]. What makes this exploitable is that C and C++ do not perform bounds-checking by default when accessing an array. In addition, we have full control over what ID is sent to this line of code. So by providing a value outside the bounds of this array, such as negative values, we can modify any memory throughout the program.Our goal is to determine how many bytes before or after command_log is lock_state located. By knowing this, we will be able to determine the correct ID to use in order to modify the lock_state value. To assist in our analysis, we can compile the provided source code using g++ and debug it using gdb. But before doing this, we uncomment lines 157 and 158 to display the memory addresses for lock_state and command_log when we run the program.$ g++ parser.c$ ./a.outAddress of lock_state:       0x56070625c130Address of command_log: 0x56070625c138Trying to bind to socket.Bound to socket.Looking at this, we can see that lock_state is only 8 bytes behind command_log. So by sending an ID value of -8, we will be able to increment the lock_state variable by 1 on every command. The issue right now is that we can only increase the value of lock_state. Since lock_state starts at 1, we will need to overflow this byte in order to reach our desired value of 0. Thankfully, command_log is defined as an array of char values, so its max value is only 255.One thing to note is that until now, we’ve only been directly typing input for the server into a nc session. However, since the server only looks at the underlying bytes it receives, it’ll interpret our “-8” as 0x382d0000. So to send a properly formatted payload, we will need to create a simple Python script to construct our message at the byte-level and send it to the server. This is a very simple task using pwntools.from pwn import *io = remote(&#39;0.0.0.0&#39;, 54321, typ=&#39;udp&#39;)io.send( p16(1) + p16(1) + p32(-8, sign=&#39;signed&#39;) )print(io.recvline())print(io.recvline())Using this script, we can validate the exploitation method by examining the server’s memory with gdb. In the following demo, we send the malicious command_header a few times to demonstrate how we’re able to increment the lock_state variable.The next demo shows how the value overflows after 255 commands.Finally, we can send our GETKEYS command and retrieve the flag from the server. The following demo shows us running the final exploit script (forest.py):"
  },
  
  {
    "title": "All-Army CyberStakes 4 - Cryptography (Headpiece Silver)",
    "url": "/posts/acictf4-headpiece-silver/",
    "categories": "CTF, AllArmyCyberStakes4",
    "tags": "cryptography",
    "date": "2020-05-16 04:00:00 -1000",
    





    "snippet": "Headpiece Silver (250 Points)This challenge provides us with a server to interact with at challenge.acictf.com:30151. (Your port number may differ) To get started, lets see what this server is about by connecting to it using ncat.Based on this information given to us, this is clearly another RSA related challenge. The server provides us with the components for a public key, the public modulus N, and the public exponent e, which are:N: 122298190177919866881639090045815514691491489519639425496178483984084352945237e: 65537If we can derive the private key from this public key, we will be able to decrypt the encrypted password they provided to us, which is: 985be9b7b845a1a09a916437d767c30ae8d7ad4987cb77b0602b04889f7c2301Normally, computing the private key from just the public key is nearly impossible. However, what makes the key provided here different is in the key length. Most RSA keys are used today are 2048-bit keys, which are practically impossible for current computers to decrypt. But the key provided by the server is only around a 256-bit key, which is vastly weaker than what is needed for proper security. To fully compare the strengths of these two key lengths, we need to determine how many bits of security these keys would have. Since RSA is based on the factoring problem, brute-forcing an RSA key doesn’t require you to test all possible numbers, unlike AES where you’d need to check every possible key. So while AES-256 has 256-bit security, 2048-bit RSA key doesn’t have 2048-bit security.According to NIST (p. 54), a 2048-bit RSA key only offers about 112-bit security. And while 256-bit RSA is so weak that it isn’t even considered in the NIST publication, this StackExchange question tells us that 256-bit RSA only offers around 46-bit security. Each extra bit of security makes a key twice as secure, so 256-bit RSA is twice as easy to break than a key with 47-bit security. Now compared to 2048-bit RSA, 256-bit RSA is about 73 quintillion times easier to break, or 73,786,976,294,838,206,464 times easier.Now to how we can actually break the key. RsaCtfTool makes this task very easy. We can provide the public key components, N and e, and the ciphertext in decimal to this tool in order to quickly derive the private key and plaintext. (Note: It appears the challenge’s modulus is now in FactorDB, so RsaCtfTool isn’t conducting the full attack).We can see the plaintext password at the end of the unciphered data: 4n1a5ebRFmtyysAe. By providing this password to the server, we can retrieve the flag: ACI{ad94502b4d2437193e9c3fed364}Bonus SolutionAs it turns out, like many real-world systems, the challenge’s server has a misconfiguration vulnerability that allows you to skip all of this. What we didn’t check in the previous steps was the fourth option to test ciphertext. It appears that this was supposed to serve as a decryption oracle that decrypts whatever you provide it using the server’s private key. However, since the password ciphertext is encrypted with the public key, we are able to use this test function to simply have the server decrypt the password ciphertext itself."
  },
  
  {
    "title": "All-Army CyberStakes 4 - Cryptography (Speak Plainly)",
    "url": "/posts/acictf4-speakplainly/",
    "categories": "CTF, AllArmyCyberStakes4",
    "tags": "cryptography",
    "date": "2020-05-16 03:00:00 -1000",
    





    "snippet": "Speak Plainly (150 Points)This problem diverts from the previous ones by providing us with a website instead. The hints bring a lot of attention to the website’s login cookies, so we try creating an account and examining the created cookies. auth_token in particular stands out since it’s not a standard cookie that’s seen on other sites.    Creating an account.    The list of site cookies from the Chrome DevTools menu.After creating an account, the website tells us it’ll give us the flag after we provide it with the StrongToken. The home page has several information blocks that give us a few hints about what this could mean:    Information blocks from the website&#39;s main menu.      auth_token is encrypted with a 128-bit key in AES-ECB mode.        Prior to encryption, the site appends a StrongToken to the data and then encrypts it.  Since the site is using Electronic Code Book (ECB) mode, we can perform a chosen-plaintext attack by using the account creation process as an encryption oracle. This will allows us to extract the StrongToken, byte-by-byte. The entire attack process is well-explained in a blog post by Zach Grace.Since we’re going to be using the account creation feature quite a bit, we should figure out a way to make the process easier for us. Burp Suite has a feature called Repeater that allows us to save a web request and repeatedly modify and resend it, rather than repeating the process in the web browser.    Finding the web request to repeat in the history menu.    Selecting the Send to Repeater option.    Modifying the request and seeing the auth_token change in the response.Our first step is to figure out exactly what’s being encrypted. We know it comes from the account information, so there’s only two real options: the username and password. By testing out two accounts with the same username but different passwords, we can see that auth_token doesn’t change as long as the username stays the same. With this, we can determine that auth_token only uses the username in its encryption.testusername:password = 958af5df8adcc6bb0abf0473f6be9bb7684387617f292c4d7e1f689f7f5bf19dtestusername:newpass  = 958af5df8adcc6bb0abf0473f6be9bb7684387617f292c4d7e1f689f7f5bf19dThe next step is to determine the encryption block size. By testing out a few different inputs, we can quickly see that ciphertext is added in 16 byte blocks.AAAAAAAAAAAAAAA  (15 As) = a764ad6331f1ed698044b8f4bf208dd7 73ad7e84d6e3bb6e8c85112732e0160aAAAAAAAAAAAAAAAA (16 As) = e5a8d39cc17dd336ac0c0fd443ca5089 23101bd6e92b9703b48b69d5a1d01460 68a9e1b3e5368dc2725eb057cc397065Our next step is to figure out the offset between the start of the encrypted data, and where our input begins. We start by sending 2 blocks (32 bytes) of the same information, and then prepending that input with padding characters until we can see two blocks in a row of the same encrypted data. It will also let us estimate the size of the StrongToken by seeing how much many more blocks appear after the matching blocks.AAAAAAAAAAAAAAAA AAAAAAAAAAAAAAAA = e5a8d39cc17dd336ac0c0fd443ca5089 e5a8d39cc17dd336ac0c0fd443ca5089 23101bd6e92b9703b48b69d5a1d01460 68a9e1b3e5368dc2725eb057cc397065[None]                   = 23101bd6e92b9703b48b69d5a1d01460 68a9e1b3e5368dc2725eb057cc397065These results immediately show that there is no offset between the start of the plaintext and the username, since the first two blocks are already the same without any padding needed. Now that we know the block size and offset, we can begin brute-forcing the StrongToken. We first provide an input one byte smaller than the block size, AAAAAAAAAAAAAAA. This creates a ciphertext block using the plaintext AAAAAAAAAAAAAAA?, where ? is the first byte of the StrongToken. Using the ciphertext block provided by the website as a reference output, we can brute-force the first byte of the StrongToken. By using the reference input, AAAAAAAAAAAAAAA, and iterating through all possible characters for the last byte, we can determine what the StrongToken’s first byte when our output matches the reference output.Reference Value:AAAAAAAAAAAAAAA  = a764ad6331f1ed698044b8f4bf208dd7Brute-Forcing:AAAAAAAAAAAAAAA! = d4e420b6abd4e19033ed1fdea60dabdbAAAAAAAAAAAAAAA&quot; = caee4360f81620169c15d01da4064629[...snip...]AAAAAAAAAAAAAAA: = 0c775d6e025a1ad985ac8c339e261a47AAAAAAAAAAAAAAA; = a764ad6331f1ed698044b8f4bf208dd7** MATCH **By repeating this process and replacing more of the reference input with discovered StrongToken characters, we can slowly determine the StrongToken byte-by-byte. Using a Python script also makes this process less arduous. With this process, we are able to determine that the full StrongToken is fY5V/=B80?e4.CA8. (The initial character ; is only used as a divider between the plaintext and the StrongToken) By submitting the token to the website, we are able to receive the flag.Correct! The Flag is: ACI{c0db96acd85091480db76ed49ca}"
  },
  
  {
    "title": "All-Army CyberStakes 4 - Cryptography (Over Time: Paid)",
    "url": "/posts/acictf4-otp/",
    "categories": "CTF, AllArmyCyberStakes4",
    "tags": "cryptography",
    "date": "2020-05-15 02:00:00 -1000",
    





    "snippet": "Over Time: Paid (50 Points)This is where the challenges start getting more difficult. This problem starts with two files again: document.encrypted, which contains 15 lines of hex, and source.py, which contains what appears to be the script that generated the document. The script performs two key steps to create the document:      Generates the plaintext of the document with a static intro line, 10 random lines, a static outro line, and finally the flag.        Generates a random, 64-byte long key and XORs each line with it.  Based on the name of the challenge (Over Time: Paid), we can see that this method is inspired by how a One-time Pad works. One-time pads ensure complete and unbreakable secrecy for a message by encrypting it with a key of the same length, usually with the XOR operation. This encryption is only unbreakable if and only if that key is used for only that text and is never reused.The major weakness in this challenge’s implementation is that it only uses a 64-byte key to encrypt the entire message. Furthermore, since we know exactly what the first line is, we can extract the key using a known-plaintext attack, by virtue of how the XOR operation works. In XOR (\\(\\oplus\\)) encryption, we can encrypt plaintext (\\(P\\)) into ciphertext (\\(C\\)) by XORing the plaintext with a key (\\(K\\)).\\[P \\oplus K = C\\]To decrypt the ciphertext, we only need to XOR the ciphertext with the key.\\[C \\oplus K = P\\]However, the mathematical properties of XOR also allow us to compute the key by XORing the plaintext and ciphertext together.\\[P \\oplus C = K\\]In this challenge, the script provides us with a hardcoded intro statement, which is our plaintext for this attack. Since is the first line of text, we also know this corresponds to the first line of ciphertext in document.encrypted. By XORing these two lines together, we can compute the 64-byte key used throughout the encrypted document using CyberChef.Note: We also need to make sure the lengths of the plaintext and ciphertext match, so we have to remove the : at the end of the plaintext.Plaintext:  The following encoded individuals are to be given a $27.3k bonusCiphertext: 2246e0fe4f69ccb153f209b8cc73a5d87ce7cfdea8fa5ce35bb68b908e5a7e20f557810187bfc8b101a69b27edce27e15802d1f3eb7ef3dfb87eac2c6e12f4c0Key:        762e85de2906a0dd3c8560d6ab53c0b61f88abbbccda358d3fdffdf9ea2f1f4c8677e073e29fbcde21c4fe078aa751843622b0d3cf4cc4f18b158c4e017c81b3Finally, we can use this key in CyberChef to XOR the remaining lines and decrypt the entire document and extract the flag.[..snip..]Furthermore, the FLAG is:                                      ACI{6e6e41b658edba0f25eb5049ee1}                               "
  },
  
  {
    "title": "All-Army CyberStakes 4 - Cryptography (Really Senseless Admins)",
    "url": "/posts/acictf4-rsa/",
    "categories": "CTF, AllArmyCyberStakes4",
    "tags": "cryptography",
    "date": "2020-05-14 01:00:00 -1000",
    





    "snippet": "Really Senseless Admins (35 Points)Here, we are provided with two files: flag.enc, containing a very large decimal number, and params.txt, containing three decimal numbers, p, q, and e. Based on the challenge’s title (Really Senseless Admins), these numbers must be the parameters that generate the RSA private key which decrypts the flag. Using the tool provided by CrypTool, we can easily generate the key and decrypt the flag by simply copying and pasting the values into it. However, it’s still worthwhile to understand the underlying theory behind how RSA works, for both knowledge purposes and to help in a later challenge. You can read into it here.After decrypting the message contained in flag.enc, we get a slightly smaller decimal number. One thing to remember is that all information contained in memory is stored as and can by represented by a number. Hexadecimal numbers are used since it’s easy to represent individual bytes of data with it. Every 4-bits of data are represented by one hex number, so a byte (8-bits) is represented by two hex numbers. For example, the string ABCDE is represented in hex as 0x4142434445.We can also represent these hex numbers as a normal decimal number. If we convert the previous hex number into decimal, we can also write the string ABCDE as the number 280284578885. Keep in mind, this is an unusual way to represent strings since, unlike hex, a small change in any character will drastically change the entire decimal number. Changing the string to BBCDE causes it to become the number 284579546181, while its hex version simply sees a change in the first two places, 0x4242434445.To get the flag, we just need to apply this principle in the reverse direction: Convert the decimal number into hex and then decode each byte into its character equivalent. We can easily perform this task by using CyberChef again.Decimal Plaintext: 104873340459054924181115292546315913092670500490515826417481341Hex Plaintext:     0x4143497b5072316d33735f54214d337a5f34373533393062367dASCII Plaintext:   ACI{Pr1m3s_T!M3z_475390b6}"
  },
  
  {
    "title": "All-Army CyberStakes 4 - Cryptography (Rotate Me)",
    "url": "/posts/acictf4-rotateme/",
    "categories": "CTF, AllArmyCyberStakes4",
    "tags": "cryptography",
    "date": "2020-05-13 00:00:00 -1000",
    





    "snippet": "Rotate Me (5 Points)This one is a very simple problem, especially considering it’s only worth 5 points. We start with a text file that contains enciphered text, which already seems to be in the expected format of a flag.IKQ{KzGxBw_NcV_nWz_ItT_ScrflorN}Based on the name of the challenge and the hints mentioning “Julius”, it’s safe to assume that this is a Caesar cipher, also known as a Rotation (ROT-N) cipher. This is a very simple enciphering method where you “shift” each character to the right by N number of places. Going beyond “Z” just causes you to rotate back around to “A”, which is where the term Rotation cipher comes from. In order to decrypt the text, you just need to shift the characters the same number of places in the other direction to the left. For example, in a classic Caesar (or ROT-3) cipher the encryption and decryption process looks like this:Plaintext:  HELLO WORLDCiphertext: KHOOR ZRUOGSince you rotate back to “A” when you hit “Z”, anything above a ROT-25 cipher is equivalent to a cipher between ROT-0 to ROT-25. (You can calculate exactly what it’s equivalent to by computing N mod 26) This means that the total number of possible keys in a Caesar cipher is only 25. This is easily brute-forced by hand and is exceptionally trivial for a computer to crack. However, if we wanted to be fancy about it, we can crack it like a known-plaintext attack. We know that the first three characters have to be ACI. By comparing first letters of the plaintext and ciphertext, we can calculate that the key is 9 - 1 = 8, since A is the 1st character of the alphabet and I is the 9th. So by rotating to the left by 8 spaces (or 18 spaces to the right, since -8 mod 26 = 18), we can decrypt the flag. It’s easy to do this using a common tool such as CyberChef.Ciphertext: IKQ{KzGxBw_NcV_nWz_ItT_ScrflorN}Plaintext:  ACI{CrYpTo_FuN_fOr_AlL_KujxdgjF}"
  }
  
]

