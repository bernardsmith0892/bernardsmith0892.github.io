<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>All-Army CyberStakes 4 - Cryptography (Headpiece Silver) | Bernard Smith</title>
<meta name="generator" content="Jekyll v4.0.0" />
<meta property="og:title" content="All-Army CyberStakes 4 - Cryptography (Headpiece Silver)" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Headpiece Silver (250 Points) This challenge provides us with a server to interact with at challenge.acictf.com:30151. (Your port number may differ) To get started, lets see what this server is about by connecting to it using ncat. Based on this information given to us, this is clearly another RSA related challenge. The server provides us with the components for a public key, the public modulus N, and the public exponent e, which are: N: 122298190177919866881639090045815514691491489519639425496178483984084352945237 e: 65537 If we can derive the private key from this public key, we will be able to decrypt the encrypted password they provided to us, which is: 985be9b7b845a1a09a916437d767c30ae8d7ad4987cb77b0602b04889f7c2301 Normally, computing the private key from just the public key is nearly impossible. However, what makes the key provided here different is in the key length. Most RSA keys are used today are 2048-bit keys, which are practically impossible for current computers to decrypt. But the key provided by the server is only around a 256-bit key, which is vastly weaker than what is needed for proper security. To fully compare the strengths of these two key lengths, we need to determine how many bits of security these keys would have. Since RSA is based on the factoring problem, brute-forcing an RSA key doesn’t require you to test all possible numbers, unlike AES where you’d need to check every possible key. So while AES-256 has 256-bit security, 2048-bit RSA key doesn’t have 2048-bit security. According to NIST (p. 54), a 2048-bit RSA key only offers about 112-bit security. And while 256-bit RSA is so weak that it isn’t even considered in the NIST publication, this StackExchange question tells us that 256-bit RSA only offers around 46-bit security. Each extra bit of security makes a key twice as secure, so 256-bit RSA is twice as easy to break than a key with 47-bit security. Now compared to 2048-bit RSA, 256-bit RSA is about 73 quintillion times easier to break, or 73786976294838206464 times easier. Now to how we can actually break the key. RsaCtfTool makes this task very easy. We can provide the public key components, N and e, and the ciphertext in decimal to this tool in order to quickly derive the private key and plaintext. (Note: It appears the challenge’s modulus is now in FactorDB, so RsaCtfTool isn’t conducting the full attack). We can see the plaintext password at the end of the unciphered data: 4n1a5ebRFmtyysAe. By providing this password to the server, we can retrieve the flag: ACI{ad94502b4d2437193e9c3fed364} Bonus Solution As it turns out, like many real-world systems, the challenge’s server has a misconfiguration vulnerability that allows you to skip all of this. What we didn’t check in the previous steps was the fourth option to test ciphertext. It appears that this was supposed to serve as a decryption oracle that decrypts whatever you provide it using the server’s private key. However, since the password ciphertext is encrypted with the public key, we are able to use this test function to simply have the server decrypt the password ciphertext itself." />
<meta property="og:description" content="Headpiece Silver (250 Points) This challenge provides us with a server to interact with at challenge.acictf.com:30151. (Your port number may differ) To get started, lets see what this server is about by connecting to it using ncat. Based on this information given to us, this is clearly another RSA related challenge. The server provides us with the components for a public key, the public modulus N, and the public exponent e, which are: N: 122298190177919866881639090045815514691491489519639425496178483984084352945237 e: 65537 If we can derive the private key from this public key, we will be able to decrypt the encrypted password they provided to us, which is: 985be9b7b845a1a09a916437d767c30ae8d7ad4987cb77b0602b04889f7c2301 Normally, computing the private key from just the public key is nearly impossible. However, what makes the key provided here different is in the key length. Most RSA keys are used today are 2048-bit keys, which are practically impossible for current computers to decrypt. But the key provided by the server is only around a 256-bit key, which is vastly weaker than what is needed for proper security. To fully compare the strengths of these two key lengths, we need to determine how many bits of security these keys would have. Since RSA is based on the factoring problem, brute-forcing an RSA key doesn’t require you to test all possible numbers, unlike AES where you’d need to check every possible key. So while AES-256 has 256-bit security, 2048-bit RSA key doesn’t have 2048-bit security. According to NIST (p. 54), a 2048-bit RSA key only offers about 112-bit security. And while 256-bit RSA is so weak that it isn’t even considered in the NIST publication, this StackExchange question tells us that 256-bit RSA only offers around 46-bit security. Each extra bit of security makes a key twice as secure, so 256-bit RSA is twice as easy to break than a key with 47-bit security. Now compared to 2048-bit RSA, 256-bit RSA is about 73 quintillion times easier to break, or 73786976294838206464 times easier. Now to how we can actually break the key. RsaCtfTool makes this task very easy. We can provide the public key components, N and e, and the ciphertext in decimal to this tool in order to quickly derive the private key and plaintext. (Note: It appears the challenge’s modulus is now in FactorDB, so RsaCtfTool isn’t conducting the full attack). We can see the plaintext password at the end of the unciphered data: 4n1a5ebRFmtyysAe. By providing this password to the server, we can retrieve the flag: ACI{ad94502b4d2437193e9c3fed364} Bonus Solution As it turns out, like many real-world systems, the challenge’s server has a misconfiguration vulnerability that allows you to skip all of this. What we didn’t check in the previous steps was the fourth option to test ciphertext. It appears that this was supposed to serve as a decryption oracle that decrypts whatever you provide it using the server’s private key. However, since the password ciphertext is encrypted with the public key, we are able to use this test function to simply have the server decrypt the password ciphertext itself." />
<link rel="canonical" href="http://localhost:4000/acictf/ctf/cryptography/2020/05/13/acictf4-headpiece-silver.html" />
<meta property="og:url" content="http://localhost:4000/acictf/ctf/cryptography/2020/05/13/acictf4-headpiece-silver.html" />
<meta property="og:site_name" content="Bernard Smith" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-05-13T04:00:00-10:00" />
<script type="application/ld+json">
{"description":"Headpiece Silver (250 Points) This challenge provides us with a server to interact with at challenge.acictf.com:30151. (Your port number may differ) To get started, lets see what this server is about by connecting to it using ncat. Based on this information given to us, this is clearly another RSA related challenge. The server provides us with the components for a public key, the public modulus N, and the public exponent e, which are: N: 122298190177919866881639090045815514691491489519639425496178483984084352945237 e: 65537 If we can derive the private key from this public key, we will be able to decrypt the encrypted password they provided to us, which is: 985be9b7b845a1a09a916437d767c30ae8d7ad4987cb77b0602b04889f7c2301 Normally, computing the private key from just the public key is nearly impossible. However, what makes the key provided here different is in the key length. Most RSA keys are used today are 2048-bit keys, which are practically impossible for current computers to decrypt. But the key provided by the server is only around a 256-bit key, which is vastly weaker than what is needed for proper security. To fully compare the strengths of these two key lengths, we need to determine how many bits of security these keys would have. Since RSA is based on the factoring problem, brute-forcing an RSA key doesn’t require you to test all possible numbers, unlike AES where you’d need to check every possible key. So while AES-256 has 256-bit security, 2048-bit RSA key doesn’t have 2048-bit security. According to NIST (p. 54), a 2048-bit RSA key only offers about 112-bit security. And while 256-bit RSA is so weak that it isn’t even considered in the NIST publication, this StackExchange question tells us that 256-bit RSA only offers around 46-bit security. Each extra bit of security makes a key twice as secure, so 256-bit RSA is twice as easy to break than a key with 47-bit security. Now compared to 2048-bit RSA, 256-bit RSA is about 73 quintillion times easier to break, or 73786976294838206464 times easier. Now to how we can actually break the key. RsaCtfTool makes this task very easy. We can provide the public key components, N and e, and the ciphertext in decimal to this tool in order to quickly derive the private key and plaintext. (Note: It appears the challenge’s modulus is now in FactorDB, so RsaCtfTool isn’t conducting the full attack). We can see the plaintext password at the end of the unciphered data: 4n1a5ebRFmtyysAe. By providing this password to the server, we can retrieve the flag: ACI{ad94502b4d2437193e9c3fed364} Bonus Solution As it turns out, like many real-world systems, the challenge’s server has a misconfiguration vulnerability that allows you to skip all of this. What we didn’t check in the previous steps was the fourth option to test ciphertext. It appears that this was supposed to serve as a decryption oracle that decrypts whatever you provide it using the server’s private key. However, since the password ciphertext is encrypted with the public key, we are able to use this test function to simply have the server decrypt the password ciphertext itself.","@type":"BlogPosting","url":"http://localhost:4000/acictf/ctf/cryptography/2020/05/13/acictf4-headpiece-silver.html","headline":"All-Army CyberStakes 4 - Cryptography (Headpiece Silver)","dateModified":"2020-05-13T04:00:00-10:00","datePublished":"2020-05-13T04:00:00-10:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/acictf/ctf/cryptography/2020/05/13/acictf4-headpiece-silver.html"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Bernard Smith" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Bernard Smith</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a><a class="page-link" href="/projects/">Projects</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">All-Army CyberStakes 4 - Cryptography (Headpiece Silver)</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2020-05-13T04:00:00-10:00" itemprop="datePublished">May 13, 2020
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h1 id="headpiece-silver-250-points">Headpiece Silver (250 Points)</h1>

<p>This challenge provides us with a server to interact with at challenge.acictf.com:30151. (<em>Your port number may differ</em>) To get started, lets see what this server is about by connecting to it using <code class="highlighter-rouge">ncat</code>.</p>

<script id="asciicast-sNd3fjZW4f9c69nYw88Ieu4G8" src="https://asciinema.org/a/sNd3fjZW4f9c69nYw88Ieu4G8.js" async="" data-rows="20"></script>

<p>Based on this information given to us, this is clearly another <em>RSA</em> related challenge. The server provides us with the components for a <em>public key</em>, the public modulus <code class="highlighter-rouge">N</code>, and the public exponent <code class="highlighter-rouge">e</code>, which are:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>N: 122298190177919866881639090045815514691491489519639425496178483984084352945237
e: 65537
</code></pre></div></div>

<p>If we can derive the <em>private key</em> from this <em>public key</em>, we will be able to decrypt the encrypted password they provided to us, which is: <code class="highlighter-rouge">985be9b7b845a1a09a916437d767c30ae8d7ad4987cb77b0602b04889f7c2301</code></p>

<p>Normally, computing the <em>private key</em> from just the <em>public key</em> is nearly impossible. However, what makes the key provided here different is in the <em>key length</em>. Most RSA keys are used today are <strong>2048-bit</strong> keys, which are practically impossible for current computers to decrypt. But the key provided by the server is only around a <strong>256-bit</strong> key, which is vastly weaker than what is needed for proper security. To fully compare the strengths of these two key lengths, we need to determine how many <em>bits of security</em> these keys would have. Since RSA is based on the <em>factoring problem</em>, brute-forcing an RSA key doesn’t require you to test <strong>all</strong> possible numbers, unlike <a href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> where you’d need to check every possible key. So while <em>AES-256</em> has <em>256-bit security</em>, 2048-bit RSA key doesn’t have 2048-bit security.</p>

<p>According to <a href="https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-57pt1r5.pdf">NIST (p. 54)</a>, a 2048-bit RSA key only offers about <strong>112-bit security</strong>. And while 256-bit RSA is so weak that it isn’t even considered in the NIST publication, <a href="https://crypto.stackexchange.com/questions/8687/security-strength-of-rsa-in-relation-with-the-modulus-size">this StackExchange</a> question tells us that <a href="https://www.wolframalpha.com/input/?i=N%5BLog2%5BExp%5B%2864%2F9*Log%5B2%5E256%5D%29%5E%281%2F3%29*%28Log%5BLog%5B2%5E256%5D%5D%29%5E%282%2F3%29%5D%5D%5D">256-bit RSA</a> only offers around <strong>46-bit security</strong>. Each extra bit of security makes a key twice as secure, so 256-bit RSA is <em>twice</em> as easy to break than a key with <em>47-bit security</em>. Now compared to 2048-bit RSA, 256-bit RSA is about <em>73 quintillion</em> times easier to break, or <em>73786976294838206464</em> times easier.</p>

<p>Now to how we can actually break the key. <a href="https://github.com/Ganapati/RsaCtfTool">RsaCtfTool</a> makes this task very easy. We can provide the <em>public key</em> components, <code class="highlighter-rouge">N</code> and <code class="highlighter-rouge">e</code>, and the <em>ciphertext</em> in decimal to this tool in order to quickly derive the <em>private key</em> and <em>plaintext</em>. (<em>Note: It appears the challenge’s modulus is now in <a href="http://factordb.com/index.php?query=122298190177919866881639090045815514691491489519639425496178483984084352945237">FactorDB</a>, so RsaCtfTool isn’t conducting the full attack)</em>.</p>

<script id="asciicast-rfequzN91lhn6WrsCDyYnTD34" src="https://asciinema.org/a/rfequzN91lhn6WrsCDyYnTD34.js" async="" data-rows="20"></script>

<p>We can see the plaintext password at the end of the unciphered data: <code class="highlighter-rouge">4n1a5ebRFmtyysAe</code>. By providing this password to the server, we can retrieve the flag: <code class="highlighter-rouge">ACI{ad94502b4d2437193e9c3fed364}</code></p>

<script id="asciicast-jeYy2ox48alc3qVHwKL5BTufE" src="https://asciinema.org/a/jeYy2ox48alc3qVHwKL5BTufE.js" async="" data-rows="20"></script>

<h2 id="bonus-solution">Bonus Solution</h2>

<p>As it turns out, like many real-world systems, the challenge’s server has a <em>misconfiguration</em> vulnerability that allows you to skip all of this. What we didn’t check in the previous steps was the fourth option to <em>test ciphertext</em>. It appears that this was supposed to serve as a <em>decryption oracle</em> that decrypts whatever you provide it using the server’s private key. However, since the <em>password ciphertext</em> is encrypted with the public key, we are able to use this test function to simply have the server decrypt the password ciphertext itself.</p>

<script id="asciicast-2h6fYvAV9BvBDJYhw3PqUrtN2" src="https://asciinema.org/a/2h6fYvAV9BvBDJYhw3PqUrtN2.js" async="" data-rows="20"></script>


  </div><a class="u-url" href="/acictf/ctf/cryptography/2020/05/13/acictf4-headpiece-silver.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Bernard Smith</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Bernard Smith</li><li><a class="u-email" href="mailto:mail@brndjsmith.net">mail@brndjsmith.net</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/bernardsmith0892"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">bernardsmith0892</span></a></li><li><a href="https://www.linkedin.com/in/bernard-smith-27324257"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#linkedin"></use></svg> <span class="username">bernard-smith-27324257</span></a></li><li><a href="https://www.twitter.com/BernardSmith892"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">BernardSmith892</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Mostly technology-related</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
